[{"title":"Architecture","type":0,"sectionRef":"#","url":"docs/sfp-3.0/","content":"KaiOS Product is decoupled into two components : Core and App Profile. App Profile A collection of built-in web apps, which represents the user interfacing functions of KaiOS for a given device form factor. Core The underlying platform that consists of the Web application runtime, i.e. Gecko, plus the hardware adaptation layer and a few other supporting module.","keywords":""},{"title":"KaiOS History","type":0,"sectionRef":"#","url":"docs/sfp-3.0/01.introduction/history","content":"About KaiOS In just three years, KaiOS has become the world’s third-largest mobile operating system, running on over 130 million smart feature phones in over 100 countries worldwide. Here’s the story of our name, our connection with Firefox, and our purpose. Our name KaiOS isn’t the same as Firefox OS. Although our operating system is based on the original Mozilla project, KaiOS has evolved into something different. When the current stakeholders took over the project from Mozilla, we decided to look for a name that reflected our aspiration of creating a platform that was accessible to everyone. We wanted it to work in both Western and Asian languages. We chose Kai, which is Chinese for open – 开 (kāi). Kai is easy to pronounce in almost any language and captures the idea of being inclusive. Our mission Over four billion people in the world still have no internet access. That’s more than half of the world’s population left out of the digital revolution. What's keeping them disconnected? Smartphones are expensive. Data plans cost too much. Advanced touchscreen devices and apps are intimidating to first-time internet users. That’s where we come in. Through partnerships with carriers, manufacturers, and developers worldwide, we bring the best of smartphones to easy-to-use, affordable devices. Our smart feature phones enable outdoor workers, senior citizens, and families living in remote areas to take advantage of all that the internet has to offer to improve their lives. This includes apps that bring important and useful information on topics such as health, digital skills, personal finance, women empowerment, and more. We believe that access to the internet can change lives, which is why our team of 300 people around the world go to work every day – to help more people join the digital revolution. KaiOS, enable tomorrow","keywords":""},{"title":"3.0 Overview","type":0,"sectionRef":"#","url":"docs/sfp-3.0/01.introduction/overview","content":"New Gecko Using Gecko version 82.0(Aug. 28, 2020)Keep updating from upstream till FC (ETA Sep. 30, 2020)Gecko changes since version 48 FireFox Releases Mozilla abanden Firefox OS project since gecko 53, RD team take a lot efforts to bring those mobile device related APIs, system message, web activity, permission management, process manager, … back to new geckoEnhanced Service WorkerModern JS (ECMAScript 2021)PWA (Progress Web App) supportWebRenderWebAssemblyWebRTC and WebAudio improveWebGL 2 interface to OpenGL ES 3.0Quantum CSS (parallel CSS engine)TLS 1.0, 1.1 dropped (1.2,1.3 remain)Web Annimation APIWebP supportMedia capabilities APISpeech Sysnthesis APIWeb Authentication APIEncryped Media Extension API (EME)Accepts some Webkit prefixed properties and attributes New Gonk layer Adapt to Android HIDL interface Unify the hardware abstraction interfaces defined by GoogleMay ease the porting efforts if new android version or new chipset coming HIDL interface used by KaiOS3.0 android.hardware.gnss-2.0android.hardware.gnss.measurement_corrections-1.0android.hardware.gnss.visibility_control-1.0android.hardware.graphics.bufferqueue-2.0android.hardware.graphics.common-1.2android.hardware.media-1.0android.hardware.media.omx-1.0android.hardware.radio-1.0android.hardware.sensors-1.0android.hardware.vibrator-1.0android.hardware.wifi-1.3android.hardware.wifi.hostapd-1.1android.hardware.wifi.supplicant-1.2 Web API changes API domain name changeBeen moved to API-daemonDeprecated Web APIs NewKai-RIL design There are two RIL services design for KaiOS 2.5 Kai-RIL: used for non-QCT platforms, implemented and maintained by KaiOS.QC-RIL(b2g-RIL): For QCT platform only, implemented, maintained and released by QCT. Since QCT is giving up QC-RIL, we decided to adapt Kai-RL to all chip platflorms in 3.0 via HIDL interfaces. V2.5 RIL V3.0 RIL Service Worker change No permission neededClients.openApp is not supported, using Clients.openWindow by following W3C standardsSystemMessage API supported and onsystemmessage event is introducedCan inspect service workers script by Remote Debugging Geolocation change Geolocation API is following W3C standardsQCT provides iZat (Qualcomm Location) service in both 2.5 and 3.0In 2.5, iZat is tightened up on QC-RIL. It provides GPS, AGPS, Wifi positioning, Cell info location.In 3.0, Kai-RIL connect iZat through HIDL interface. QCT didn’t maintain Wifi positioning and use Skyhook in place.Using iZat service needs agreement from QCT in both 2.5 and 3.0. New Apps manager In KaiOS 3.0, mozApps API is removed and new apps manager is implemented in api-daemon. http://127.0.0.1/api/v1/apps/service.js webapps-manager permissionApp is launched with open api with url, Apps manager supports: App download/downloaded resumeInstall/sideload package appsInstall PWA appsUpdate/Uninstall appsApp signature checkGet apps list App types in KaiOS 3.0 Core App (certified app in 2.5) KaiOS native packaged apps, such as launcher app, settings app, calculator app and so on.stored in read-only /system, so can only be upgraded by FOTA.special app: store app and kai-pay app, store in /system, but copied to read-write /data, so can be upgraded without FOTA. Signed App (priviliged app in 2.5) 3rd party packaged app preinstalled in /system, but copied to read-write /data or download from store and store in /data, both can be upgraded without FOTA. PWA App (hosted app in 2.5) hosted 3rd apps from store or pwa webside App origin changed in KaiOS 3.0 “app://” are removed, all app origins are “https://”. For example, https://launcher.local for launcher app and https://example.com for PWAApp manager uses app origin and manifest to tell app types Core app: https://launcher.local + manifest property, core: trueSigned app: https://app_name.local without manifest property “core”PWA: https://example.com App manifest PWA manifest w3c spec: https://w3c.github.io/manifest/ (firefox 82)Non-normative(B2G): https://w3c.github.io/manifest/#proprietary-extensions (b2g_features)File extension The latest w3c spec[1] says .webmanifest is the official file extension for web apps, but we do have .webapp and .json before the spec defined it. App manifest required name or short_name: stringdescription: stringlang: Stringtheme_color: stringbackground_color: stringorientation: stringstart_url: stringicons: Array of object App manifest optinal dir: stringscope: stringdisplay: stringorientation: stringrelated_applications: Array of object Permission Management The permission manageent mechanism is the same in between 2.5 and 3.0.But the default permission table is changed in 3.0 Progressive Web Application support (PWA) No significant changes but better to check the support from MDN before using any PWA API. Gaia Change We replace the build runtime from XPCShell to nodejs, but no changes on the build usage/logic/options.We have moved lots of js/resources from gaia/shared to shared app. Now can import from https://shared.local instead of copying to app's application.zip.","keywords":""},{"title":"Technologies","type":0,"sectionRef":"#","url":"docs/sfp-3.0/01.introduction/technologies","content":"KaiOS apps are based on web technologies – HTML, CSS, and JavaScript and are run by Gecko runtime. If you have written a web page you already know the basics. Rendering is done by parsing HTML/CSS and painted using graphic APIs. JavaScript are executed by the JS engine SpiderMonkey and connected to C++ components by XPConnect and WebIDL bindings. Applications and the core process communicate only through IPC protocols defined by IPDL. Additionally a set of core components including file and memory management, threads and data structures etc. are provided through the XPCOM component object model.","keywords":""},{"title":"Development Environment","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/01.env-setup/development-env","content":"Text editor / Integrated Development Environment (IDE) Visual Studio Code Visual Studio Code is a source code editor developed by Microsoft for Windows, Linux and macOS. It includes support for debugging, embedded Git control, syntax highlighting, intelligent code complementation, snippets, and code refactoring. It is also customizable, allowing users to change the editor theme, shortcut keys, and preferences. WebStorm WebStorm is a cross-platform IDE primarily for web, JavaScript and TypeScript development. Many of JetBrain's other IDEs include the feature set of WebStorm via plugins. Atom Atom is an open source text editor available for Linux, MacOS and Microsoft Windows platforms, developed by GitHub under the MIT license. The tool was created using Electron and web technologies like HTML, JavaScript and CSS. Allows the installation of extensions developed with Node.js. Sublime Text Sublime Text is a multiplatform text editing software, however used by many developers to edit source code. Vim Vim is designed for use both from a command-line interface and as a standalone application in a graphical user interface. Vim is free and open-source software and is released under a license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. Node To get started, you need to have the node installed on your computer, if you do not have it on your computer, follow these steps, choosing your operating system. Install Yarn (Optional) Yarn is a JavaScript Package Manager, a direct competitor of npm, and it’s one of the Facebook Open Source projects. It’s compatible with npm packages, so it has the great advantage of being a drop-in replacement for npm. When it launched it used to be way faster than npm due to parallel download and caching, to install follow these steps. Git Git is a file version control system. Through Git, we can develop projects in which multiple people can simultaneously contribute to the same by editing and creating new files and allowing them to exist without the risk of their changes being overwritten. Follow the steps in the documentation to install.","keywords":""},{"title":"OS ENV Setup","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/01.env-setup/os-env-setup","content":"Instructions for users who have access to a debug device Windows Install Firefox Download firefox v59 before installing make sure the previous version of firefox is uninstalled. Disabling auto updates once Firefox is installed. (Menu -> options -> general) Install ADB Visit this Google page to Download the ADB ZIP file for Windows. Unzip the folder on your Windows C Drive (C:\\platform-tools). Connecting to Device Connect your device with the laptop using USB cable. Make sure it is in debug mode. Open the Settings app and follow this flow: Device > Developer > Debugger > ADB and DevTools Open command prompt of your laptop. Run $ cd /path/to/extracted/folder/ Run $ adb devices You should see your device has been detected. Run $ adb root $ adb forward tcp:6000 localfilesystem:/data/local/debugger-socket This is to establish a path between your device and the laptop. Open Firefox Web IDE. Click on “Remote Runtime” on the right side. Press “OK”. A warning about old connected runtime version would pop up. Ignore it. You are ready to install an app on your device Install your first app Open Firefox Web IDE and make sure you have connected your device and executed the commands $ adb root $ adb forward tcp:6000 localfilesystem:/data/local/debugger-socket If you have packaged app stored on your laptop, click “Open Packaged App” on the left side and select your project folder. Your project folder must have a manifest.webapp file. Otherwise, the IDE cannot open your app. Check here to create manifest.webapp file. After selecting your app, you should be able to see your app. Install the app on your device with RUN button and Debugger button to debug top center of WebIDE. Install the app. Then, you are available to use the basic tools in the web IDE for development, such as Inspector, Console, JavaScript Debugger, Style Editor, Scratchpad. macOS Install ADB You can follow this link install ADB tools for macOS. Install and Run app Download firefox v59 open terminal and run these commands $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" $ brew cask install android-platform-tools connect device and run adb devices You should see 1 device connected. disconnect from internet, install downloaded firefox, go to prefferences and disable updates (download or check): Connect to internet Go to about:config, turn the following preferences: xpinstall.signatures.required = false, extensions.legacy.enabled = true Go to this link and download install adb helper In Firefox Tools > Add on > Extension and add the downloaded adb_helper.xpi file In firefox go to Tools > Web Developer > WebIDE On right should see \"USB Devices\" and should have one device On the left have \"Open Packaged App\" - click it, and choose some app (a folder) Middle top click the play button... that's it, app should be on your phone and you should notice it. Linux Install Firefox You will need to get the Firefox v59 or older version for KaiOS implementations, to download these versions, you can get them through Mozilla FTP. After downloading the chosen version, you must unpack the package with the command: $ tar jxvf firefox-*.tar.bz2 -C /opt Create a shortcut to facilitate program execution $ sudo ln -sf /opt/firefox/firefox /usr/bin/firefox Setting WebIDE Firefox's WebIDE is a necessary development tool to inspect your app, as well as see the console, debugger, and others. Follow the instructions in WebIDE to setup and learn more about WebIDE. Installing make(Optional) Make is a necessary tool to run KaiOS. Execute the following commands on the terminal to install it. $ wget http://ftp.us.debian.org/debian/pool/main/m/make-dfsg/make_3.81-8.2_amd64.deb $ sudo dpkg -i make_3.81-8.2_amd64.deb $ sudo apt-mark hold make Setting the required architectures(Optional) $ sudo dpkg --add-architecture i386 $ sudo dpkg --add-architecture amd64 Installing dependencies(Optional) There are some necessary dependencies to complete your environment for running Gaia. Execute the command below on your terminal and all these dependencies will be installed. $ sudo apt install --no-install-recommends autoconf2.13 bison bzip2 ccache curl flex gawk gcc g++ g++-multilib git lib32ncurses5-dev lib32z1-dev libgconf2-dev zlib1g:amd64 zlib1g-dev:amd64 zlib1g:i386 zlib1g-dev:i386 libgl1-mesa-dev libx11-dev make zip lzop libxml2-utils openjdk-8-jdk nodejs unzip python Setting ccache(Optional) $ ccache -M 10G Installing ADB and fastboot $ sudo apt install android-tools-adb android-tools-fastboot Setting USB access $ wget -S -O - https://raw.githubusercontent.com/cm-b2g/B2G/1230463/tools/51-android.rules | sudo tee >/dev/null /etc/udev/rules.d/51-android.rules; sudo udevadm control --reload-rules Plug the device in your computer using a USB cable Use the command $ lsusb on the terminal to get the Vendor ID. Example of a result: Bus 001 Device 014: ID 22b8:2e76 Motorola PCS ===> vendor ID is 22b8 Log in as root and edit this file: /etc/udev/rules.d/51-android.rules In the file above put a new line using the vendor ID that you got before. Example: SUBSYSTEM==\"usb\", ATTR{idVendor}==\"22b8\", MODE=\"0666\", GROUP=\"plugdev\" Now execute: $ sudo chmod a+r /etc/udev/rules.d/51-android.rules Create the following file in your HOME dir (not as root) $ nano ~/.android/adb_usb.ini Put the value of vendor ID on this file using hex format. Example: 0x22b8, where 22b8 is the vendor ID that you got before. Use the command 'adb devices' on the terminal to list all devices connected on your PC. Your device should be listed and is ready to receive Gaia apps or use it on WebIDE. Connection Errors For more information about the ADB connection fail error see this link This extension will re-enable extensions that were disabled on May 3, 2019 for Firefox versions 52 - 56.","keywords":""},{"title":"Simulator","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/01.env-setup/simulator","content":"The simulator lets you run Gaia and Web apps in a Gecko-based environment somewhat similar to an actual device. It doesn't emulate device hardware, so it's not adequate for testing device APIs and it isn't a replacement for testing on actual hardware. It can, therefore, be useful during the development of your application, or while working on the application user interface itself. This article covers downloading of the simulator, as well as how to use it. Resources Linux Simulator Build Release information Revision: kaiosrt-v2.5-ubuntu_Sep19 (Sep. 2019) Release note: Support Ubuntu.Embed adb in simulator debugger feature and support debugging device with simulator.UI modification.Screenshot function supported.Fix app uninstall function(from option menu).By design: Only support system and basic app (Settings) for development.Only support PC keyboard to type text, can’t input text with keypad.Hardware related function not supported, ex. BT, Modem related, GPS, etc.In web view design, developer can click on device screen to focus and scroll. In native view, developer can use D-pad to go up/down/left/right. Known issues: Contacts function is not working.When device is become black and no response, click on device screen to wake it up. Launch KaiOS Runtime (Kaiosrt) app Linux Unzip the Kaiosrt_ubuntu.zip file firstEnter the kaiosrt folderRun kaiosrt file Create a new app With Kaiosrt opened, click on New App... on the left side Choose a template and name your project Name the project and select the folder to save it Install and run the app After app is created, click on the Install and run button (the play icon at the top of the Kaiosrt window) Kaiosrt will be updated as below Debugging runtime apps Click on the Debug App button (the wrench icon at the top of the Kaiosrt window) and the console panel will show up below it","keywords":""},{"title":"Manifest","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/02.main-concepts/manifest","content":"The manifest.webapp file provides important information about the app, such as version, name, description, icon location, locale strings, domains the app can be installed from, and much more. Most importantly, it contains a list of APIs that your app needs. This allows users to make informed decisions about apps before installing them. Your app's manifest.webapp file should be placed in the root of your app directory, and contain a simple JSON structure. A simple App Manifest JSON looks like this: { \"version\": \"1.0.0\", \"name\": \"KaiOS App\", \"description\": \"A file simple example manifest.webapp\", \"type\": \"web\", \"launch_path\": \"/your/repository/index.html\", \"icons\": { \"56\": \"/your/repository/icons/ic_Appname_56.png\", \"112\": \"/your/repository/icons/ic_Appname_112.png\" }, \"developer\": { \"name\": \"Your Name\", \"url\": \"http://yourawesomeapp.com\" }, \"locales\": { \"en-US\": { \"name\": \"KaiOS App\", \"subtitle\": \"Short description for the user\", \"description\": \"Brief description of your app\" } }, \"default_locale\": \"en-US\" } Required fields The fields in your manifest can be in any order. Fields in the manifest other than the ones listed below will be ignored. name Note: Required for all app manifests. A human-readable name for the app. Maximum length is 20 characters. If you change the name of your app after distribution, the name will not be updated for any existing installations. \"name\": \"The Open Web!\" version A specialized string that represents the version of the app. Must be integers separated by dots. \"version\": \"1.2.0\" description Note: Required for all app manifests. A human-readable description for the app. It should be a short and strong message. \"description\": \"My elevator pitch goes here\" icons Note: One icon sized 56×56 is required for all app manifests. One icon sized 112×112 is recommended for all app manifests. A map of icon sizes to URIs of the icons. Remember that internal paths to icons must be absolute from the app's origin, while paths to externally hosted icons must be fully qualified. Icons must be square and in .png format. Icons should not have solid backgrounds that extend to all four corners of the icon. For more details about app icon check Launcher Icon section in Design Guide. \"icons\": { \"56\": \"/img/ic_Appname_56.png\", \"112\": \"/img/ic_Appname_112.jpg\" } developer Note: Only the name is required for all app manifests. name: The name of the developer. Required for all app manifests.url: The URL of a website containing information about the app's developer. Optional. \"developer\": { \"name\": \"The Open Web!\", \"url\": \"http://www.mywebapp.com\" } localesA map of one or more language-specific overrides of the field values in your app manifest. Keys for locales use the same language tags as for default_locale (RFC 4646). \"locales\": { \"it-IT\": { \"name\": \"L'Open Web\", \"description\": \"Eccitante azione di sviluppo web open!\" }, \"de-DE\": { \"name\": \"Der Open Web\", \"description\": \"Spannende offene Web-Entwicklung-Action!\" } } default_locale A language tag (RFC 4646) that defines the language you used in the field values of your app manifest. Please refer to the list below of language identification codes used in the KaiOS system. We strongly suggest to use the same language identification codes throughout to avoid misalignment issues or incorrect results when users change language settings in the system: af-ZA\tAfrikaans ar-SA\tعربي az-Latn-AZ\tAzərbaycan be-BY\tБеларуская bg-BG\tБългарски bn-IN\tবাংলা (IN) bn-BD\tবাংলা-BD bs-BA\tBosanski cs-CZ\tČesky da-DK\tDansk de-DE\tDeutsch el-GR\tΕλληνικά en-GB\tEnglish (GB) en-US\tEnglish (US) es-US\tEspañol (US) et-EE\tEesti es-ES\tEspañol (ES) fa-IR\tفارسی (IR) fi-FI\tSuomi fil-PH\tTagalog fr-CA\tFrench (CA) fr-FR\tFrançais (FR) he-IL\tעברית hi-HI\tहिन्दी hr-HR\tHrvatski hu-HU\tMagyar hy-AM\tՀայերեն id-ID\tBahasa Indonesia is-IS\tÍslenska it-IT\tItaliano It-LT\tLietuvių ka-GE\tქართული kk-KZ\tҚазақша km-KH\tភាសាខ្មែរ lo-LA\tລາວ lv-LV\tLatviešu mk-MK\tМакедонски mo-RO\tМолдовеняскэ ms-MY\tMelayu nb-NO\tNorsk (bokmål) ne-IN\tनेपाली nl-NL\tNederlands pl-PL\tPolski ps-AF\tپښتو pt-BR\tPortuguês (do Brasil) pt-PT\tPortuguês (Europeu) ro-RO\tRomână ru-RU\tРусский si-LK\tසිංහල sk-SK\tSlovenčina sl-SI\tSlovenščina sq-AL\tShqip sr-Latn-CS\tСрпски/Srpski sv-SE\tSvenska sw-ZA\tKiswahili ta-IN\tதமிழ் th-TH\tไทย tr-TR\tTürkçe uk-UA\tУкраїнська ur-PK\tاردو uz-Cyrl-UZ\tO'zbek vi-VN\tTiếng Việt xh-ZA\tisiXhosa zh-CN\t中文 (简体) zh-HK\t中文-HK zh-TW\t中文-TW zu-ZA\tisiZulu as-IN\tঅসমীয়া und-bod\tबोड़ो doi-IN\tडोगरी gu-IN\tગુજરાતી kn-IN\tಕನ್ನಡ ks-IN\tکأشُر kok-IN\tकोंकणी mai-IN\tमैथिली ml-IN\tമലയാളം mni-IN\tমণিপুরী mr-IN\tमराठी or-IN\tଓଡ଼ିଆ pa-IN\tਪੰਜਾਬੀ sa-IN\tसंस्कृत sat-IN\tᱥᱟᱱᱛᱟᱞᱤ sd-IN\tसिन्धी te-IN\tతెలుగు ko-KR\t한국어\" For example, if your app uses English, it's default_locale would be: \"default_locale\": \"en-US\" type The app's type, which defines its level of access to sensitive device APIs. If you do not define type, it will default to web as the type. web: A regular hosted app. This type has the least access to APIs. privileged: An authenticated app that has been approved by an app store such as the KaiStore. This type has greater access to APIs than a web app. subtitleYour app’s subtitle appears below your app name throughout the KaiStore. A subtitle is a short and striking or memorable message, and is intended to summarize your app in a concise phrase. A compelling subtitle can encourage product page views and installs. The maximum length of a subtitle is 40 characters. categoriesYour app's categories represent different categories that your app should be belongs to in the KaiStore. We have defined different type of Store apps. You must choose at least one type for your app. social gamesutilitieslife styleentertainmenthealthsportsbook/reference \"categories\": [ \"health\", \"sports\" ], Optional fields The following fields are optional. short_nameA human-readable name for the app. Can differ from name field. bgsA map of background images sizes to URIs of the icons. \"bgs\": { \"56\": \"/img/ic_Appname_56.png\", \"112\": \"/img/ic_Appname_112.jpg\" } launch_pathThe path within the app's origin that is loaded when the app starts. Specifies the starting point of the content local to the zip file containing the packaged app. For example, if the launch_path is /mywebapp/index.html, the app will open the file at /mywebapp/index.html when the app is launched. Tips: If your app is stored in the root of a Web server, for example mywebapp.github.com/, then launch_path must be set to /. If your app is stored in a subdirectory, for example mymarket.github.com/mywebapp/, then launch_path must be set to /mywebapp/. \"launch_path\": \"/index.html\" origin Note: Applies only to privileged or internal (certified) packaged apps. Packaged apps have a special internal protocol of app://UUID where UUID is a string unique to each device the app is installed on. UUID is not easily accessible at this time. The origin field allows you to replace this UUID value with a single domain name that will be used by each installed app. Remember: domain name must start with app://, and you must be the owner of the domain name you specify. \"origin\": \"app://mywebapp.com\" permissionsThe user permissions for sensitive device APIs that your app needs, for example, access to the user's Contacts. See a full list of API permissions/features. Each permission requires: name: the name of the permission description: the reason why your app needs to use this permission access: the level of access required, options being readonly, readwrite, readcreate, and createonly. Only a few APIs need this, for example Data Store. For example, here's a manifest entry for an app that needs permission to use the device's contacts and alarms. \"permissions\": { \"contacts\": { \"description\": \"Required for autocompletion in the share screen\", \"access\": \"readcreate\" }, \"alarms\": { \"description\": \"Required to schedule notifications\" } } Note: If an app tries to use one of these APIs without a corresponding entry in the permissions field, it will fail to run. There are many APIs, some of whom require the app type to be privileged or internal (certified). For example, systemXHR requires the type field to be set to privileged in order to work: \"type\": \"privileged\", \"permissions\": { \"systemXHR\": { \"description\": \"Required to download podcasts.\" } } fullscreenA control that tells the runtime whether or not to launch the app in full-screen mode. \"fullscreen\": \"true\" datastores-owned Note: Applies only to privileged/certified apps to be installed on KaiOS. When making use of the Data Store API, the app that owns the data store MUST include the datastores-owned field in its manifest to claim ownership, for example: \"datastores-owned\": { \"myData\": { \"access\": \"readwrite\", \"description\": \"my data store\" } } You can include multiple properties to represent different data stores, and each one can use an access of readonly/readwrite to specify whether the data store can be read/modified by other applications. A description is also included to describe the purpose of the data store. datastores-access Note: Applies only to privileged/certified apps to be installed on KaiOS. When making use of the Data Store API, any non-owner app that wants access to the the data store MUST include the datastores-access field in its manifest, for example: \"datastores-access\": { \"myData\": { \"access\": \"readwrite\", \"description\": \"Read and modify my data store\" } } Without this field being specified, the default behaviour is \"no access\". Again, multiple properties can be included if you want to access multiple data stores, and an access of readonly or readwrite can be set to declare what access type is needed by the app. messages Note: Applies only to apps to be installed on KaiOS. The system messages you allow the app to capture, and the pages in your app that will display when those messages occur. Below is an example from the KaiOS Dialer app. Every time an incoming call comes in (system message: telephony-new-call), the device shows the dialer's keypad (URL: /dialer/index.html#keyboard-view). \"messages\": [ { \"alarm\": \"/index.html\" } { \"notification\": \"/index.html\" } { \"telephony-new-call\": \"/dialer/index.html#keyboard-view\" } ] redirects Note: Applies only to privileged/certified apps that are to be installed on KaiOS. The internal URLs your app uses to handle external processes. For example, your app might use Facebook OAuth authentication to get a user's contacts. When the authentication is finished, the server usually redirects back to a URL that you control. Because packaged apps are not hosted on the web, a packaged app does not have a valid URL that can be redirected to. So you use the redirects field to redirect an external URL to an internal app URL. In the scenario above, the redirects field will look like this: \"redirects\": [ { \"from\": \"http://facebook.com/authentication/success.html\", \"to\": \"/app/main_interface.html\" } ] The scope of the redirects declared by redirects is limited to the app that declares them. That makes it so that several apps can redirect the same public URL to their own local resources, and it also prevents global hijacking of public URLs by an application. activitiesA set of Web Activities that your app supports (full list). It's structured like so: Each property in this field is an activityActivity names are free-form textEach activity is represented by an object For example, here's an entry with one activity named share. \"activities\": { \"share\": { \"filters\": { \"type\": [ \"image/png\", \"image/gif\" ] }, \"href\": \"foo.html\", \"disposition\": \"window\", \"returnValue\": true } } The object for the share activity in the example has filters, href, disposition and returnValue properties. These are described in Activity handler description. precompileThe path to JavaScript files containing asm.js code that you want compiled at install time. Compilation at install time makes the installation process longer, but reduces the time it takes to start up an app. \"precompile\": [ \"game.js\", \"database.js\" ] orientationThe positioning at which the application will stay locked. Illustration of possible values: Value\tApp will stay locked toportrait-primary portrait-secondary portrait landscape-primary landscape-secondary landscape \"orientation\": [ \"landscape-primary\" ] cspThis field can be used to define a Content Security Policy (CSP) that is applied to all pages in the app. The policies you can add to a CSP are listed in CSP policy directives, and for an app you'll need to include them in a line like so: \"csp\" : \"default-src *; script-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline'\" The default policies applied to KaiOS privileged and internal/certified apps are as follows: Privileged CSP default-src *; script-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' Certified/Internal CSP default-src *; script-src 'self'; object-src 'none'; style-src 'self' These defaults can’t be overridden, only added to, i.e. the CSP policy in the manifest can only make the actual CSP applied more restrictive in the case of privileged/internal apps. Serving manifest Note: This is applied to 'hosted app URL' The app manifest must be served from the same origin that the app is served from. The manifest should be stored with a file extension of .webapp. App manifests must be served with a Content-Type header of application/x-web-app-manifest+json. This is currently enforced by the KaiStore. The KaiStore only checks this if the origin of the page where the user triggers the install is different from the origin of the app itself. You don't need other headers such as Content-Security-Policy and X-UA-Compatible. Manifests can be served over SSL to mitigate certain classes of attacks. You can also serve the manifest with HTTP compression. The manifest should not be cached. The manifest must be in UTF-8 encoding in order for the app to be submitted to the KaiStore. It is recommended that you omit the byte order mark (BOM). Other encodings can be specified with a charset parameter on the Content-Type header. User Agents when possible should meaningfully message the site identity and TLS status when prompting a user to install an app. China Type Approval (CTA), and how does it affect your apps on the KaiStore According to the new regulation, when the users in China install an app from the KaiStore, the app needs to pop up a confirmation window to let users accept or deny the operation like data connection, Wi-Fi connection, access call log. If your app uses KaiAds, Analytics, leaderboards, or any features that need connection to the internet, then you will be required to update the app. Please modify the manifest file of your app in according to the below conditions: If your apps do not need a network connection or call log request, there is no need to make any modifications. Privilege app in Store that needs network connection or call log, should add below permissions in the app’s manifest.webapp file. \"permissions\": { \"mobiledata\":{}, \"wifidata\":{}, \"calllog\":{} } Web and Hosted apps in Store that needs a network connection, it should add the below permissions in the app’s manifest.webapp file. \"Permissions\": { \"mobiledata\":{}, \"wifidata\":{} }, Certified app does not need any modifications The affected OS versions are KaiOS/2.5.2.1 and KaiOS/2.5.4.1 which will be used in the China market, and in case your apps do not have the requested permissions, they won’t be published in these two OS versions.These changes do not affect any of the existing devices and users.","keywords":""},{"title":"Security access level","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/02.main-concepts/security-access-level","content":"In this section you will have an overview of KaiOS security framework, which is designed to protect mobile devices from threats to the platform, apps, and data. KaiOS has implemented a comprehensive security model, integrated, and multi-layered security model that delivers best-of-breed protection against security risks to mobile phones. Platform Security The KaiOS platform uses a multi-layered security model that is designed to mitigate exploitation risks at every level. Front-line countermeasures are combined with a defense-in-depth strategy that provides comprehensive protection against threats. The KaiOS connects web-based applications to the underlying hardware. It is an integrated technology stack consisting of the following levels: Gaia: The suite of web apps that make up the user experience (apps consist of HTML5, CSS, JavaScript, images, media, and so on).Gecko: The application runtime layer that provides the framework for app execution, and implements the Web APIs used to access features in the mobile device.Gonk: The underlying Linux kernel, system libraries, firmware, and device drivers that everything runs on top of.The mobile device: The mobile phone running KaiOS. Gecko is the gatekeeper that enforces security policies designed to protect the mobile device from misuse. The Gecko layer acts as the intermediary between web apps (at the Gaia layer) and the phone. Gonk delivers features of the underlying mobile phone hardware directly to the Gecko layer. Web apps access mobile phone functionality only through the Web APIs, and only if Gecko allows the access request — there is no direct access, no “back door” into the phone. Gecko enforces permissions and prevents access to unauthorized requests. App Security KaiOS uses a defense-in-depth security strategy to protect the mobile phone from intrusive or malicious applications. This strategy employs a variety of mechanisms, including implicit permission levels based on an app trust model, sandboxed execution at run time, API-only access to the underlying mobile phone hardware, a robust permissions model, and secure installation and update processes. For technical details, refer to Application security. In KaiOS, all applications are web apps — programs written using HTML5, JavaScript, CSS, media, and other open web technologies (pages running within the browser are not referred to as web apps in this context). Because there are no binary (\"native\") applications installed by the user, all system access is mediated strictly through the Web APIs. Even access to the file system happens only through Web APIs and a back-end SQLite database — there is no direct access from apps to files stored on the SD card. KaiOS limits and enforces the scope of resources that can be accessed or used by an app, while also supporting a wide range of apps with varying permission levels. Mozilla has implemented tight control over what type of applications can access which APIs. For example, only certified apps (shipped with the phone) can have access to the Telephony API. The Dialer app has privileges to access the Telephony API in order to make phone calls, but not all certified apps can access this API. This prevents a situation, for example, in which an arbitrary third-party app gets installed, dials a pay-per-use phone number (900 and 910), and racks up a large cell phone bill. Other OEM apps might be selectively given access to the Telephony API, however. For example, an operator might provide a systems management application that allows a customer to manage their account, including the ability to phone the Operator’s billing or support office directly. Trusted and Untrusted Apps KaiOS categorizes apps according to the following types: Type\tTrust Level\tDescriptionCertified\tHighly Trusted\tSystem apps that have been approved by the Operator or OEM (due to risk of device corruption or risk to critical functionality). System apps and services only; not intended for third-party applications. This designation is reserved for just a small number of critical applications. Examples: SMS, Bluetooth, camera, system clock, telephony, and the default dialer (to ensure that emergency services are always accessible). Privileged\tTrusted\tThird-party apps that have been reviewed, approved, and digitally signed by an authorized KaiStore. Web (everything else)\tUntrusted\tRegular web content. Includes both installed apps (stored on the mobile phone) and hosted apps (stored remotely, with only an app manifest stored on the mobile phone). The manifest for hosted apps can be obtained through a KaiStore. An application’s trust level determines, in part, its ability to access mobile phone functionality. Certified apps have permissions to most Web API operations.Privileged apps have permissions to a subset of the Web API operations accessible to Certified apps.Untrusted apps have permissions to a subset of the Web API operations accessible to Privileged apps — only those Web APIs that contain sufficient security mitigations to be exposed to untrusted web content. Some operations, such as network access, are assumed to be an implicit permission for all apps. In general, the more sensitive the operation (for example, dialing a phone number or accessing the Contacts list), the higher the app trust level required to execute it. Note: for more information on the APIs available and their permission levels, consult App permissions. Principle of Least Permissions For web apps, the KaiOS security framework follows the principle of least permissions: start with the absolute minimum permissions, then selectively grant additional privileges only when required and reasonable. By default, an app starts with very low permissions, which is comparable to untrusted web content. If the app makes Web API calls that require additional permissions, it must enumerate these additional permissions in its manifest (described later in this document). Gecko will consider granting Web API access to an application only if the applicable privileges are explicitly requested in its manifest. Gecko will grant the requested permission only if the type of the Web App (certified, trusted, or web) is sufficiently qualified for access. Packaged and Hosted Apps Apps for KaiOS can be either packaged (stored on the mobile phone) or hosted (stored on a remote web server, with just a manifest stored on the mobile phone). There are some differences in the way in which security is managed for each. Nonetheless, packaged and hosted apps are both subject to application sandboxing, which is described later in this document. Packaged Apps A packaged app consists of a ZIP file containing application resources (HTML5, CSS, JavaScript, images, media), as well as a manifest that provides an explicit list of assets and their corresponding hashes. Certified and privileged apps must be packaged apps because the app manifest needs to be digitally signed. When a user obtains a packaged app, the ZIP file is downloaded onto the mobile phone, and the manifest is read from a known location inside the ZIP file. During the install process, app assets are verified and remain stored locally in the package. All explicit permissions are requested at runtime, showing the user the app's data usage intentions, and persisted by default. To refer to app resources in a packaged app, the URL begins with app: using the following format: app://identifier/path_within_zipfile/file.html where app:// represents the mount point for the ZIP file, and identifier is a UUID that is generated when the app is installed on the mobile phone. This mechanism ensures that resources referred to with an app: URL are contained in the ZIP file. The path within an app: is relative, so relative links to resources in the ZIP file are allowed. While packaged apps are primarily intended to be used for Certified or Privileged apps, regular web apps can also be packaged. However, they do not gain any increase in trust or permissions access simply because they are packaged. Hosted Apps Hosted apps are located on a web server and loaded via HTTP. Only the app manifest is stored on the mobile phone. Everything else is stored remotely. Certain APIs are available only to privileged and certified apps, which requires the app to be packaged due to signing requirements. Therefore, a hosted app will not have access to any of the Web API operations that require privileged or certified app status. From a security point of view, hosted apps work very much like normal websites. A hosted app is loaded by invoking a hard-coded, fully-qualified URL that points to the startup page in the root directory of the app on that web server. Once a hosted app is loaded, the mobile phone links to pages using the same URLs that are used when browsing the web site. Security Settings in the App Manifest The manifest can also contain other settings, including the following security settings: Field\tDescriptionpermissions\tPermissions required by the app. An app must list every Web API it intends to use that requires user permission. Most permissions make sense for privileged apps or certified apps, but not for hosted apps. Properties per API: description: A string specifying the intent behind requesting use of this API. Required. access: A string specifying the type of access required for the permission. Implicit permissions are granted at install time. Required for only a few APIs. Accepted values: read, readwrite, readcreate, and createonly. csp\tContent Security Policy (CSP). Applied to all pages loaded in the app. Used to harden the app against bugs that would allow an attacker to inject code into the app. If unspecified, privileged and certified apps have system-defined defaults. type\tType of application (web, privileged, or certified). KaiOS requires that the manifest be served with a specific mime-type application/x-web-app-manifest+json and from the same fully-qualified host name (origin) from which the app is served. This restriction is relaxed when the manifest app (and thus the app manifest) is same-origin with the page that requested the app to be installed. This mechanism is used to ensure that it's not possible to trick a website into hosting an application manifest. Security Infrastructure The following figure shows the components of the KaiOS security framework: Permission Manager: Gateway to accessing functionality in the Web API, which is the only access to the underlying hardware.Access Control List: Matrix of roles and permissions required to access Web API functionality.Credential Validation: Authentication of apps/users.Permissions Store: Set of privileges required to access Web API functionality.","keywords":""},{"title":"Building with Web technologies","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/03.build-your-first-package-app/building-with-web-technologies","content":"To build an application for KaiOS, you need to learn three technologies: HTML - (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. CSS - (Cascading Style Sheets) is a language that describes the style of an HTML document, describes how HTML elements should be displayed. JavaScript - is a lightweight interpreted or just-in-time compiled programming language with first-class functions. JavaScript is a prototype-based, multi-paradigm, dynamic language, supporting object-oriented, imperative, and declarative styles.","keywords":""},{"title":"Sample code","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/03.build-your-first-package-app/sample-code","content":"Let's use a simple to-do app, using only JavaScript (Vanilla), React, Vue.js and Angular. Vanilla In Vanilla development, we use only the main technologies without any framework or library to aid development. Note: You can use the ArrowRight key to simulate the SoftRight key To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-vanilla.git Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub React Create React App (CRA) is a template with all the basic settings to start a project in React. First you need to have the create-react-app installed on your computer as a global package, in your terminal run the command: $ npm install -g create-react-app or with yarn $ yarn global add create-react-app Now you can run the following command to start your project using the official react template $ create-react-app my-first-kaios-react-app Open the folder created in your IDE or text editor of your preference. Now, you can look at the following app made by the create-react-app template Note: You can use the ArrowRight key to simulate the SoftRight key To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-react.git Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub Vue Vue CLI is a template with all the basic settings to start a project in Vue. First you need to have the Vue CLI installed on your computer as a global package, in your terminal run the command: $ npm install -g @vue/cli or with yarn $ yarn global add @vue/cli Now you can run the following command to start your project using the official react template $ vue create my-first-vue-app-kaios Open the folder created in your IDE or text editor of your preference. Now, you can look at the following app made by the Vue CLI template Note: You can use the ArrowRight key to simulate the SoftRight key To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-vue.git Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub Angular Angular CLI is a template with all the basic settings to start a project in Angular. First you need to have the Angular CLI and TypeScript installed on your computer as a global package, in your terminal run the command: $ npm install -g @angular/cli typescript or with yarn $ yarn global add @angular/cli typescript Now you can run the following command to start your project using the official react template $ ng new my-first-angular-app-kaios Open the folder created in your IDE or text editor of your preference. Now, you can look at the following app made by the Angular CLI template Note: You can use the ArrowRight key to simulate the SoftRight key To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-angular.git Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub Apps which use indexedDB IndexedDB is a low-level API for client-side storage of significant amounts of structured data, including files/blobs. This API uses indexes to enable high-performance searches of this data. While Web Storage is useful for storing smaller amounts of data, it is less useful for storing larger amounts of structured data. In this next example we will use the example of the app made with React and add the indexedDB to persist the to-do list Note: You can use the ArrowRight key to simulate the SoftRight key If you reload this page you will see that the tasks you added were stored. To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-react.git -b indexedDB Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub Theme apps App themes give the user a better experience, giving her the ability to choose the best theme of her choice. In this next example, we will use the example of the application made with Vanilla and we will add the light and dark themes. Note: You can use the ArrowRight key to simulate the SoftRight key and the ArrowLeft key to simulate the SoftLeft key. To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-vanilla.git -b theme Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub Apps with translation - l10n Currently KaiOS uses a modified version of the L10n.js library to localize the default apps that are available in KaiOS. In this next example, we will use the example of the application made with React and add the translations in en-US and pt-BR. Note: You can use the ArrowRight key to simulate the SoftRight key To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-react.git -b l10n Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub","keywords":""},{"title":"Testing your apps","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/03.build-your-first-package-app/test-your-apps","content":"There are two ways to test your application. with the Real device and Simulator as alternative. Install App via appscmd Download appscmd cd appcmd Verify appscmd cd appscmd ./appscmd --help The output should be like below appscmd 0.2.0 Manages apps installed on a b2g device, simulator or desktop. USAGE: appscmd [FLAGS] [OPTIONS] [SUBCOMMAND] FLAGS: -h, --help Prints help information -j, --json Set output as json format -V, --version Prints version information OPTIONS: --socket <socket> Socket path to connect SUBCOMMANDS: help Prints this message or the help of the given subcommand(s) install Install an application list List installed applications uninstall Uninstall an application appscmd script usage List all apps installed in device appscmd_path/appscmd list Install app appscmd_path/appscmd install your_app_path Uninstall app appscmd_path/appscmd uninstall your_app_name Debug App via firefox Download firefox nightly build versionConnect your device to your computer with a USB cableVerify device information adb devices adb root Open firefox RemoteDebugger Device should be visible in left panel of the RemoteDebugger Click the Connect button right of your device. The device should be connected with the Firefox RemoteDebugger The Tabs show all apps running in device except System App, which can be found in the bottom of the page) Apps running in device System apps running in device Click Inspect button will go to app. Then you can debug and modify via RemoteDebugger","keywords":""},{"title":"Packaged or hosted App","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/04.build-your-first-hosted-app/packaged-or-hosted","content":"While Packaged Apps are the recommended way to deliver your KaiOS apps, there may be benefits to using the Hosted App approach. This page provides a guide to the key differences between these delivery methods and offers advice on choosing between the two. The primary difference between Packaged Apps and Hosted Apps is fairly obvious: the former delivers all its content onto a user’s device, while the latter delivers the app‘s assets on demand from a web server. However, there are many more subtle differences that you should consider when choosing between the two. Packaged and Hosted apps compared Let’s start by looking at key features of Packaged Apps and Hosted Apps and see how they differ. Functionality The overriding reason for creating a Packaged App is the functionality it can offer to your users. Packaged Apps can use the Privileged APIs, which provide apps with the ability to integrate closely with hardware and software features on a KaiOS device. If, for example, your app wanted to allow the user to select and use details of contacts stored on the device, this can only be done in a Packaged App. Feature\tPackage Apps\tHosted AppsAPI support\tAll available KaiOS APIs\tNo access to Privileged and Internal APIs Device integration\tExcellent\tLimited Can access web resources\tYes\tYes Performance In general you should expect users to observe better response from Packaged Apps, as all the app’s assets are stored locally on their device. When accessing remote data from the Internet, generally there’ll be no significant difference between the two options. Feature\tPackage Apps\tHosted AppsStart-up time\tFast, all assets on the device\tNetwork limited, all assets downloaded Network impact\tRemote data only\tApp content(unless AppCached) and remote data Content optimization, e.g. screen size\tThrough redundant assets or multiple packages\tOn-the-fly Impact of data plan limits\tLow\tHigh Availability While KaiOS supports AppCache and local data storage, Packaged Apps provide the app’s assets locally by default, removing the need to explicitly design for application caching. Hosting The cost and effort of hosting a server to deliver Hosted Apps may be an issue for you, if it is then Packaged Apps have a clear advantage. Feature\tPackage Apps\tHosted AppsServer required\tNo\tYes Discovery Feature\tPackage Apps\tHosted AppsDiscovery\tThrough Marketplace\tThrough Marketplace and own site Direct access using a URL\tNo\tYes Delivery All apps need to be delivered to a user’s device, which will be affected by both the network bandwidth and the available storage memory on the device. Here the overall size of your app’s assets will be the primary decision driver, the larger your app the more likely you’ll want to deliver it as a Hosted App. Feature\tPackage Apps\tHosted AppsMarketplace review time\tLonger (when using Privileged APIs)\tShorter Self-publication\tYes\tYes App updates\tRequires a new package to be loaded onto Marketplace\tCore app changes delivered on-the-fly, new install details (e.g. name, icon) require a new Marketplace package App Asset/Content redundancy on device\tPossible\tNo, only used assets/content downloaded App asset limits\tPractical package size limit is device memory and network dependent, generally < 50Mb, <5Mb for low memory devices\tOnline: No practical limit AppCached: As for Packaged Apps Number of apps per device\tLimited by device memory\tOnline: Practically unlimited AppCached: As for Packaged Apps Asset extendibility\tLimited, except for data from XMLHttpRequest and browser links all assets must be on the device\tUnlimited, within Origin Remote content\tBy using iframes, but that content will not have access to privileged APIs nor will it have the default CSP applied to it.\tBy default Development Feature\tPackage Apps\tHosted AppsDelivery standard\tProprietary (albeit a simple ZIP)\tWeb standard Debugging\tEasier, no Origin limitations\teasy, Just like normal web app debug Reading JavaScript assets\tRequires use of XMLHttpRequest\tDirect Coding challenges\tOAuth functionality for Facebook, Dropbox, Twitter, etc. Manifest must specify a launch_path\tRequired\tOptional Apps per Origin\tDoesn’t apply\tDoesn't apply CSP\tEnforced\tOptional mozApps API install function\tApps.installPackage\tapps.install Making your choice The choice of Packaged App or Hosted App isn’t necessarily a simple one. There are however a few key factors that can be used to determine the option to use, as shown in this flowchart :","keywords":""},{"title":"Caching","type":0,"sectionRef":"#","url":"docs/sfp-3.0/03.core-developer-topics/caching","content":"KaiOS supports standard and non-standard web cache. Standard The Cache interface provides a storage mechanism for Request/Response objects. Non-standard HTML5 provides application caching that lets web applications run offline. The application cache mechanism allows offline browsing, increases loading speed, and reduces server load.","keywords":""},{"title":"D-Pad navigation","type":0,"sectionRef":"#","url":"docs/sfp-3.0/03.core-developer-topics/dpad-navigation","content":"On non-touch devices, the preferred method of app navigation is to use the available hardware keys. KaiOS feature phones generally come up with 4 directional arrow keys and confirmation keys. The steps below are guidelines on how to have your webapp respond to directional keys instead of using a cursor or touch controls. Step 1 Use same class to group elements and make them a navigation candidate pool. <div class=\"items\">1</div> <div class=\"items\">2</div> <div class=\"items\">3</div> <div class=\"items\">4</div> <input type=\"text\" class=\"items\"/> <a href=\"more.html\" class=\"items\">more..</a> Step 2 Make every element focusable HTMLAnchorElement/HTMLAreaElement with an href HTMLInputElement/HTMLSelectElement/HTMLTextAreaElement/HTMLButtonElement without disabled HTMLIFrameElement Any element with a tabindex e.g.: <div class=\"items\" tabIndex=\"1\"></div> Step 3 Let target element execute focus() to become active element. After calling focus you can confirm it via document.activeElement. Step 4 Active element listen keydown or keyup event: document.activeElement.addEventListener('keydown', handleKeydown); Step 5 Handle ArrowUp, ArrowRight, ArrowLeft and ArrowDown keys: function handleKeydown(e) { switch(e.key) { case 'ArrowUp': nav(-1); break; case 'ArrowDown': nav(1); break; case 'ArrowRight': nav(1); break; case 'ArrowLeft': nav(-1); break; } } Step 6 Find next target element: function nav (move) { const currentIndex = document.activeElement.tabIndex; const next = currentIndex + move; const items = document.querySelectorAll('.items'); const targetElement = items[next]; targetElement.focus(); } ","keywords":""},{"title":"Emulated Cursor","type":0,"sectionRef":"#","url":"docs/sfp-3.0/03.core-developer-topics/emulated-cursor","content":"KaiOS supports emulating a cursor in app, which user can control with d-pad. There are two types of settings to invoke emulated cursor in app. 1. Emulated Cursor Handled by System To enable emulated cursor in app, set cursor to true in manifest.webapp file: { \"cursor\": true } App with this setting will have the feature of emulated cursor just as browser tab does. For example, cursor is automatically turned off when focusing on input field, and is turned on after leaving input field. Note: This type of cursor usage is strongly recommended. 2. Emulated Cursor Handled by App Note: This type of cursor usage by design lets app have FULL CONTROL of emulated cursor, which means that system will NOT turn on or off cursor for app. That is, app has full responsibilities of when to show and when to hide the cursor. Furthermore, some key events are treated differently when cursor is on, please find more details in the followings: Turning on cursor will prevent default and stop propagation on key events of Enter, Up, Right, Down, Left.Turning on cursor will NOT prevent default or stop propagation on key event of RSK, in addition, it will trigger contextmenu event on key event of RSK.When focus is on an input element (IME is active), app should remember to turn cursor off by itself.Other than the case of focusing on input elements, there might be other cases that apps need to control. Emulated cursor handled by system makes the emulated cursor exist in the app all the time like browser tab. If app needs to control cursor on their own, another api spatialnavigation-app-manage is supported. To get permissions, app must be at least a privileged app. Set spatialnavigation-app-manage in manifest.webapp file: { \"type\": \"privileged\", // or \"certified\" \"permissions\": { \"spatialnavigation-app-manage\": {} } } To turn on cursor: navigator.spatialNavigationEnabled = true; To turn off cursor: navigator.spatialNavigationEnabled = false; ","keywords":""},{"title":"Notifications","type":0,"sectionRef":"#","url":"docs/sfp-3.0/03.core-developer-topics/using-push-notifications","content":"Push API allow applications to receive asynchronous notifications and perform actions without staying in the foreground. W3C Push API Push API introduction Service Worker Cookbook - Web Push Payload","keywords":""},{"title":"Softkeys","type":0,"sectionRef":"#","url":"docs/sfp-3.0/03.core-developer-topics/softkeys","content":"The software key appears at the bottom of the screen, which corresponds to the center, right, and left hardware keys. Each key may or may not appear depending on the availability of features. Structure This is a simple structure of a softkey use, see the UI Components section for the style example of the component. <body id=\"app\"> <!-- Your app's code --> <footer class=\"softkey\"> <div id=\"softkey-left\">Back</div> <div id=\"softkey-center\">SELECT</div> <div id=\"softkey-right\">Options</div> </footer> </body> Actions User actions on the keyboard can lead to a new state of your application. For more understanding see the simple example below, where you can hear the device keyboard actions. const softkeyCallback = { left: function() { console.log('You click on SoftLeft') }, center: function() { console.log('You click on Enter') }, right: function() { console.log('You click on SoftRight') } }; function handleKeyDown(evt) { switch (evt.key) { case 'SoftLeft': // Action case press left key softkeyCallback.left(); break; case 'SoftRight': // Action case press right key softkeyCallback.right(); break; case 'Enter': // Action case press center key softkeyCallback.center(); break; } }; document.addEventListener('keydown', handleKeyDown); In case your application needs to update the softkey, according to a state, view or navigation, this can be done using a function like the following example: function updateSoftKey(props) { const keys = Object.keys(props); keys.forEach(function(key) { const button = document.getElementById('softkey-' + key); button.textContent = props[key].label; softkeyCallback[key] = props[key].callback; }); } /* This function is call that way */ updateSoftKey({ left: { label: 'Left text', callback: function(){ /* Code */ } }, center: { label: 'Center text', callback: function(){ /* Code */ } }, right: { label: 'Right text', callback: function(){ /* Code */ } } }); ","keywords":""},{"title":"Multiple Resolutions","type":0,"sectionRef":"#","url":"docs/sfp-3.0/03.core-developer-topics/supporting-multiple","content":"Applications on KaiOS should adapt to different resolutions. Current KaiOS devices support QVGA resolutions in portrait (240x320 pixels) or landscape (320x240 pixels). Media query The best and easiest way to develop a responsive UI on KaiOS is by making use of CSS media queries. The following are examples of media queries considering device orientation, with KaiOS supported resolutions in mind: /* KaiOS portrait devices (240x320) */ @media only screen and (orientation : portrait) { /* styles */ } /* KaiOS landscape devices (320x240) */ @media screen and (orientation: landscape) { /* styles */ } If you need more help, make use of some the below tips to build your responsive KaiOS app: Using media queries The building blocks of responsive design","keywords":""},{"title":"Network State Changes","type":0,"sectionRef":"#","url":"docs/sfp-3.0/03.core-developer-topics/network-state-changes","content":"In order to build a good offline-capable web application, you need to know when your application is actually offline. You also need to know when your application has returned to an 'online' status again. Effectively, the requirements break down as follows: You need to know when the user comes back online so that you can re-synchronize with the server.You need to know when the user is offline so that you can queue your server requests for a later time. It is this process that online/offline events help to simplify. NavigatorOnLine navigator.onLine navigator.onLine is a property that maintains a true/false value (true for online, false for offline). This property is updated whenever the user switches into \"Offline Mode\". Additionally, this property should update whenever a browser is no longer capable of connecting to the network. According to the specification: The navigator.onLine attribute must return false if the user agent will not contact the network when the user follows links or when a script requests a remote page (or knows that such an attempt would fail)... online and offline events You can register listeners for these events in a few familiar ways: Using addEventListener on the window, document, or document.bodyBy setting the .ononline or .onoffline properties on document or document.body to a JavaScript Function object. (Note: using window.ononline or window.onoffline will not work for compatibility reasons.)By specifying ononline=\"...\" or onoffline=\"...\" attributes on the <body> tag in the HTML markup. Example window.addEventListener('load', function() { let status = document.getElementById(\"status\"); let log = document.getElementById(\"log\"); function updateOnlineStatus(event) { let condition = navigator.onLine ? \"online\" : \"offline\"; status.className = condition; status.innerHTML = condition.toUpperCase(); log.insertAdjacentHTML(\"beforeend\", \"Event: \" + event.type + \"; Status: \" + condition); } window.addEventListener('online', updateOnlineStatus); window.addEventListener('offline', updateOnlineStatus); }); Network Information The Network Information API provides information about the system's connection in terms of general connection type (e.g., 'wifi', 'cellular', etc.). This can be used to select high definition content or low definition content based on the user's connection. The entire API consists of the addition of the NetworkInformation interface and a single property to the Navigator interface: Navigator.connection. Examples Detect connection changes This example watches for changes to the user's connection. var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection; var type = connection.type; function updateConnectionStatus() { console.log(\"Connection type changed from \" + type + \" to \" + connection.type); } connection.addEventListener('change', updateConnectionStatus); Preload large resources The connection object is useful for deciding whether to preload resources that take large amounts of bandwidth or memory. This example would be called soon after page load to check for a connection type where preloading a video may not be desirable. If a cellular connection is found, then the preloadVideo flag is set to false. For simplicity and clarity, this example only tests for one connection type. A real-world use case would likely use a switch statement or some other method to check all of the possible values of NetworkInformation.type. Regardless of the type value you can get an estimate of connection speed through the NetworkInformation.effectiveType property. let preloadVideo = true; var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection; if (connection) { if (connection.type === 'cellular') { preloadVideo = false; } } Interfaces NetworkInformation Provides information about the connection a device is using to communicate with the network and provides a means for scripts to be notified if the connection type changes. The NetworkInformation interfaces cannot be instantiated. It is instead accessed through the Navigator interface.","keywords":""},{"title":"Transform PWA to hosted app","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/04.build-your-first-hosted-app/pwa-to-hosted-app","content":"What is PWA? Put it simply, Progressive Web Apps are web applications that load in a web browser just like web pages or websites. It gives you a rich mobile experience via native-like functionalities such as the ability to work offline, push notifications, and device hardware accessibility. It feels like a native app and offers the same experience as a native one. There is no need to download it from an app store. It loads, runs, and functions in a web browser. For more information about PWA, You can see also Progressive web apps on MDNProgressive web apps on Google DevelopersProgressive web apps details on Google DevelopersProgressive Web Apps Check ListThe Lighthouse Tool by Google Progressive Web Apps Promote Mobile-First Approach According to one Statista report, The number of mobile phone users is forecasted to reach 4.68 billion by 2019. Going further, in 2016, an estimated 62.9 percent of the population worldwide already owned a mobile phone. This will round up to 67 percent by 2019. 4 Things Every Progressive Web App Must Have There are 4 things every progressive web apps must have. Lets's start listing each of them, then we'll go over them one after the other: HTTPSWeb app manifestService workerResponsive design HTTPS A PWA must be safe and secure, hence the requirement to be served on HTTPS instead of HTTP. Gone are the days when getting an SSL certificate for a website is expensive and tedious. Every modern website today should be running on HTTPS, you will be doing your app such a great good by serving it on HTTPS. Web App Manifest The web app manifest is simply a JSON (manifest.json) file that is used to describe the application. The web app manifest provides information about an application (such as name, icon, and description etc.). The purpose of the manifest is to install web applications to the home screen of a device, providing users with quicker access and a richer experience such as theme, splash screen and the ability to run the app in full-screen mode and as a standalone application. A typical web app manifest can be as below: { \"name\": \"Weather\", \"short_name\": \"Weather\", \"icons\": [{ \"src\": \"/images/icons/icon-128x128.png\", \"sizes\": \"128x128\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-144x144.png\", \"sizes\": \"144x144\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-152x152.png\", \"sizes\": \"152x152\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-192x192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-256x256.png\", \"sizes\": \"256x256\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-512x512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" }], \"start_url\": \"/index.html\", \"display\": \"standalone\", \"background_color\": \"#3E4EB8\", \"theme_color\": \"#2F3BA2\" } Service Worker A service worker is vital to allow a PWA. So what is a service worker? A service worker is a script that runs in the background making the decision to serve network or cached content based on availability. Service worker provides offline support for applications through caching, which is essential for a PWA. In addition to the offline functionality, a service work also provides support for other features such as push notifications, and background sync. It is important to mention that service workers can only be registered on pages served over HTTPS. Though it can be registered on localhost while in development, as soon as you deploy to a live server, it will require HTTPS and not HTTP. Responsive Design Since a PWA can be somewhat installed on a device (mobile phone or tablet etc.), it should be responsive enough so as to display properly irrespective of the devices it is being viewed on. With the numerous CSS frameworks out there that support responsive design, making your app responsive on major screen sizes should be easy. Transform PWA to hosted app If you already have a PWA web app and want to publish it to hosted app under KaiOS，We will provide some instruction to help you transform PWA to KaiOS hosted app and submit to KaiStore. We assume you already be familiar with PWA.The under instruction only list some points you need focus on,Please refer above link about the details of PWA. Add new manifest.webapp Your PWA app manifest.json file may be looks like below: { \"name\": \"Weather\", \"short_name\": \"Weather\", \"icons\": [{ \"src\": \"/images/icons/icon-56x56.png\", \"sizes\": \"56x56\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-112x112.png\", \"sizes\": \"112x112\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-224x224.png\", \"sizes\": \"224x224\", \"type\": \"image/png\" }], \"start_url\": \"/index.html\", \"display\": \"standalone\", \"background_color\": \"#3E4EB8\", \"theme_color\": \"#2F3BA2\" } First we need add a new file manifest-hosted.app(any meaningful name will be accepted) and let this new manifest file be served through your server. { \"version\": \"1.0.0\", \"name\": \"KaiOS Hosted Weather APP\", \"description\": \"A sample hosted APP which transported for PWA\", \"type\": \"web\", \"launch_path\": \"/index.html\", \"icons\": { \"56\": \"/images/icons/icon-56x56.png\", \"112\": \"/images/icons/icon-112x112.png\", \"224\": \"/images/icons/icon-224x224.png\" }, \"developer\": { \"name\": \"KaiOS\", \"url\": \"http://www.kaiostech.com\" }, \"permissions\": { \"serviceworker\":{} }, \"cursor\": \"true\", \"locales\": { \"en-US\": { \"name\": \"KaiOS App\", \"subtitle\": \"Short description for the user\", \"description\": \"Brief description of your app\" } }, \"default_locale\": \"en-US\" } Certainly you can just add a REST API and return json like below: const hostedManifest = { \"version\": \"1.0.0\", \"name\": \"KaiOS Hosted Weather APP\", \"description\": \"A sample hosted APP which transported for PWA\", \"type\": \"web\", \"launch_path\": \"/index.html\", \"icons\": { \"56\": \"/images/icons/icon-56x56.png\", \"112\": \"/images/icons/icon-112x112.png\", \"224\": \"/images/icons/icon-224x224.png\" }, \"developer\": { \"name\": \"KaiOS\", \"url\": \"http://www.kaiostech.com\" }, \"permissions\": { \"serviceworker\":{} }, \"locales\": { \"en-US\": { \"name\": \"KaiOS App\", \"subtitle\": \"Short description for the user\", \"description\": \"Brief description of your app\" } }, \"default_locale\": \"en-US\", \"cursor\": true, }; function getHostedManifest(req, resp) { resp.json(hostedManifest); } app.get('/hosted-manifest', getHostedManifest); You can reference the details of this manifest file here.We will provide helper tool for you to transform PWA manifest.json file to hosted app manifest.webapp soon.The most important is you must specify ServiceWorker permission like blow or you can not use ServiceWorker in this hosted app. \"permissions\": { \"serviceworker\":{} } Offline Support The traditional offline of KaiOS app use appCache,For sure you can continue use this technology,In addition you can use Service Worker to implement like ServiceWorker Offline experience. Responsive Design Current KaiOS devices support QVGA resolutions in portrait (240x320 pixels) or landscape (320x240 pixels). If you want adapter your hosted app to KaiOS app, You should process your responsive design for small screen. You can refer more details about responsive design through Responsive Design on Google Developer. Navigation Fow now,You can add \"cursor: true\" to manifest.webapp file for the navigation purpose(Emulated Cursor), Certainly you can use D-pad for navigation(D-pad navigation). Install experience When a Progressive Web App is installed, it looks and behaves like all of the other installed apps. It launches from the same place as other apps launch. It runs in an app without an address bar or other browser UI. And like all other installed apps, it's a top level app in the task switcher.When you port your PWA to KaiOS hosted app, Currently you can only install your web app via submit to our KaiStore Submit To KaiStore. Certainly you can test through WebIDE install hosted app.","keywords":""},{"title":"Storage","type":0,"sectionRef":"#","url":"docs/sfp-3.0/03.core-developer-topics/storage","content":"There is no limit to application size or storage size, except for physical storage constraints. App size range depends on the complexity of the app. Below some internal KaiOS apps’ sizes for your reference: Calculator: 200KBSettings: 10MB Data Storage The aim of this guideline is to provide information for app developer saving data in a better way due to smart feature phone is not like smart phone usually with large data storage. To prevent user hit storage full issue with unexpected scenario, KaiOS needs app developer’s support to follow the guideline below for better user experience. Media file should be saved in media storage, NOT in application data as indexedDB. KaiOS system will block DB writing once remaining data storage size is lower than 30MB, so each app must do error handling. (the number may be difference based on device) App developer should handle the content carefully and set some limitation especially for low storage devices. For example, to limit the total size of content such as the number of messages to 10000 or contact number to 1000, once the number is close to the limit, to show the error message or overwrite the older data. KaiOS provides a preventive action to keep device working normal as usual when storage is full by large size of indexedDB. It will perform data storage clean up by deleting old, removable indexedDB. To delete the object properly, KaiOS needs app to mark indexedDB when creating DB for those data which is considered “can be deleted” while storage full. App Developer should be aware of: * The storage type for these IDB is \"temporary\" which will be all removed when available space is lower than a threshold. * For IDB guideline, developer could refer [this link](https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase) since the rest of usage is the same as normal database. * App should support error handling and upgrade situation when the indexedDB is removed. * Method to Create/Delete removable indexedDB as following: To request opening a connection to a database that able to be deleted when space needed: Syntax: var IDBOpenDBRequest = indexedDB.open(name, { version, storageType }); var db; var DBOpenRequest = indexedDB.open('MyTestDatabase'); DBOpenRequest.onerror = function(event) { alert(\"Why didn't you allow my web app to use IndexedDB?!\"); }; DBOpenRequest.onsuccess = function(event) { db = event.target.result; }; To request deletion of a database which in temporary storage type: Syntax: var IDBOpenDBRequest = indexedDB.deleteDatabase(name, { version, storageType }); var DBDeleteRequest = window.indexedDB.deleteDatabase('toDoList', { version: 4, storage: 'temporary' }); DBDeleteRequest.onerror = function(event) { console.log('Error deleting database.'); }; DBDeleteRequest.onsuccess = function(event) { console.log('Database deleted successfully'); console.log(event.result); // should be undefined }; For small size records and application data, the Web Storage APIprovides access to session storage or local storage, allowing you to add, modify, or delete stored items. Session storage: Window.sessionStorageLocal storage: Window.localStorage Device Storage For access to specific files in a specific storage area on the device, the DeviceStorage interface is used. navigator.getDeviceStorage() will return a DeviceStorage object which you can then use to access content of the storage area. MDN Resource You can refer Using IndexedDB for more information.","keywords":""},{"title":"First hosted App","type":0,"sectionRef":"#","url":"docs/sfp-3.0/02.getting-started/04.build-your-first-hosted-app/your-first-hosted-app","content":"Let's create a simple hosted app, using only JavaScript (Vanilla). it’s there to provide you with the most basic features to get started with building an app from scratch, or tools to port your existing web app. The idea is also to avoid any dependency on external libraries or resources, but rather be self-contained. It contains: Web Activities - lots of examples and use casesWebAPIS in actionOffline support It’s available on GitHub: Code for KaiOS hosted AppLive demo of KaiOS hosted App How to use it The easiest way to get started, installing it and testing the various features, is to open the WebIDE Open Hosted APP with this URL and install either in device or simulator: https://firegnu.github.io/kaios-hosted-sample/manifest.webapp ## Running it locally Once you’re ready to get started developing, download the code and run it on a web server(Sample code use Github pages service), Using WebIDE to install the app in device or simulator . Note: make sure that the paths in the manifest file are valid on your localhost – bear in mind that these paths are relative to the root of the web site they are being served at. Also make sure to configure your server to send the manifest file with the right Content-type: application/x-web-app-manifest+json. This is, for instance, easy to set up in an .htaccess file in Apache: AddType application/x-web-app-manifest+json .webapp Need to notice Responsive Design Current KaiOS devices support QVGA resolutions in portrait (240x320 pixels) or landscape (320x240 pixels). If you want adapter your hosted app to KaiOS app, You should process carefully. You can refer more details about responsive design throughResponsive Design on Google Developer and Multiple Resolutions. Navigation Fow now,You can add \"cursor: true\" to manifest.webapp file for the navigation purpose(Emulated Cursor), Certainly you can use D-pad for navigationD-pad navigation. Offline support This Sample provided an .appcache file for enabling offline support (App Caching). To enable offline capabilities, just add this to the index.html file: <html manifest=\"manifest.appcache\"> Remember that the .appcache file has to be served as a text/cache-manifest file: AddType text/cache-manifest .appcache ","keywords":""},{"title":"Action icon","type":0,"sectionRef":"#","url":"docs/sfp-3.0/04.design-guide/action-icon","content":"Action icons are used to represent common actions in your app. KaiOS provides many common action icons, such as add, cancel, search, next, and so on. We highly recommend using these icons in your apps. If none of the standard action icons meet your app’s needs, you can design your own action icons by following the design principles in the following sections. Size & format An action icon must be 32 x 32 pixels in SVG format. Always keep free space (5 pixels) around the icon. However, the icon can be extended into free space due to visual weight balance. Normal & focus states Each icon has normal and focussed states, differentiated by their color compositions. Avoid using the same color for both states so they are easily recognizable. Style The icon should be two-dimensional and filled with a solid color. Avoid decorative details or using visual effects like drop shadow, gradient, and glow. Also, ensure that the size of your icon is readable and clear on a small-sized display. Shape An action icon should represent its desired function as simply and clearly as possible, while avoiding overly complex or compound ideas, such as intricate details or thin outline strokes.","keywords":""},{"title":"alarm APIs","type":0,"sectionRef":"#","url":"docs/sfp-3.0/06.api/web-apis/alarm/alarm","content":"Alarm 3.0","keywords":""},{"title":"Typography","type":0,"sectionRef":"#","url":"docs/sfp-3.0/04.design-guide/typography","content":"KaiOSKaiOSKaiOSKaiOS The typography of KaiOS provides a great reading experience, conveys hierarchy, and facilitates understanding. Open Sans is the standard typeface on KaiOS. It provides high legibility and is well suited for high or low density displays. Noto Sans is the typeface to support other languages with harmonious look and feel. Typefaces Use font weight and size to emphasize important information in your app. Open Sans font weights KaiOS picks out 4 weights of Open Sans including Light, Regular, Semi-bold, and Bold. OPEN SANS LIGHT The Open Sans is optimized for legibility across print, web, and mobile interfaces. OPEN SANS REGULAR The Open Sans is optimized for legibility across print, web, and mobile interfaces. OPEN SANS SEMIBOLD The Open Sans is optimized for legibility across print, web, and mobile interfaces. OPEN SANS BOLD The Open Sans is optimized for legibility across print, web, and mobile interfaces. Noto Sans KaiOS picks out 2 weights of Noto Sans including Regular and Bold. NOTO SANS REGULAR The Noto Sans is optimized for legibility across print, web, and mobile interfaces. NOTO SANS BOLD The Noto Sans is optimized for legibility across print, web, and mobile interfaces. Font Sizes KaiOS uses a specific set of font sizes to balance content priority and readability. This is a list of the most common styles and the basics you may need. There are 11 default styles calculated for a 140 ppi screen, which is a QVGA resolution at 2.8 inch display. If you’re working with a different resolution you will need to convert the unit based on your device resolution. Label\tDescription\tTypeface\tPixelH1\tHeader text\tRegular/400\t17 H2\tHeader of body text\tSemibold/600\t17 H3\tTab text\tRegular/400\t14 H4\tSeparator text\tRegular/400\t14 H5\tSoftware key text\tSemibold/600\t14 P.PRI\tPrimary text\tRegular/400\t17 P.SEC\tSecondary text\tRegular/400\t14 P.THI\tTertiary text\tRegular/400\t12 P, UL\tBody text\tRegular/400\t17 P.LINK\tHyperlink text\tBold/700\t17 P.BTN\tButton text\tRegular/400\t17","keywords":""},{"title":"sfp 3.0","type":0,"sectionRef":"#","url":"docs/sfp-3.0/06.api/web-apis","content":"sfp 3.0 sfp 3.0 Jump to: ABCDHMNPSTX A AppsManagerAudio Channels APIAudioChannelClientAudioContextAudioVolumeManager B BlueTooth C Contacts D DeviceCapability H HTMLMediaElement M MozSpeakerManager N navigator.b2g.alarmManagernavigator.b2g.audioChannelManagernavigator.b2g.camerasnavigator.b2g.dataCallManagernavigator.b2g.downloadManagernavigator.b2g.externalapinavigator.b2g.fmRadionavigator.b2g.getDeviceStoragenavigator.b2g.inputMethodnavigator.b2g.mobileConnectionnavigator.b2g.mobileMessagenavigator.b2g.virtualCursornavigator.geolocationnavigator.mediaDevices.getUserMedianavigator.mozTCPSocketnavigator.vibrateNotification P PowerManager S ServiceWorkerSettings T TcpSocketTelephonyTimeService X XMLHttpRequest","keywords":""},{"title":"App Permissions","type":0,"sectionRef":"#","url":"docs/sfp-3.0/03.core-developer-topics/permissions","content":"The permissions field in the app manifest controls the app's access to various sensitive APIs on the device (sometimes called WebAPIs). The permissions are described in the following tables. The three levels of permission, in brief, are: Web apps: These only have a basic level of permissions, and don't have access to privileged or internal APIs.Privileged apps: These have all the permissions of web apps plus more. Hosted apps can't be privileged — they must be packaged apps. Hosted app and privileged app permissions Manifest permission\tAPI name\tMinimum app type required\taccess property\tDefault grantedalarms\tAlarm\thosted\tnone\tAllow audio-capture\tgetUserMedia, Web Speech API\thosted for getUserMedia, privileged for Web Speech API\tnone\tPrompt for all installed App types for getUserMedia, Allow for Web Speech API. audio-channel-alarm\tAudioChannels\tprivileged\tnone\tAllow audio-channel-content\tAudioChannels\thosted\tnone\tAllow audio-channel-normal\tAudioChannels\thosted\tnone\tAllow audio-channel-notification\tAudioChannels\tprivileged\tnone\tAllow browser\tBrowser\tprivileged\tnone\tAllow camera\tCamera\tprivileged in KaiOS certified\tnone\tPrompt for all installed App types.` contacts\tContacts\tprivileged\treadonly, readwrite, readcreate, or createonly\tPrompt for all installed App types. desktop-notification\tNotification\thosted\tnone\tPrompt for Web content. Allow for all installed App types. device-storage:music\tDevice Storage\tprivileged\treadonly, readwrite, readcreate, or createonly\tPrompt device-storage:pictures\tDevice Storage\tprivileged\treadonly, readwrite, readcreate, or createonly\tPrompt device-storage:sdcard\tDevice Storage\tprivileged\treadonly, readwrite, readcreate, or createonly\tPrompt device-storage:videos\tDevice Storage\tprivileged\treadonly, readwrite, readcreate, or createonly\tPrompt fmradio\tFM Radio\thosted\tnone\tAllow geolocation\tGeolocation\thosted\tnone\tPrompt (even for certified Apps) input\tKeyboard\tprivileged\tnone\tAllow mobileid\tMobile identity\tprivileged\tnone\tPrompt mobilenetwork\tMobile Network\tprivileged\tnone\tAllow moz-firefox-accounts\tFirefox Accounts\tprivileged\tnone\tPrompt for all installed App types. nfc\tNFC API\tprivileged\tnone\tAllow nfc-share\tNFC API\tprivileged\tnone\tAllow nfc-read, nfc-write\tNFC API\tWas certified/internal at this stage in development.\tnone\tAllow push\tSimple Push\thosted\tnone\tAllow speech-recognition\tWeb Speech API\tprivileged\tnone\tAllow systemXHR\tSystemXHR\tprivileged\tnone\tAllow tcp-socket\tTCP Socket\tprivileged\tnone\tAllow video-capture\tGetUserMedia\thosted\tnone\tPrompt for all installed App types. Certified app permissions Manifest permission\tAPI name\tMinimum app type required\taccess propertyattention\tAttention Screen\tcertified\tnone audio-channel-ringer\tAudioChannels\tcertified\tnone audio-channel-telephony\tAudioChannels\tcertified\tnone audio-channel-publicnotification\tAudioChannels\tcertified\tnone background-sensors\tBackground Sensor\tcertified\tnone backgroundservice (Deprecated)\tBackground Services\tcertified\tnone bluetooth certified\tnone browser:embedded-system-app\tBrowser\tcertified\tnone camera\tCamera\tcertified\tnone cellbroadcast certified\tnone No permission needed, but datastores-access/datastores-owned needs to be set in the manifest (see Data Store API Manifest fields.)\tData Store\tcertified\tdatastores-access/ datastores-owned device-storage:apps\tDevice Storage\tcertified\tread embed-apps\tEmbed Apps\tcertified\tnone idle\tIdle\tcertified\tnone mobileconnection\tMobile Connection\tcertified\tnone network-events\tNetwork Events\tcertified\tnone networkstats-manage\tNetwork Stats\tcertified\tnone open-remote-window\tOpen out-of-process windows\tcertified\tnone permissions\tPermissions (Firefox OS)\tcertified\tnone power\tPower Management\tcertified\tnone presentation-device-manage\tPresentation\tcertified\tnone settings\tSettings\tcertified\treadonly or readwrite sms\tWebSMS\tcertified\tnone telephony\tWeb Telephony\tcertified\tnone time\tTimeManager\tcertified\tnone voicemail\tVoicemail\tcertified\tnone webapps-manage\tOpen Webapps\tcertified\tnone wifi-manage\tWiFi Management\tcertified\tnone wappush\tWAP Push\tcertified\tnone","keywords":""},{"title":"Run and debug your first App","type":0,"sectionRef":"#","url":"docs/sfp-3.0/05.run-and-debug","content":"Running apps When you're ready to run the app, follow these steps for executing: Start WebIDE. If everything is fine until now, you can see your device on 'USB Devices' section.Click on the device name and all apps will be listed on the left side.Choose one app to run, inspect, debug, test, etc. Debugging apps To debug the app, click the wrench icon and the Developer Tools Toolbox appears, connected to your app: The basic tools available in your WebIDE are: The Inspector to examine and modify the HTML and CSS of a page. The Console for logs information associated with a web page and enables you to interact with a web page by executing JavaScript expressions in the context of the page. The JavaScript Debugger enables you to step through JavaScript code and examine or modify its state to help track down bugs. Style Editor enables you to view and edit all the stylesheets associated with a page, create new stylesheets from scratch and import existing stylesheets and apply them. The Scratchpad provides an environment for experimenting with JavaScript code. You can write, run, and examine the results of code that interacts with the web page. Just as in a web page, any changes you make in the tools are visible immediately in the app, but are not persistent. Conversely, any changes you make in the editor pane can be saved straight back to disk, but are not visible without restarting the app. Performance If you're interested in the performance of your apps, there are a few ways to measure their impact on the runtime in WebIDE: The Performance tool gives you insight into your app's general responsiveness, JavaScript and layout performance. With the Performance tool you create a recording, or profile, of your app over a period of time. The Memory tool lets you take a snapshot of the current tab's memory heap. It then provides a number of views of the heap that can show you which objects account for memory usage and exactly where in your code you are allocating memory. Generating memory reports with B2G Another way to see the device's memory usage is creating a memory report with B2G tool. To create one follow the steps below: Clone mozilla/B2G git clone https://github.com/mozilla-b2g/B2G.git Apply this patch cd B2G/tools git apply path/to/memory.patch Run the get_about_memory.py script which will get information from the plugged device. ./get_about_memory.py -m A folder called about-memory-0 will be created into B2G/tools and inside then you will see a gzipped file. Open Firefox and type \"about:memory\" into the address bar and hit Enter. Click in \"Load...\" and open the gzipped created in step 3. You can diff two different files too.","keywords":""},{"title":"Other Web APIs","type":0,"sectionRef":"#","url":"docs/sfp-3.0/06.api/other-apis","content":"Web Application Programming Interfaces (Web APIs) are used to perform a variety of tasks, such as manipulating the DOM, playing audio or video, or generating 3D graphics. When writing code for the Web with JavaScript, there are a great many APIs available. This page has a list of all the interfaces that you may be able to use while developing your Web app.","keywords":""},{"title":"UI Component","type":0,"sectionRef":"#","url":"docs/sfp-3.0/04.design-guide/ui-component","content":"KaiOS apps are created from UI Components which define common interface elements. By following UI Components, apps achieve a consistent appearance across the system. The Units of spacing defined in KaiOS are specified in rem. On a screen with a density of 140, 1 rem is equal to 10 pixels, which is a baseline QVGA resolution on a 2.8-inch display and the resolution is 240*320. Header A header appears below the status bar. The text in the header is centered and displays the app name or page title. Tab A tab appears below the header, which separates grouped content and provides the ability to quickly switch between different sections of an app by tapping left or right on the navigation key. Software Key The software key appears at the bottom of the screen, which corresponds to the center, right, and left hardware keys. Each key may or may not appear depending on the availability of features. In certain conditions, it is allowed to use icon for the center key if it is of universal recognition, such as play or pause icon. List Lists are typically used to navigate to a new screen, or to display information or controls. Separator Separators are used to describe a subsection of content. The separator often appears between list or grid items, as it helps separate different groups of content. Controls - Checkbox and Radio Button Checkboxes allow users to select multiple options from a set. Radio buttons provide the ability to select one option from a set. Progress Progress represents how long the current operation will take, or appears as indeterminate when the completion status cannot be determined. Slider The slider is an extension of Progress that adds a draggable thumb. On a non-touch device, the user can press the Right and Left keys to set a new value for a given control, such as volume or brightness. Button The button is used to perform an explicit action. It can include a title or combine with an icon. Input Input is a data entry field and can be as simple as a text-only entry field in a list or a search input in the header. For multiple-line input, the center key is Enter for a new line. Option Menu Option Menu provides a list of choices on a pop-up component which may appear with controls such as a checkbox or radio button. It allows users to perform actions on objects without having to leave their current view. Value Selector The Value Selector provides an easy way to select single or multiple values from a pre-determined set of values. Date Value Selector and Time Value Selector can be used for specific scenarios. Dialog A Dialog provides the user with some important information, asks the user to take or confirm an action, or allows the user to make a choice or enter information. Notice Notice appears at the top of the screen like Toast, but with different layout. A Notice has an icon, primary text, and secondary text. After a Notice disappears from the top of the screen, users can still access it from Notices panel. Toast Toast appears at the top of the screen and provides important information, or alerts the user to a system event. It can’t be interacted with and will automatically time out depending on the length of the content. Capitalization for UI Components Three styles are used: Title Case, Sentence case, and ALL CAPS. Useful third-party component For some reason，We did't publish our official component，But there are some good design third-party component,They follow closely our design guideline. KaiUI from AdrianMachado or follow design at kai in medium Design at Kai","keywords":""},{"title":"API Change","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/api-change","content":"API Name\t2.5\t3.0\tChange TypeAppsManager\tAppsManager service\tAppsManager Service\tNew API VolumeManager\tnavigator.volumeManager\tAudiovolume Service\tNew API Contacts\tnavigator.mozContacts\tContacts Service\tNew API DeviceCapability\tnavigator.getFeature/hasFeature\tDeviceCapability Service\tNew API PowerManager\tnavigator.mozPower\tPowerManager Service\tNew API Settings\tnavigator.mozSettings\tSettings Service\tNew API TimeService\tTime Service\tTime Service\tNew API Alarm\tnavigator.mozAlarms\tnavigator.b2g.alarmManager\tChanged API Name Audio Channels\tnavigator.mozAudioChannelManager\tnavigator.b2g.audioChannelManager\tChanged API Name Bluetooth\tnavigator.mozBluetooth\tnavigator.b2g.bluetooth\tChanged API Name Camera\tnavigator.mozCameras\tnavigator.b2g.cameras\tChanged API Name Data Call\tnavigator.dataCallManager\tnavigator.b2g.dataCallManager\tChanged API Name Download Manager\tnavigator.mozDownloadManager\tnavigator.b2g.downloadManager\tChanged API Name External API\tnavigator.externalapi\tnavigator.b2g.externalapi\tChanged API Name FM Radio\tnavigator.mozFMRadio\tnavigator.b2g.fmRadio\tChanged API Name Device Storage\tnavigator.getDeviceStorage\tnavigator.b2g.getDeviceStorage\tChanged API Name Keyboard IME\tnavigator.mozInputMethod\tnavigator.b2g.inputMethod\tChanged API Name Mobile Network\tnavigator.mozMobileConnection\tnavigator.b2g.mobileConnection\tChanged API Name Mobile Message Manager\tnavigator.mozMobileMessage\tnavigator.b2g.mobileMessage\tChanged API Name Virtual Cursor\tnavigator.spatialNavigationEnabled\tnavigator.b2g.virtualCursor\tChanged API Name Audio Channel Client\tAudioChannelClient\tnavigator.b2g.AudioChannelClient\tChanged API Name Audio Context\tAudioContext\tnavigator.b2g.AudioContext\tChanged API Name HTMLMediaElement\tHTMLMediaElement\tnavigator.b2g.HTMLMediaElement\tChanged API Name Audio Channels\tAudio Channels\tAudio Channels\tChanged API Name Notification\tNotification\tNotification\tNo Change Speaker Control\tMozSpeakerManager\tMozSpeakerManager\tNo Change Service Worker\tServiceWorker\tServiceWorker\tNo Change SystemXHR\tXMLHttpRequest\tXMLHttpRequest\tNo Change Geolocation\tnavigator.geolocation\tnavigator.geolocation\tNo Change TCP Socket\tnavigator.mozTCPSocket\tnavigator.mozTCPSocket\tNo Change Vibration\tnavigator.vibrate\tnavigator.vibrate\tNo Change getUserMedia\tnavigator.MozGetUserMediaDevices\tnavigator.mediaDevices.getUserMedia\tNo Change TcpSocket\tTcpSocket Service\tTcpSocket Service\tNo Change Telephony\tTelephony Service\tTelephony Service\tNo Change","keywords":""},{"title":"Basic Navigation","type":0,"sectionRef":"#","url":"docs/sfp-3.0/04.design-guide/basic-navigation","content":"Emulated Cursor Navigation You can use Emulated Cursor Navigation，Just add this line to manifest.webapp。 \"cursor\": true List View A list view typically contains items listed vertically where we can press UP and DOWN keys to navigate. Since a list view might accommodate many items, continuous key actions — the events that happen after a button has been pressed — and a list view loop are introduced to improve the experience. When we press and hold one of the D-pad keys, key events are dispatched continuously, from slow to fast. This feature allows us to scroll a list without pressing the D-pad numerous times. We can start slow to target accuracy, then speed up for efficiency. At the end of a list, pressing DOWN will navigate to the top. This list view loop also applies when you press UP at the beginning of the list. Grid View A grid view displays items in a two-dimensional grid, where we can press the D-pad keys to navigate. We’ve introduced Z-navigation and no-row-skipping to improve this experience. We usually have to use four D-pad keys to navigate a grid view since it has only two dimensions. With Z-navigation, pressing the RIGHT key at item three brings you to item four instead of item one. This allows users to navigate through all items by using only the LEFT and RIGHT keys. When you press the DOWN key at item nine, it goes to 11 instead of item three. Similarly, pressing the UP key at item three brings you to item 11 instead of item nine. No-row-skipping helps users not to miss the last row which is especially useful when that row falls outside of the screen. Tab View When an app has a lot of content that needs to be organized by grouping, tab view is the appropriate solution.","keywords":""},{"title":"Examples of Apps Design","type":0,"sectionRef":"#","url":"docs/sfp-3.0/04.design-guide/kai-designed","content":"Todo of Examples of Apps Design","keywords":""},{"title":"Key","type":0,"sectionRef":"#","url":"docs/sfp-3.0/04.design-guide/key","content":"Overview Software Key (LSK, CSK, RSK) When a software key (LSK, CSK or RSK) has a function, there should be an indicator on software key bar to inform user what it will do when pressed. D-Pad (UP, DOWN, LEFT, RIGHT) D-pad is used to move highlight to different items on list views or grid views, switch tabs, adjust spinners or sliders, move text cursor, and move browser cursor. Long pressing a directional key will send keyDown event continuously and it speeds up. Call Key Call key is used to make a call or answer an incoming call. Independent Back Key Type And Combined Key Type Independent Back Key Type Back/Clear Key In an input, BACK/CLEAR key is used to clear one character. If the input is empty, pressing BACK/CLEAR key works like normal case.In normal case (not in an input), pressing BACK/CLEAR key goes to the upper level of an app. At the top level of the app, pressing BACK/CLEAR key leaves the app.In a dialog, if LSK is Cancel, BACK/CLEAR key works like LSK. Otherwise, pressing BACK/CLEAR key does nothing. End/Power Key END/POWER key is used to end a call, reject an incoming call, or leave an app.Long pressing END/POWER key invokes the sleep menu with actions including Lock, Restart, Power off, etc.When the device is off, long pressing END/POWER key powers on the device. Combined Key Type Back/Clear/End/Power Key In an input, BACK/CLEAR/END/POWER key is used to clear one character. If the input is empty, pressing BACK/CLEAR/END/POWER key works like normal case.In normal case (not in an input), pressing BACK/CLEAR/END/POWER key goes to the upper level of an app. At the top level of the app, pressing BACK/CLEAR/END/POWER key leaves the app.In a dialog, if LSK is Cancel, BACK/CLEAR/END/POWER key works like LSK. Otherwise, pressing BACK/CLEAR/END/POWER key does nothing.BACK/CLEAR/END/POWER key is used to end a call, reject an incoming call.In Homescreen, long pressing BACK/CLEAR/END/POWER key invokes the sleep menu with actions including Lock, Restart, Power off, etc.In an app, long pressing BACK/CLEAR/END/POWER key leaves the app.When the device is off, long pressing BACK/CLEAR/END/POWER key powers on the device. Number Pad Number pad is used to enter numbers or characters with certain input methods. Volume Key Volume key is used to control volume directly. There are 4 types of volume: Ringtones & Notice Alerts, Media, Alarm, and Telephony. When pressing volume key, system will adjust the proper type of volume by context. For devices without volume keys, app should provide at least one way to adjust volume. It is recommended to use UP/DOWN key to invoke volume panel directly and then user can adjust volume. Fallback solution is to use Options > Volume to invoke volume panel.","keywords":""},{"title":"Marketing Banner","type":0,"sectionRef":"#","url":"docs/sfp-3.0/04.design-guide/marketing-banner","content":"Your marketing banner is a background image appears behind the icon, app name, and subtitle. It plays an assistant role that communicates your app’s feature and purpose. Using an attractive image can encourage product page views and get users attention. The image should be simple and subtle, and it needs to ensure your icon, app name, and subtitle are legible, avoid adding unnecessary visual details to your marketing banner. KaiStore UI Design resource sketch file is here for you to design the Marketing Banner of your product. It includes screenshot preview and helps quickly export the product assets. The resource file requires Sketch 51 or higher version. Size Banner Image Requirements Format: JPG format, non alphaDimensions: Portrait/Landscape: 240 x 130 pixelsMaximum file size: 100 KBFile Name: Portrait/Landscape: img_AppName.jpg (e.g. img_weather.jpg, img_star_war.jpg) Your marketing banner will be displayed responsively on the Landing page and Product page in both portrait and landscape layouts. Usage Design Tips Suggest using photos, illustrationsAvoid adding text overlayKeep image’s ratio correct Theme color The color theme represents the background color of an app on Store Launch page and Product page. Also, It replaces the background image if your app does not have a background image submitted. Background Color Requirements Pick one color with Hex color codes, or choose one from below color palettes. The purple is the default option. Background Color & Focus Color Requirements Pick one color with Hex color codes, or choose one from below default color palettes. Purple\t#8500DC Rose\t#CD006F Red\t#FF0E0E Lime\t#6B9A23 Cyan\t#00B1B4 Blue\t#0071DD Orange\t#FF4B00 Dark Gray\t#323232","keywords":""},{"title":"Launcher Icon","type":0,"sectionRef":"#","url":"docs/sfp-3.0/04.design-guide/launcher-icon","content":"The launcher icon is the first visual expression of your app, as it directly and, hopefully, effectively communicates its main purpose to the user. Unified graphic elements allow you to create simple, intuitive, consistent icons that reflect product characteristics and quality. It can also help your app stand out from other apps. The design principles in the following pages serve as a guide for icon design. KaiOS App Icon Template resource sketch file is here for you to design your KaiOS app icon. It includes screenshot preview and helps quickly export multiple icon sizes. The resource file requires Sketch 51 or higher version. Sizes Baseline icon Every app must supply a baseline icon at 56 x 56 pixels for use on the All Apps grid and list views, the KaiStore, Notices, and throughout the system once the app has been installed. Large icon Every app should also provide a larger icon at 112 x 112 pixels (you can make the baseline icon 2x bigger proportionally) for display in the All Apps single view and the app launch screen. Image Size (px)\tFile Name\tUse For56 x 56 (Baseline)\tAppName_56.png\tAll Apps (grid view) All Apps (List view) KaiOS Store Notices In-app Notices 112 x 112\tAppName_112.png\tAll Apps (Single view) Launch Screen Shape The app icon image is provided at 56 x 56 pixels in 24-bit png format. Icon shape is limited to 46 x 46 pixels round shape or 44 x 44 pixels square shape which casts a soft shadow around it. Usage Normal & focus states Each icon has normal and focussed states, differentiated by color composition. Avoid using the same color for both states so they are easily distinguishable. Appropriate icon size It is important to keep the icon design area between 44x44 and 46x46 pixels; an oversized icon will obstruct the view while an app is being selected. Concise icon style All colors should be solid color elements with minimal flair; three- dimensional designs and textures will cause the icons to become overly complex and lead to inconsistencies on low resolution devices. Transparency of icon The launcher icon and focused color background should not be transparent, as it will expose the wallpaper and make it hard to recognize the icon. Focus State Color your own Our unique transition design animates when an app is selected by users. It helps users stay focused while navigating to the app they are looking for. The focus color in the All Apps view can be changed individually and customized to suit any brand need, as shown in the following illustration.","keywords":""},{"title":"CameraManager","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/cameras/cameraManager","content":"Description# The CameraManager interface provides access to any cameras available on the device being used. Properties# This interface doesn't implements, nor inherits any property. Methods# CameraManager.getCamera Gets a camera instance based on its identifier. CameraManager.getListOfCameras() Returns an Array of all camera identifiers available on the device. Permissions# \"permissions\": { \"camera\": { \"description\": \"Required for accessing cameras on the device.\" } } Copy","keywords":""},{"title":"CameraManager.getListOfCameras()","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/cameras/cameraManager/getListOfCameras","content":"Description# This method is used to get an Array of identifiers of all the cameras available on the device. Syntax# var cameras = navigator.b2g.cameras.getListOfCameras(); Copy Return Value# camera an Array of identifiers of all cameras available. Permissions# \"permissions\": { \"camera\": { \"description\": \"Required for accessing cameras on the device.\" } } Copy","keywords":""},{"title":"KaiStore","type":0,"sectionRef":"#","url":"docs/sfp-3.0/07.submit-to-kaistore","content":"About KaiStore is a service channel to showcase your product and allow users to install an app on their phones. This guide serves as a resource for you and makes sure your app icon, app name, description, and marketing banner are ready for your product page. App name An app name is a name for your product. It plays a crucial role in how users discover it on the KaiStore. Choose a simple, memorable name that is easy to spell and hints at what your app does. Avoid names that use generic terms or are too similar to existing app names. An app name should not be longer than 20 characters. Subtitle Your app’s subtitle appears below your app name throughout the KaiStore. A subtitle is a short and striking or memorable message, and is intended to summarize your app in a concise phrase. A compelling subtitle can encourage product page views and installs. The maximum length of a subtitle is 40 characters. Icon The app icon (aka. Launcher icon) is the first visual expression of the app, as it directly and effectively communicates the main feature and purpose with the user. Unified graphic elements allow you to create simple, intuitive, and consistent icons that reflect product characteristics and quality. These elements also ensure your app stands out from other ones. To ensure the icon is legible in all sizes, avoid adding unnecessary visual details. For more details, please go to Launcher Icon. Marketing banner Your marketing banner is a background image that appears behind the icon, app name, and subtitle. It helps communicate your app’s feature and purpose. Using an attractive image can encourage product page views and attract user attention. The image should be simple and subtle. Remove unnecessary visual details to ensure your icon, app name, and subtitle are legible. For more information, please go to marketing banner. Description Provide a succinct description that highlights the features and functionality of your app on the Product page. The ideal description is a concise, informative paragraph that introduces your app in a few sentences. Such a description will maximize user engagement. Don’t add unnecessary keywords to your description in an attempt to improve search results. Also avoid including specific prices in your app description. Pricing is already shown on the product page, and references within the description may not be accurate in all countries and territories. Category You can assign one category to your app so that users can find it while browsing the KaiStore. The category you select is particularly important for your app’s discoverability on the KaiStore. This will be the category in which the app appears when users browse the KaiStore. Be sure to select a proper category from the list below that best describes the primary function of your app. A list of categories for apps GamesSocialEntertainmentUtilitiesSportsNewsHealthLifestyleShoppingBooks & Reference Theme color The color theme represents the focus color of an app in the All Apps view when the user selects the app. For more information, please go to marketing banner. Status tags for app These tags displays your App's price and enabled states on the Launch page and Product page. Status Tags on the launch page. Free tag in product page, press center key \"GET\" to start downloading. Price tag in product page, press center key \"BUY\" to go payment page. Update tag Reminder to update. On the product page press center key \"UPDATE\" to get new version. Enabled tag Indicates App has been installed successfully, the tag will display to check icon. On the product page press center key \"GO\" to launch App. Downloading Downloading App or update. On the product page press center key \"STOP\" to cancel downloading. Status tag for website The tags displays your Website enabled states on the Launch page and Product page. Status Tags on the launch page. Status Tags on the launch page. Status Tags on the launch page. Submit my app Thank you for your interest in contributing to the KaiOS platform. Please have a look at our App Submission and Distribution Agreement which you would accept before you could submit your app. Currently, we are only accepting apps that are monetized using KaiAds SDK. Most apps on the developer portal are for QA that use KaiAds for monetization. Visit the KaiAds website to learn more. After you have integrated KaiAds, go through this checklist. We hope you have read all the documentation on the portal. This will help you understand what is considered a qualified app for KaiOS. Make sure the name of the app is relevant to the app. You can’t have a generic app name such as wallpaper, ringtone, wallet, phone, etc. Prepare an app manifest for the required fields. You cannot submit your app without a proper manifest so make sure you read this section carefully. We test your apps on 512MB as well has 256MB devices. We recommend you to optimize the performance of the apps so that you can reach our global audience. You can learn about improving the performance of your app through this article. The type of your app in the manifest file. Hosted app, the type can only be type: \"web\".Native app should be \"web\" by default.If your app needs to access Privileged or Certified APIs, Justify it in the \"Known Issue\" section on the submission portal. If you have any comments for our QA team, you can mention them in \"known issues\" on the Submission Portal. You only need to submit two app icons. (56x56 and 112x112) Read our UI design guidelines carefully. Include Subtitles and App Description Page. This is the first texts that users will see, having better app descriptions have proved to increase the app downloads.Subtitle text limit - 40 characters (including white spaces), Description text limit - 220 characters (including white spaces). You can test your Submitted Application on any KaiOS phone that has KaiStore available on it. Once you have submitted your app on the Submission Portal, click on 'Test Device'.Enter the IMEI of your KaiOS device and after 5 minutes you will be able to view your app on the device KaiStore. Test your app, and if you find any unusual behavior, fix the changes and upload the new version. Once you have submitted your app, the KaiStore team will review your submission and inform you of the result. If you donʼt hear from us within three weeks, please contact developersupport@kaiostech.com Submission Portal To submit your app, visit the Submission Portal. The KaiStore team reserves the right to reject your app under the following circumstances: The above steps have not been followed.The required materials have not been submitted or are incomplete.Your app does not meet our quality threshold in areas such as 'Basic function', 'Interaction', 'Stability', as well as 'Compatibility'.","keywords":""},{"title":"navigator.b2g.cameras","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/cameras/navigator-b2g-cameras","content":"Description# Returns a CameraManager object you can use to access the cameras available on the user's device. Syntax# var cameraManager = navigator.b2g.cameras; Copy Value# navigator.b2g.cameras is a CameraManager object you can use to access the cameras available on the device.","keywords":""},{"title":"Hosted App","type":0,"sectionRef":"#","url":"docs/sfp-3.0/04.design-guide/hosted-app","content":"This article provides an introduction to some behaviors of hosted app in KaiOS. Cursor If a hosted app needs cursor, developer can set cursor as true to enable OS provided cursor. Cursor behaviors are similar to Browser app: Press D-Pad to move the cursor. Press CSK to perform mouse click. Status Bar A hosted app can hide the status bar by setting fullscreen as true. Address Bar There is no address bar for hosted app. Developers can make it by themselves. Browser app has address bar. Loading Progress Bar By default OS doesn’t show loading progress bar for hosted app. Developers can make loading progress bar for a hosted app by themselves, or set loading progress bar as true to show OS provided loading progress bar. Software Key No OS provided software key bar for hosted app. Developers can make it by themselves. Pressing LSK: No predefined functions. App can listen to its key event.Pressing CSK: Perform mouse click.Pressing RSK: No predefined functions. App can listen to its key event. Browser app has software key bar. Pressing LSK: Start using search bar.Pressing CSK: Perform mouse click.Pressing RSK: Show Options menu. Shortcut Key Shortcut keys are not available in hosted app. Developers can make it by themselves. Browser app has shortcut keys by default when a page is loaded. Input When entering text edit mode, focus on the input and show OS-provided software key bar for text inputting. Pressing CSK: Send Enter key event.Pressing RSK: Leave text edit mode (blur from the input) and hide the text inputting software key bar. Full-Screen Video When entering full-screen video mode, hide cursor and show OS-provided softkey bar. Pressing LSK/BACK: Leave full-screen mode.Pressing CSK: Play/Pause.Pressing UP/DOWN: Volume up/down.Pressing LEFT/RIGHT: Jump 10 sec backward/forward. Error Handling When trying to change pages without internet connection, show this error message with 3 buttons. Error title and message change according to different errors. Select “Settings”: Go to connection settings.Select “Refresh”: Refresh the page.Select “Quit”: Quit the app directly. Volume App has ability to call vol up/down api to change system volume. When calling that api, OS will show volume panel (auto-detecting volume channel and show the corresponding panel) and change the volume levels, and then disappear after 2 sec timeout. However, app should handle when/how to change the volume. For example, pressing some key to vol up, app should listen the key by itself.","keywords":""},{"title":"navigator.b2g.audioChannelManager","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/audioChannelManager/navigator-b2g-audioChannelManager","content":"Description# The AudioChannelManager interface of the AudioChannels API includes features for managing your device's audio channels, including setting what channel's volume to affect when the volume buttons are pressed inside a particular app. Methods# Note: Inherits methods from its parent, EventTarget Properties# Note: Inherits methods from its parent, EventTarget AudioChannelManager.headphones A boolean that indicates whether headphones are plugged into the device. AudioChannelManager.telephonySpeaker A boolean that allows you to set whether the \"telephony\" audio channel should be played out of the device's speakers. AudioChannelManager.volumeControlChannel A DOMString that allows you to set which audio channel should have its volume changed when you press the device's hardware volume controls. Event handlers# AudioChannelManager.onheadphoneschange Fired when the device's headphones are plugged in or unplugged. Examples# In the following simple example, we use the navigator.b2g.audioChannelManager property to access the app's AudioChannelManager object, first to do some rudimentary feature detection, and then to set value of the AudioChannelManager.volumeControlChannel property, based on a received variable. navigator.b2g.AudioChannelManager.volumeControlChannel = 'normal' AudioChannelClient('normal') HTMLMediaElement.mozAudioChannelType = 'normal' AudioContext.mozAudioChannelType = 'normal' Copy navigator.b2g.AudioChannelManager.volumeControlChannel = 'content' AudioChannelClient('content') HTMLMediaElement.mozAudioChannelType = 'content' AudioContext.mozAudioChannelType = 'content' Copy navigator.b2g.AudioChannelManager.volumeControlChannel = 'notification' AudioChannelClient('notification') HTMLMediaElement.mozAudioChannelType = 'notification' AudioContext.mozAudioChannelType = 'notification' Copy navigator.b2g.AudioChannelManager.volumeControlChannel = 'alarm' AudioChannelClient('alarm') HTMLMediaElement.mozAudioChannelType = 'alarm' AudioContext.mozAudioChannelType = 'alarm' Copy navigator.b2g.AudioChannelManager.volumeControlChannel = 'system' AudioChannelClient('system') HTMLMediaElement.mozAudioChannelType = 'system' AudioContext.mozAudioChannelType = 'system' Copy","keywords":""},{"title":"CameraManager.getCamera()","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/cameras/cameraManager/getCamera","content":"Description# This method is used to access to one of the cameras available on the device based on its identifier. You can get a list of the available cameras by calling the CameraManager.getListOfCameras() method. Syntax# Promise CameraManager.getCamera(camera, cameraConfiguration); Copy Parameters# camera Specify the camera you want to use (the device may have more than one camera). cameraConfiguration An object allowing you to set camera options for this camera: mode, previewSize and recorderProfile. Return Value# Returns a Promise. The Promise's .then() function accepts two function arguments: onsuccess A callback function that take an object as parameter. This object has the camera property as CameraControl object and the configuration property as actual cameraConfiguration of device. onerror An object allowing you to set camera options for this camera: mode, previewSize and recorderProfile. Examples# var options = { mode: 'picture', recorderProfile: 'jpg', previewSize: { width: 352, height: 288 } }; var camera = navigator.b2g.cameras.getListOfCameras()[0]; function onSuccess(cameraObj) { var cameraControl = cameraObj.camera; // Do stuff with the cameraControl }; function onError(error) { console.warn(error); }; navigator.b2g.cameras.getCamera(camera, options).then(onSuccess, onError); Copy Permissions# \"permissions\": { \"camera\": { \"description\": \"Required for accessing cameras on the device.\" } } Copy","keywords":""},{"title":"navigator.b2g.virtualCursor","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/virtualCursor/navigator-b2g-virtualCursor","content":"Description# Supports emulating a cursor in app, which user can control with d-pad. Interfaces# interface DOMVirtualCursor { /** * Enable virtual cursor on this window * Throws an exception if no permissions. */ [Throws] void enable(); /** * Disable virtual cursor on this window * Throws an exception if no permissions. */ [Throws] void disable(); readonly attribute boolean enabled; }; Copy Examples# To turn on cursor: navigator.b2g.virtualCursor.enable(); Copy To turn off cursor: navigator.b2g.virtualCursor.disable(); Copy","keywords":""},{"title":"navigator.b2g.getDeviceStorage","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/getDeviceStorage/navigator-b2g-getDeviceStorage","content":"Description# The getDeviceStorage method is used to access some storage area available on the device. This method gives access to a storage area from the device's default storage, that is the storage area whose .default attribute is true. This is controlled by the user via Settings App > Media Storage > Default media location (e.g. sdcard, internal memory, etc.) Alternatively, you can use the getDeviceStorages method, which returns an Array of DeviceStorage objects, one per physical storage area. Syntax# var instanceOfDeviceStorage = navigator.b2g.getDeviceStorage(storageName); Copy Parameters# storageName The name of the targeted storage area. Firefox OS supports the following areas: app: This storage area is used to store the user data needed by apps. As it is critical data, accessing this storage area requires some extra privileges and is available for certified applications only. music: This is the storage area where music and sounds are stored. pictures: This is the storage area where pictures are stored. sdcard: This is the storage area that gives access to the device's SDCard. videos: This is the storage area where videos are stored. Returns# This method returns a DeviceStorage object that can be used to manage files on the associated storage area. Examples# var sdcard = navigator.b2g.getDeviceStorage(\"sdcard\"); Copy","keywords":""},{"title":"navigator.b2g.inputMethod","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/inputMethod/navigator-b2g-inputMethod","content":"Description# The InputMethod API enables the keyboard app to interact with the targeted input field. Interfaces# interface InputMethod { Promise<boolean> setComposition(DOMString text); Promise<boolean> endComposition(optional DOMString text); Promise<boolean> sendKey(DOMString key); Promise<boolean> keydown(DOMString key); Promise<boolean> keyup(DOMString key); /** * Delete a text/node/selection before the cursor */ Promise<boolean> deleteBackward(); /** * Select the <select> option specified by index. * If this method is called on a <select> that support multiple * selection, then the option specified by index will be added to * the selection. * If this method is called for a select that does not support multiple * selection the previous element will be unselected. */ void setSelectedOption(long index); /** * Select the <select> options specified by indexes. All other options * will be deselected. * If this method is called for a <select> that does not support multiple * selection, then the last index specified in indexes will be selected. */ void setSelectedOptions(sequence<long> indexes); /** * Remove focus from the current input, usable by Gaia System app, globally, * regardless of the current focus state. */ void removeFocus(); }; Copy Examples# TBD","keywords":""},{"title":"DeviceCapabilityManager service","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/daemon-api/devicecapability/daemon-api-devicecapability","content":"Instanciating the service# Load the following scripts: <script src=\"http://127.0.0.1:8081/api/v1/shared/core.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/shared/session.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/apps/service.js\"></script> Copy You can then get an instance of the service with code similar to: function getService() { return new Promise((resolve, reject) => { let session = new lib_session.Session(); let sessionstate = { onsessionconnected() { lib_devicecapability.DeviceCapabilityManager.get(session).then(resolve, reject); }, onsessiondisconnected() { reject(\"Session Disconnected\"); } }; // On desktop version, set ENV WS_RUNTIME_TOKEN=secrettoken when running the api-daemon. session.open(\"websocket\", \"localhost:8081\", \"secrettoken\", sessionstate); }); } let instance = getService().then(devicecapability => { ... }); Copy This service implements the DeviceCapabilityFactory interface. DeviceCapabilityFactory Interface# Methods# get get(/ , feature / string) Resolves with json Rejects with void","keywords":""},{"title":"AudioVolumeManager service","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/daemon-api/audiovolumemanager/daemon-api-audiovolumemanager","content":"Instanciating the service# Load the following scripts: <script src=\"http://127.0.0.1:8081/api/v1/shared/core.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/shared/session.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/apps/service.js\"></script> Copy You can then get an instance of the service with code similar to: function getService() { return new Promise((resolve, reject) => { let session = new lib_session.Session(); let sessionstate = { onsessionconnected() { lib_audiovolume.AudioVolumeManager.get(session).then(resolve, reject); }, onsessiondisconnected() { reject(\"Session Disconnected\"); } }; // On desktop version, set ENV WS_RUNTIME_TOKEN=secrettoken when running the api-daemon. session.open(\"websocket\", \"localhost:8081\", \"secrettoken\", sessionstate); }); } let instance = getService().then(audiovolume => { ... }); Copy This service implements the AudioVolume interface. AudioVolumeState enumeration# { NONE, VOLUME_UP, VOLUME_DOWN, VOLUME_SHOW, } AudioVolume Interface# Methods# requestVolumeDown requestVolumeShow requestVolumeUp requestVolumeDown() Resolves with void Rejects with void requestVolumeShow() Resolves with void Rejects with void requestVolumeUp() Resolves with void Rejects with void Events# AUDIO_VOLUME_CHANGED The AUDIO_VOLUME_CHANGED event emits a AudioVolumeState To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.AUDIO_VOLUME_CHANGED_EVENT, handleEvent); target.removeEventListener(target.AUDIO_VOLUME_CHANGED_EVENT, handleEvent); Copy","keywords":""},{"title":"navigator.b2g.externalapi","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/externalapi/navigator-b2g-externalapi","content":"Description# TBD Interfaces# interface ExternalAPI { Promise<DOMString> getToken(); }; Copy Examples# TBD","keywords":""},{"title":"navigator.b2g.dataCallManager","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/dataCallManager/navigator-b2g-dataCallManager","content":"Description# TBD Interfaces# /** * Request data call for a certain data call type. * * @param type * The desired data call type, one of the DataCallType values. * @param serviceId [optional] * Default value is the user setting service id for data call. * * @return If success, promise is resolved with the new created DataCall object. Otherwise, rejected with an error message. */ Promise<DataCall> requestDataCall(DataCallType type, optional unsigned long serviceId); /** * Request the current state of a certain data call type. * * @param type * The desired data call type, one of the DataCallType values. * @param serviceId [optional] * Default value is the user setting service id for data call. * * @return If success, promise is resolved with a DataCallState. Otherwise, * rejected with an error message. */ Promise<DataCallState> getDataCallState(DataCallType type, optional unsigned long serviceId); Copy Interface Params# DataCallType The desired data call type. enum DataCallType { \"default\", \"mms\", \"supl\", \"ims\", \"dun\", \"fota\", \"hipri\", \"xcap\", \"cbs\", \"Emergency\" }; Copy DataCallState enum DataCallState { \"unknown\", \"connecting\", \"connected\", \"disconnecting\", \"disconnected\", \"unavailable\" }; Copy Examples# TBD","keywords":""},{"title":"navigator.b2g.mobileConnection","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/mobileConnection/navigator-b2g-mobileConnection","content":"Description# This API is used to get information about the current mobile voice and data connection states of the device. It is accessible through navigator.b2g.mobileConnection, which returns an array of MozMobileConnection objects. Methods# lastKnownNetworklastKnownHomeNetwork Examples# navigator.b2g.mobileConnection[0].lastKnownNetwork navigator.b2g.mobileConnection[0].lastKnownHomeNetwork Copy","keywords":""},{"title":"navigator.geolocation","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/navigator/geolocation/navigator-geolocation","content":"Description# The Geolocation interface represents an object able to programmatically obtain the position of the device. It gives Web content access to the location of the device. This allows a Web site or app to offer customized results based on the user's location. Notice that 'geolocation' permission is required for packaged app to use Geolocation API. (i.e. The developer must add the permisson to the manifest.webapp) An object with this interface is obtained using the navigator.geolocation property implemented by the Navigator object. Properties# The Geolocation interface neither implements, nor inherits any property. Methods# The Geolocation interface doesn't inherit any method. navigator.geolocation.watchPositionDetermines the device's current location and gives back a Position object with the data.navigator.geolocation.clearWatchRemoves the particular handler previously installed using watchPosition().navigator.geolocation.getCurrentPositionGet the current position once time. Example# TBD","keywords":""},{"title":"SettingsManager service","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/daemon-api/settings/daemon-api-settings","content":"Instanciating the service# Load the following scripts: <script src=\"http://127.0.0.1:8081/api/v1/shared/core.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/shared/session.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/apps/service.js\"></script> Copy You can then get an instance of the service with code similar to: function getService() { return new Promise((resolve, reject) => { let session = new lib_session.Session(); let sessionstate = { onsessionconnected() { lib_settings.SettingsManager.get(session).then(resolve, reject); }, onsessiondisconnected() { reject(\"Session Disconnected\"); } }; // On desktop version, set ENV WS_RUNTIME_TOKEN=secrettoken when running the api-daemon. session.open(\"websocket\", \"localhost:8081\", \"secrettoken\", sessionstate); }); } let instance = getService().then(settings => { ... }); Copy This service implements the SettingsFactory interface. GetErrorReason enumeration# { UNKNOWN_ERROR, NON_EXISTING_SETTING, } GetError dictionnary# { name: string, reason: GetErrorReason, } SettingInfo dictionnary# { name: string, value: json, } SettingObserver callback object# Creating a SettingObserver object# Use code similar to: class MyCallbackObject extends lib_settings.SettingObserverBase { constructor(service, session) { super(service.id, session); } callback(...) { ... } Copy Methods# callback callback(/ , setting / SettingInfo) Resolves with void Rejects with void SettingsFactory Interface# Methods# addObserver clear get getBatch removeObserver set addObserver(/ , name / string/ , observer / SettingObserver) Resolves with void Rejects with void clear() Resolves with void Rejects with void get(/ , name / string) Resolves with SettingInfo Rejects with GetError getBatch(/ , name / [string]) Resolves with [SettingInfo] Rejects with void removeObserver(/ , name / string/ , observer / SettingObserver) Resolves with void Rejects with void set(/ , settings / [SettingInfo]) Resolves with void Rejects with void Events# CHANGE The CHANGE event emits a SettingInfo To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.CHANGE_EVENT, handleEvent); target.removeEventListener(target.CHANGE_EVENT, handleEvent); Copy","keywords":""},{"title":"navigator.b2g.mobileMessage","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/mobileMessage/navigator-b2g-mobileMessage","content":"Description# WebSMS is an API that makes it possible for web content to create, send, and receive Short Message Service (SMS) or Multimedia Messaging Service (MMS) messages. Syntax# interface MobileMessageManager : EventTarget { [Throws] DOMRequest getSegmentInfoForText(DOMString text); /** * Send SMS. * * @param number * Either a DOMString (only one number) or an array of numbers. * @param text * The text message to be sent. * @param sendParameters * A SmsSendParameters object. * * @return * A DOMRequest object indicating the sending result if one number * has been passed; an array of DOMRequest objects otherwise. */ [Throws] DOMRequest send(DOMString number, DOMString text, optional SmsSendParameters sendParameters={}); [Throws] sequence<DOMRequest> send(sequence<DOMString> numbers, DOMString text, optional SmsSendParameters sendParameters={}); /** * Send MMS. * * @param parameters * A MmsParameters object. * @param sendParameters * A MmsSendParameters object. * * @return * A DOMRequest object indicating the sending result. */ [Throws] DOMRequest sendMMS(optional MmsParameters parameters={}, optional MmsSendParameters sendParameters={}); [Throws] DOMRequest getMessage(long id); // The parameter can be either a message id, or a {Mms,Sms}Message, or an // array of {Mms,Sms}Message objects. [Throws] DOMRequest delete(long id); [Throws] DOMRequest delete(SmsMessage message); [Throws] DOMRequest delete(MmsMessage message); [Throws] DOMRequest delete(sequence<(long or SmsMessage or MmsMessage)> params); // Iterates through {Mms,Sms}Message. [Throws] MobileMessageIterable getMessages(optional MobileMessageFilter filter={}, optional boolean reverse = false); [Throws] DOMRequest markMessageRead(long id, boolean read, optional boolean sendReadReport = false); // Iterates through MobileMessageThread. [Throws] MobileMessageIterable getThreads(); [Throws] DOMRequest retrieveMMS(long id); [Throws] DOMRequest retrieveMMS(MmsMessage message); [Throws] Promise<SmscAddress> getSmscAddress(optional unsigned long serviceId); /** * Set the SMSC address. * * @param smscAddress * SMSC address to use. * Reject if smscAddress.address does not present. * @param serviceId (optional) * The ID of the RIL service which needs to be specified under * the multi-sim scenario. * @return a Promise * Resolve if success. Otherwise, reject with error cause. */ [NewObject] Promise<void> setSmscAddress(optional SmscAddress smscAddress={}, optional unsigned long serviceId); attribute EventHandler onreceived; attribute EventHandler onretrieving; attribute EventHandler onsending; attribute EventHandler onsent; attribute EventHandler onfailed; attribute EventHandler ondeliverysuccess; attribute EventHandler ondeliveryerror; attribute EventHandler onreadsuccess; attribute EventHandler onreaderror; attribute EventHandler ondeleted; }; Copy Methods# navigator.b2g.mobileMessage.addEventListener Add EventListener for mobileMessage. navigator.b2g.mobileMessage.getThreads() Iterates through MobileMessageThread. navigator.b2g.mobileMessage.getMessage() Iterates through {Mms,Sms}Message. navigator.b2g.mobileMessage.retrieveMMS() retrieveMMS through mobileMessage. navigator.b2g.mobileMessage.getMessages() Iterates through {Mms,Sms}Message. navigator.b2g.mobileMessage.send() Send SMS. navigator.b2g.mobileMessage.sendMMS() Send MMS. navigator.b2g.mobileMessage.delete() Delete {Mms,Sms}Message. navigator.b2g.mobileMessage.markMessageRead() &Mark Message as read. navigator.b2g.mobileMessage.getSegmentInfoForText() Get segment information for text message. Sample code# TBD","keywords":""},{"title":"navigator.mediaDevices.getUserMedia","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/navigator/getUserMediaDevices/navigator-getUserMediaDevices","content":"Description# The MediaDevices.getUserMedia() method prompts the user for permission to use a media input which produces a MediaStream with tracks containing the requested types of media. That stream can include, for example, a video track (produced by either a hardware or virtual video source such as a camera, video recording device, screen sharing service, and so forth), an audio track (similarly, produced by a physical or virtual audio source like a microphone, A/D converter, or the like), and possibly other track types. It returns a Promise that resolves to a MediaStream object. If the user denies permission, or matching media is not available, then the promise is rejected with NotAllowedError or NotFoundError respectively. Generally, you will access the MediaDevices singleton object using navigator.mediaDevices, like this: async function getMedia(constraints) { let stream = null; try { stream = await navigator.mediaDevices.getUserMedia(constraints); /* use the stream */ } catch(err) { /* handle the error */ } } Copy Similarly, using the raw promises directly, the code looks like this: navigator.mediaDevices.getUserMedia(constraints) .then(function(stream) { /* use the stream */ }) .catch(function(err) { /* handle the error */ }); Copy Syntax# var promise = navigator.mediaDevices.getUserMedia(constraints); Copy Parameters# constraints A MediaStreamConstraints object specifying the types of media to request, along with any requirements for each type. The constraints parameter is a MediaStreamConstraints object with two members: video and audio, describing the media types requested. Either or both must be specified. If the browser cannot find all media tracks with the specified types that meet the constraints given, then the returned promise is rejected with NotFoundError.","keywords":""},{"title":"navigator.b2g.alarmManager","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/alarmManager/navigator-b2g-alarmManager","content":"Description# Alarm API allows applications to schedule notification at a specific time in the future. For example, some applications like alarm-clock, calendar or auto-update might need to utilize the Alarm API to trigger particular device behaviors at specified time points. Alarms persist after reboot. When bootup, all expired alarms are fired immediately. When an alarm is fired, it is dispatched to applications through the System Message API, so applications which want to react to alarms have to register themselves to the alarm messages. Alarm API exposes to both Window and Worker scope. Get all alarms# navigator.b2g.alarmManager.getAll().then( (list) => console.log(list), // Array of alarm objects. (err) => console.log(\"getAll err: \" + err) ); Copy Add an alarm# options = { \"date\": new Date(Date.now() + 10*60*1000), \"data\": {\"note\": \"take a nap\"}, \"ignoreTimezone\": false }; navigator.b2g.alarmManager.add(options).then( (id) => console.log(\"add id: \" + id), (err) => console.log(\"add err: \" + err) ); Copy Remove an alarm# navigator.b2g.alarmManager.remove(7); Copy Handle alarm# Applications need to subscribe system message of type \"alarm\" to receive alarm messages. For more details, please see Subscribe system messages Subscribe alarm# Use from main scripts# navigator.serviceWorker.register(\"sw.js\").then(registration => { registration.systemMessageManager.subscribe(\"alarm\").then( rv => { console.log('Successfully subscribe system messages of name \"alarm\".'); }, error => { console.log(\"Fail to subscribe system message, error: \" + error); } ); }); Copy Receive alarm# self.onsystemmessage = (e) => { console.log(\"receive systemmessage event on sw.js!\"); console.log(e.data.json()); // The alarm object }; Copy TODO# Handle system time and timezone change# Test on CPU wake lock# Test listener cleanup on inner-window-destroyed#","keywords":""},{"title":"Telephony service","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/daemon-api/telephony/daemon-api-telephony","content":"Instanciating the service# Load the following scripts: <script src=\"http://127.0.0.1:8081/api/v1/shared/core.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/shared/session.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/apps/service.js\"></script> Copy You can then get an instance of the service with code similar to: function getService() { return new Promise((resolve, reject) => { let session = new lib_session.Session(); let sessionstate = { onsessionconnected() { lib_telephony.Telephony.get(session).then(resolve, reject); }, onsessiondisconnected() { reject(\"Session Disconnected\"); } }; // On desktop version, set ENV WS_RUNTIME_TOKEN=secrettoken when running the api-daemon. session.open(\"websocket\", \"localhost:8081\", \"secrettoken\", sessionstate); }); } let instance = getService().then(telephony => { ... }); Copy This service implements the TelephonyManager interface. CallState enumeration# { IDLE, RINGING, OFFHOOK, } TelephonyManager Interface# Members# callState callState is of type CallState To get value, use code similar to: target.callState().then(value => { ... }); Copy To set value, use code similar to: target.callState = value; Copy Events# CALLSTATE_CHANGE The CALLSTATE_CHANGE event emits a CallState To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.CALLSTATE_CHANGE_EVENT, handleEvent); target.removeEventListener(target.CALLSTATE_CHANGE_EVENT, handleEvent); Copy","keywords":""},{"title":"TCP Socket API","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/navigator/mozTCPSocket/tcpSocketAPI","content":"Description# The TCPSocket API offers a whole API to open and use a TCP connection. This allows app makers to implement any protocol available on top of TCP such as IMAP, IRC, POP, HTTP, etc., or even build their own to sustain any specific needs they could have. Permissions# In order to use that API, as for all privileged API, it's required to request permission to use it within the app manifest. \"permissions\" : { \"tcp-socket\" : { \"description\" : \"Create TCP sockets and communicate over them.\" } } Copy Overview# This API is available through the Navigator.mozTCPSocket property which is itself a TCPSocket object. Opening a socket# Opening a socket is done with the TCPSocket.open() method. This method expects up to three parameters: A string representing the hostname of the server to connect to (it can also be its raw IP address).A number representing the TCP port to be used by the socket (some protocols have a standard port, for example 80 for HTTP, 447 for SSL, 25 for SMTP, etc. Port numbers beyond 1024 are not assigned to any specific protocol and can be used for any purpose.)A optional object containing up to two options: a boolean named useSecureTransport is the socket needed to use SSL, false by default; and a string named binaryType allows to state the type of data retrieved by the application through the data event, with the expected values string or arraybuffer. By default, it is string. var socket = navigator.mozTCPSocket.open('localhost', 80); Copy Note: Only certified apps can use a port below 1024. Listening for connections# Listening for connections is done with the TCPSocket.listen() method. This method expects up to three parameters: A number representing the TCP port to be used to listen for connections.An optional object specifying the details of the socket. This object expects a property called binaryType, which is a string that can have two possible values: \"string\" or \"arraybuffer\". If the value is \"arraybuffer\" then the TCPSocket.send() will use ArrayBuffers and the data received from the remote connection will also be available in that format.A number representing the maximum length that the pending connections queue can grow. var socket = navigator.mozTCPSocket.listen(8080); Copy Note: Only certified apps can use a port below 1024. Sending data# Sending data is done using the TCPSocket.send() method. The data sent can be either a string or a Uint8Array object; however, remember that a TCP socket always deals with binary data. For that reason, it's a lot safer to use Uint8Array instead of a string when sending data. As per the TCP protocol, it's a good optimization to send a maximum of 64kb of data at the same time. As long as less than 64kb has been buffered, a call to the send method returns true. Once the buffer is full, the method will return false which indicates the application should make a pause to flush the buffer. Each time the buffer is flushed, a drain event is fired and the application can use it to resume data sending. It's possible to know exactly the current amount of data buffered with the TCPSocket.bufferedAmount property. function getData() { var data; // do stuff that will retrieve data return data; } function pushData() { var data; do { data = getData(); } while (data != null && socket.send(data)); } // Each time the buffer is flushed // we try to send data again. socket.ondrain = pushData; // Start sending data. pushData(); Copy Getting data# Each time the socket gets some data from the host, it fires a data event. This event will give access to the data from the socket. The type of the data depends on the option set when the socket was opened (see above). socket.ondata = function (event) { if (typeof event.data === 'string') { console.log('Get a string: ' + event.data); } else { console.log('Get a Uint8Array'); } } Copy As the data event is fired as much as needed, it can sometimes be necessary to pause the flow of incoming data. To that end, calling the TCPSocket.suspend() method will pause reading incoming data and stop firing the data. It's possible to start reading data and firing events again by calling the TCPSocket.resume() method. Closing a socket# Closing a socket is simply done using TCPSocket.close().","keywords":""},{"title":"Manifest Change","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/manifest-change","content":"With KaiOS Next. We use PWA standard for the App's manifest. W3C webappmanifest. Next (PWA standard) If fields don't map in PWA standard, They will be put in b2g_feature. Common Fields We Used: Requires: name or shor_name: stringdescription: stringlang: stringtheme_color: stringorientation: stringstart_url: stringicons: Array of Object Optional: dir: stringscope: stringdisplay: stringbackground_color: stringrelated_applications: Array of Objectprefer_related_applications: Booleancategories: Array of Stringsscreenshots: Array of Stringsshortcuts: Array of Objects name / short_name You must provide at least name or short_name. If both are provided: name is used when the app is installed.short_name is used on the user's home screen, or other places where space may be limited. icons Every object have 3 fields: src image pathtype image type. ex: image/pngsizes image size. ex: 192x192 // MOZ: \"icons\": {​​ \"512\": \"/img/icon-512.png\", \"128\": \"/img/icon-128.png\" } // PWA: \"icons\": [ { \"src\": \"/images/icons-192.png\", \"type\": \"image/png\", \"sizes\": \"192x192\" } ] start_url is equal to MOZ field: launch_path background_color the same as MOZ This property is used on the splash screen when the application is first launch on mobile. display is equal to MOZ field: fullscreen You can customize what browser UI is shown when your app is launched. For example, you can hide the address bar and browser chrome. Game can even be made to launch full screen. value: fullscreenstandaloneminimal-uibrowser (default) theme_color the same as MOZ orientation the same as MOZ, but the value is a little bit different. anynaturallandscapelandscape-primarylandscape-secondaryportraitportrait-primaryportrait-secondary lang is equal to MOZ field default_locale","keywords":""},{"title":"TCPSocket","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/navigator/mozTCPSocket/tcpSocket","content":"Description# The TCPSocket interface provides access to a raw TCP socket. The main entry point for this API is the navigator.mozTCPSocket property which is a TCPSocket object. Note: Only certified apps can accept incoming connections on a port below 1024. API overview# interface TCPSocket{ readonly attribute DOMString host; readonly attribute unsigned short port; readonly attribute boolean ssl; readonly attribute unsigned long bufferedAmount; readonly attribute DOMString binaryType; readonly attribute DOMString readyState; TCPSocket open(DOMString host, unsigned short port, [object options]); TCPServerSocket listen(unsigned short port, [object options, [unsigned short backlog]]); void upgradeToSecure(); void suspend(); void resume(); void close(); boolean send(in jsval data); attribute onopen; attribute ondrain; attribute ondata; attribute onerror; attribute onclose; }; Copy Properties# TCPSocket.host Read only A string representing the host name of the server the socket is connected to. TCPSocket.port Read only A number representing the port the socket is connected to. TCPSocket.ssl Read only A boolean indicating whether the socket is encrypted with SSL (true) or not (false). TCPSocket.bufferedAmount Read only The number of bytes of not-yet-sent data in the socket buffered. TCPSocket.binaryType Read only The type of data used. Possible value is arraybuffer or string. TCPSocket.readyState Read only The socket state. Possible value is connecting, open, closing, or closed. Events handler# TCPSocket.onopen A handler for the open event. After this event, the socket is ready to send and receive data. TCPSocket.ondrain A handler for the drain event. This event is triggered each time the buffer of data is flushed. TCPSocket.onerror A handler for the error event. TCPSocket.ondata A handler for the data event. This event is triggered each time data has been received. TCPSocket.onclose A handler for the close event. Methods# TCPSocket.close() Closes the connection. TCPSocket.open(host, port [, options]) Returns a new TCPSocket object connected to the given host at the given port. TCPSocket.listen(port [, options [, backlog]]) Returns a new TCPServerSocket object listening at the given port. TCPSocket.resume() Resumes the data events. TCPSocket.send(data) Buffers data to be sent across the network. TCPSocket.suspend() Pauses the data events. TCPSocket.upgradeToSecure() Enables secure on channel.","keywords":""},{"title":"AudioContext","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/others/AudioContext/other-AudioContext","content":"Ref AudioContext# Description# The AudioContext interface represents an audio-processing graph built from audio modules linked together, each represented by an AudioNode. An audio context controls both the creation of the nodes it contains and the execution of the audio processing, or decoding. You need to create an AudioContext before you do anything else, as everything happens inside a context. It's recommended to create one AudioContext and reuse it instead of initializing a new one each time, and it's OK to use a single AudioContext for several different audio source and pipeline concurrently. Constructor# AudioContext() Creates and returns a new AudioContext object. Properties# Also inherits properties from its parent interface, BaseAudioContext. AudioContext.baseLatency Read only Returns the number of seconds of processing latency incurred by the AudioContext passing the audio from the AudioDestinationNode to the audio subsystem. AudioContext.outputLatency Read only Returns an estimation of the output latency of the current audio context. Methods# Also inherits methods from its parent interface, BaseAudioContext. AudioContext.close() Closes the audio context, releasing any system audio resources that it uses. AudioContext.createMediaElementSource() Creates a MediaElementAudioSourceNode associated with an HTMLMediaElement. This can be used to play and manipulate audio from <video> or <audio> elements. AudioContext.createMediaStreamSource() Creates a MediaStreamAudioSourceNode associated with a MediaStream representing an audio stream which may come from the local computer microphone or other sources. AudioContext.createMediaStreamDestination() Creates a MediaStreamAudioDestinationNode associated with a MediaStream representing an audio stream which may be stored in a local file or sent to another computer. AudioContext.createMediaStreamTrackSource() Creates a MediaStreamTrackAudioSourceNode associated with a MediaStream representing an media stream track. AudioContext.getOutputTimestamp() Returns a new AudioTimestamp object containing two audio timestamp values relating to the current audio context. AudioContext.resume() Resumes the progression of time in an audio context that has previously been suspended/paused. AudioContext.suspend() Suspends the progression of time in the audio context, temporarily halting audio hardware access and reducing CPU/battery usage in the process. Examples# Basic audio context declaration: var audioCtx = new AudioContext(); Copy Cross browser variant: var AudioContext = window.AudioContext || window.webkitAudioContext; var audioCtx = new AudioContext(); var oscillatorNode = audioCtx.createOscillator(); var gainNode = audioCtx.createGain(); var finish = audioCtx.destination; // etc. Copy","keywords":""},{"title":"TcpSocketManager service","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/daemon-api/tcpsocket/daemon-api-tcpsocket","content":"Instanciating the service# Load the following scripts: <script src=\"http://127.0.0.1:8081/api/v1/shared/core.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/shared/session.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/apps/service.js\"></script> Copy You can then get an instance of the service with code similar to: function getService() { return new Promise((resolve, reject) => { let session = new lib_session.Session(); let sessionstate = { onsessionconnected() { lib_tcpsocket.TcpSocketManager.get(session).then(resolve, reject); }, onsessiondisconnected() { reject(\"Session Disconnected\"); } }; // On desktop version, set ENV WS_RUNTIME_TOKEN=secrettoken when running the api-daemon. session.open(\"websocket\", \"localhost:8081\", \"secrettoken\", sessionstate); }); } let instance = getService().then(tcpsocket => { ... }); Copy This service implements the TcpSocketFactory interface. SocketAddress dictionnary# { host: string, port: integer, } TcpSocket Interface# Methods# close resume send suspend close() Resolves with void Rejects with void resume() Resolves with void Rejects with void send(/ , data / arraybuffer) Resolves with boolean Rejects with void suspend() Resolves with void Rejects with void Events# CLOSE DATA DRAIN ERROR The CLOSE event emits a void To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.CLOSE_EVENT, handleEvent); target.removeEventListener(target.CLOSE_EVENT, handleEvent); Copy The DATA event emits a arraybuffer To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.DATA_EVENT, handleEvent); target.removeEventListener(target.DATA_EVENT, handleEvent); Copy The DRAIN event emits a boolean To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.DRAIN_EVENT, handleEvent); target.removeEventListener(target.DRAIN_EVENT, handleEvent); Copy The ERROR event emits a string To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.ERROR_EVENT, handleEvent); target.removeEventListener(target.ERROR_EVENT, handleEvent); Copy TcpSocketFactory Interface# Methods# open open(/ , addr / SocketAddress) Resolves with TcpSocket Rejects with void","keywords":""},{"title":"navigator.b2g.fmRadio","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/fmRadio/navigator-b2g-fmRadio","content":"Description# The WebFM API provides access to the device FM radio. This interface lets you turn the FM radio on and off and tune it to different stations. It is accessible through the navigator.b2g.fmRadio property. API Overview# interface FMRadio : EventTarget { readonly attribute boolean enabled; readonly attribute boolean antennaAvailable; readonly attribute double frequency; readonly attribute double frequencyUpperBound; readonly attribute double frequencyLowerBound; readonly attribute double channelWidth; attribute Function onantennaavailablechange; attribute Function onfrequencychange; attribute Function onenabled; attribute Function ondisabled; DOMRequest enable(double frequency); DOMRequest disable(); DOMRequest setFrequency(double frequency); DOMRequest seekUp(); DOMRequest seekDown(); DOMRequest cancelSeek(); } Copy Properties# FMRadio.enabled Indicates whether the radio is playing. FMRadio.antennaAvailable Indicate if an antenna is plugged and available. FMRadio.frequency Current radio frequency.. FMRadio.frequencyUpperBound Maximum frequency up to which the seek method searches for radio stations. FMRadio.frequencyLowerBound Minimum frequency down to which the seek method searches for radio stations. FMRadio.channelWidth The channel width of the ranges of frequency, in MHz. Event handlers# FMRadio.onenabled Current radio frequency.. FMRadio.ondisabled A handler for the enabled event; It is triggered when the radio has been turned on. FMRadio.onantennaavailablechange A handler for the antennaavailablechange event; It is triggered when an antenna is plugged or unplugged. FMRadio.onfrequencychange A handler for the frequencychange event; It is triggered whenever the radio frequency is changed. Methods# FMRadio.enable() Turns on the radio on the given frequency. This function throws if called with no argument. Returns a DOMRequest for the success or error of the operation. FMRadio.disable() Turns the radio off. Returns a DOMRequest which success indicates that the radio has properly been disabled. FMRadio.setFrequency() Asynchronously changes the radio frequency. The value has to be between frequencyLowerBound and frequencyUpperBound. Trying to set outside the bounds results in an error. Returns a DOMRequest which success indicates the frequency has properly been changed. FMRadio.seekUp() Asks the radio to find a new frequency (usually greater than the current one). If one is successfully found, a frequencychange event is fired. Returns a DOMRequest which success indicates that the search has started. The search circles back to lower frequencies when the highest frequency has been reached. FMRadio.seekDown() Same as above, but searching in frequencies lower than the current one. The search cirlces back to higher frequencies when the lowest frequency has been reached. FMRadio.cancelSeek() Cancels the radio seek if one was happening. Returns a DOMRequest which success indicates that the frequency search has been cancelled.","keywords":""},{"title":"navigator.vibrate","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/navigator/vibrate/navigator-vibrate","content":"Description# The Navigator.vibrate() method pulses the vibration hardware on the device, if such hardware exists. If the device doesn't support vibration, this method has no effect. If a vibration pattern is already in progress when this method is called, the previous pattern is halted and the new one begins instead. If the method was unable to vibrate because of invalid parameters, it will return false, else it returns true. If the pattern leads to a too long vibration, it is truncated: the max length depends on the implementation. Syntax# var successBool = window.navigator.vibrate(pattern); Copy pattern Provides a pattern of vibration and pause intervals. Each value indicates a number of milliseconds to vibrate or pause, in alternation. You may provide either a single value (to vibrate once for that many milliseconds) or an array of values to alternately vibrate, pause, then vibrate again. See Vibration API for details. Passing a value of 0, an empty array, or an array containing all zeros will cancel any currently ongoing vibration pattern. Examples# window.navigator.vibrate(200); // vibrate for 200ms window.navigator.vibrate([100,30,100,30,100,30,200,30,200,30,200,30,100,30,100,30,100]); // Vibrate 'SOS' in Morse. Copy","keywords":""},{"title":"Audio Channels API","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/AudioChannels/permission-table-audiochannel","content":"Description# The Audio Channels API allowing you to place your app audio content into a hierarchy of importance, which dictates when the audio will be paused and resumed in response to other audio playing and actions occurring and allows you to control the volume of different types of audio independently from one another. Use case examples: You want your audio player app to continue playing audio even when it is running in the background so you can do other things as it plays, but you want it to pause when someone rings your phone. When you mute your phone you don't want to also mute your wake up alarm for the next morning. Concepts and usage# The AudioChannels API extends the HTMLMediaElement and AudioContext interfaces with (among other things) a mozAudioChannelType property that can be set to the channel you want your audio to be played in. The <audio> and <video> elements can also be used to set this value via the mozaudiochannel attribute. When your audio is placed into a channel, it is generally paused (or interrupted) by audio in a higher priority channel being played. Audio in the least important channel — normal — is also paused by its app being put into the background (this is not the case with the other channels). The audio channels are as follows: Channel name\timportance\tUsed for\tApp permission levelnormal\t1\tUI sounds, app and web content\tPWA content\t2\tMusic, radio, video\tPWA notification\t3\tNew email, incoming SMS\tSigned alarm\t4\tAlarm clock, calendar alarms\tSigned ringer\t5\tIncoming phone calls\tCore telephony\t6\tOngoing phone calls, VOIP calls\tCore publicnotification\t7\tForced camera shutter sounds\tCore Each channel has a separate mute and volume setting, to provide more granular control over the different parts of audio on your device. These are accessed using the audioChannelManager object via the navigator.b2g.audioChannelManager property. Note: If you have two apps playing audio in the content channel, only the one in the foreground can play audio, while the other is interrupted. When the foreground app is put into the background with audio playing, it will not be muted, as per normal \"content\" behaviour. AudioChannels interfaces# AudioChannelManager Includes some features for managing your device's audio channels, including setting what channel's volume to affect when the volume buttons are pressed inside a particular app. HTMLMediaElement and AudioContext extentions HTMLMediaElement and AudioContext are extended with some proprietary features for controlling audio channels, including setting what audio channel the media is in, and events that fire when the audio is interrupted, and resumes playing.","keywords":""},{"title":"navigator.mozTCPSocket","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/navigator/mozTCPSocket/navigator-mozTCPSocket","content":"Description# Returns a TCPSocket object you can use to open other sockets. Syntax# var socket = navigator.mozTCPSocket; Copy Value# navigator.mozTCPSocket is a TCPSocket object. See also# TCPSocketTCP Socket API","keywords":""},{"title":"BluetoothAttributeEvent","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothattributeevent/BluetoothAttributeEvent","content":"Description# The BluetoothAttributeEvent interface of the Bluetooth API provides access to changed attributes and their new values as the parameter of attributechanged event handlers (including BluetoothManager.onattributechanged, BluetoothAdapter.onattributechanged, and BluetoothDevice.onattributechanged), when fired. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothAttributeEvent : Event { [Cached, Constant] readonly attribute sequence<DOMString> attrs; }; Copy Properties# BluetoothAttributeEvent.attrs {.read-only .no-link} Returns an array of changed attribute values, which may be BluetoothManagerAttributes, BluetoothAdapterAttributes, or BluetoothDeviceAttributes. BluetoothManagerAttributes \"unknown\" or \"defaultAdapter\" BluetoothAdapterAttributes \"unknown\", \"state\", \"address\", \"name\", \"discoverable\" or \"discovering\" BluetoothDeviceAttributes \"unknown\", \"cod\", \"name\", \"paired\" or \"uuids\" Example#","keywords":""},{"title":"XMLHttpRequest","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/others/XMLHttpRequest/other-XMLHttpRequest","content":"Ref MDN XMLHttpRequest# Description# XMLHttpRequest (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing. XMLHttpRequest is used heavily in AJAX programming. Despite its name, XMLHttpRequest can be used to retrieve any type of data, not just XML. If your communication needs to involve receiving event data or message data from a server, consider using server-sent events through the EventSource interface. For full-duplex communication, WebSockets may be a better choice. Constructor# XMLHttpRequest The constructor initializes an XMLHttpRequest. It must be called before any other method calls. Properties# This interface also inherits properties of XMLHttpRequestEventTarget and of EventTarget. XMLHttpRequest.onreadystatechange An EventHandler that is called whenever the readyState attribute changes. XMLHttpRequest.readyState Returns an unsigned short, the state of the request. XMLHttpRequest.response Returns an ArrayBuffer, Blob, Document, JavaScript object, or a DOMString, depending on the value of XMLHttpRequest.responseType, that contains the response entity body. XMLHttpRequest.responseText Read only Returns a DOMString that contains the response to the request as text, or null if the request was unsuccessful or has not yet been sent. XMLHttpRequest.responseType Is an enumerated value that defines the response type. XMLHttpRequest.responseURL Read only Returns the serialized URL of the response or the empty string if the URL is null. XMLHttpRequest.responseXML Read only Returns a Document containing the response to the request, or null if the request was unsuccessful, has not yet been sent, or cannot be parsed as XML or HTML. Not available in workers. XMLHttpRequest.status Read only Returns an unsigned short with the status of the response of the request. XMLHttpRequest.statusText Read only Returns a DOMString containing the response string returned by the HTTP server. Unlike XMLHttpRequest.status, this includes the entire text of the response message (\"200 OK\", for example). XMLHttpRequest.timeout Is an unsigned long representing the number of milliseconds a request can take before automatically being terminated. XMLHttpRequestEventTarget.ontimeout Is an EventHandler that is called whenever the request times out. XMLHttpRequest.upload Read only Is an XMLHttpRequestUpload, representing the upload process. XMLHttpRequest.withCredentials Is a Boolean that indicates whether or not cross-site Access-Control requests should be made using credentials such as cookies or authorization headers. Non-standard properties# XMLHttpRequest.channel Read only Is a nsIChannel. The channel used by the object when performing the request. XMLHttpRequest.mozAnon Read only Is a boolean. If true, the request will be sent without cookie and authentication headers. XMLHttpRequest.mozSystem Read only Is a boolean. If true, the same origin policy will not be enforced on the request. XMLHttpRequest.mozBackgroundRequest Is a boolean. It indicates whether or not the object represents a background service request. Event handlers# onreadystatechange as a property of the XMLHttpRequest instance is supported in all browsers. Since then, a number of additional event handlers have been implemented in various browsers (onload, onerror, onprogress, etc.). See Using XMLHttpRequest. More recent browsers, including Firefox, also support listening to the XMLHttpRequest events via standard addEventListener() APIs in addition to setting on* properties to a handler function. Methods# XMLHttpRequest.abort() Aborts the request if it has already been sent. XMLHttpRequest.getAllResponseHeaders() Returns all the response headers, separated by CRLF, as a string, or null if no response has been received. XMLHttpRequest.getResponseHeader() Returns the string containing the text of the specified header, or null if either the response has not yet been received or the header doesn't exist in the response. XMLHttpRequest.open() Initializes a request. XMLHttpRequest.overrideMimeType() Overrides the MIME type returned by the server. XMLHttpRequest.send() Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent. XMLHttpRequest.setRequestHeader() Sets the value of an HTTP request header. You must call setRequestHeader()after open(), but before send(). Non-standard methods# XMLHttpRequest.init() Initializes the object for use from C++ code.Warning: This method must not be called from JavaScript. XMLHttpRequest.openRequest() Initializes a request. This method is to be used from native code; to initialize a request from JavaScript code, use open() instead. See the documentation for open(). XMLHttpRequest.sendAsBinary() A variant of the send() method that sends binary data. Events# abort Fired when a request has been aborted, for example because the program called XMLHttpRequest.abort(). Also available via the onabort property. error Fired when the request encountered an error. Also available via the onerror property. load Fired when an XMLHttpRequest transaction completes successfully. Also available via the onload property. loadend Fired when a request has completed, whether successfully (after load) or unsuccessfully (after abort or error). Also available via the onloadend property. loadstart Fired when a request has started to load data. Also available via the onloadstart property. progress Fired periodically when a request receives more data. Also available via the onprogress property. timeout Fired when progress is terminated due to preset time expiring. Also available via the ontimeout property.","keywords":""},{"title":"BluetoothAdapterEvent","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothadapterevent/BluetoothAdapterEvent","content":"Description# The BluetoothAdapterEvent interface of the Bluetooth API provides access to a BluetoothAdapter object and its address as the parameter of a adapteradded or adapterremoved event handler (see BluetoothManager.onadapteradded and BluetoothManager.onadapterremoved), when fired. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothAdapterEvent : Event { readonly attribute BluetoothAdapter? adapter; readonly attribute DOMString? address; }; Copy Properties# BluetoothAdapterEvent.adapter {.read-only .no-link} Returns the BluetoothAdapter object. This is null for the BluetoothManager.onadapterremoved event handler since the corresponding adapter is already removed. BluetoothAdapterEvent.address {.read-only .no-link} Returns a DOMString representing the address of the removed adapter. The property is null for the BluetoothManager.onadapteradded event handler since the adapter already has an BluetoothAdapter.address property.","keywords":""},{"title":"MozSpeakerManager","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/others/speakerManager/other-SpeakerManager","content":"Description# General Use Cases: Allow application can control acoustic sound output through speaker. Interfaces# SpeakerPolicy# /* * SpeakerPolicy is used to configure the force speaker policy of a SpeakerManager. * - \"foreground-or-playing\" (default value): * SpeakerManagerService will try to respect our \"forcespeaker\" setting when our * SpeakerManager is in the foreground, or our APP is playing. Note that foreground * state has a higher priority than playing state. If we are in the foreground and * not playing, but some other background APP is playing, then SpeakerManagerService * will respect our \"forcespeaker\" setting. * - \"playing\": * SpeakerManagerService will try to respect our \"forcespeaker\" setting only when * our APP is playing. * - \"query\": * Configure SpeakerManager as query mode. In this mode, SpeakerManager can only be * used to query \"speakerforced\" status, but our \"forcespeaker\" setting is never * applied. The event \"onspeakerforcedchange\" is still effective. */ enum SpeakerPolicy { \"foreground-or-playing\", \"playing\", \"query\" }; Copy SpeakerManager# interface MozSpeakerManager : EventTarget { [Throws] constructor(optional SpeakerPolicy policy); /* query the speaker status */ readonly attribute boolean speakerforced; /* force device device's acoustic sound output through speaker */ attribute boolean forcespeaker; /* this event will be fired when device's speaker forced status change */ attribute EventHandler onspeakerforcedchange; }; Copy Examples# var sm = new navigator.SpeakerManager(); // fired anytime when device's speaker status changed sm.onspeakerforcedchange = function() { bool enabled = sm.speakerforced; // Refresh UI return; } if (sm.speakerforced) { // device's speaker is on } else { sm.forcespeaker = true; } Copy","keywords":""},{"title":"PowermanagerService service","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/daemon-api/powermanager/daemon-api-powermanager","content":"Instanciating the service# Load the following scripts: <script src=\"http://127.0.0.1:8081/api/v1/shared/core.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/shared/session.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/apps/service.js\"></script> Copy You can then get an instance of the service with code similar to: function getService() { return new Promise((resolve, reject) => { let session = new lib_session.Session(); let sessionstate = { onsessionconnected() { lib_powermanager.PowermanagerService.get(session).then(resolve, reject); }, onsessiondisconnected() { reject(\"Session Disconnected\"); } }; // On desktop version, set ENV WS_RUNTIME_TOKEN=secrettoken when running the api-daemon. session.open(\"websocket\", \"localhost:8081\", \"secrettoken\", sessionstate); }); } let instance = getService().then(powermanager => { ... }); Copy This service implements the Powermanager interface. FactoryResetReason enumeration# { NORMAL, WIPE, ROOT, } Powermanager Interface# Members# cpuSleepAllowed extScreenBrightness extScreenEnabled factoryReset keyLightBrightness keyLightEnabled screenBrightness screenEnabled cpuSleepAllowed is of type boolean To get value, use code similar to: target.cpuSleepAllowed().then(value => { ... }); Copy To set value, use code similar to: target.cpuSleepAllowed = value; Copy extScreenBrightness is of type integer To get value, use code similar to: target.extScreenBrightness().then(value => { ... }); Copy To set value, use code similar to: target.extScreenBrightness = value; Copy extScreenEnabled is of type boolean To get value, use code similar to: target.extScreenEnabled().then(value => { ... }); Copy To set value, use code similar to: target.extScreenEnabled = value; Copy factoryReset is of type FactoryResetReason To get value, use code similar to: target.factoryReset().then(value => { ... }); Copy To set value, use code similar to: target.factoryReset = value; Copy keyLightBrightness is of type integer To get value, use code similar to: target.keyLightBrightness().then(value => { ... }); Copy To set value, use code similar to: target.keyLightBrightness = value; Copy keyLightEnabled is of type boolean To get value, use code similar to: target.keyLightEnabled().then(value => { ... }); Copy To set value, use code similar to: target.keyLightEnabled = value; Copy screenBrightness is of type integer To get value, use code similar to: target.screenBrightness().then(value => { ... }); Copy To set value, use code similar to: target.screenBrightness = value; Copy screenEnabled is of type boolean To get value, use code similar to: target.screenEnabled().then(value => { ... }); Copy To set value, use code similar to: target.screenEnabled = value; Copy Methods# powerOff reboot powerOff() Resolves with void Rejects with void reboot() Resolves with void Rejects with void","keywords":""},{"title":"TimeService service","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/daemon-api/timeservice/daemon-api-timeservices","content":"Instanciating the service# Load the following scripts: <script src=\"http://127.0.0.1:8081/api/v1/shared/core.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/shared/session.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/apps/service.js\"></script> Copy You can then get an instance of the service with code similar to: function getService() { return new Promise((resolve, reject) => { let session = new lib_session.Session(); let sessionstate = { onsessionconnected() { lib_time.TimeService.get(session).then(resolve, reject); }, onsessiondisconnected() { reject(\"Session Disconnected\"); } }; // On desktop version, set ENV WS_RUNTIME_TOKEN=secrettoken when running the api-daemon. session.open(\"websocket\", \"localhost:8081\", \"secrettoken\", sessionstate); }); } let instance = getService().then(time => { ... }); Copy This service implements the Time interface. CallbackReason enumeration# { NONE, TIME_CHANGED, TIMEZONE_CHANGED, } TimeObserver callback object# Creating a TimeObserver object# Use code similar to: class MyCallbackObject extends lib_time.TimeObserverBase { constructor(service, session) { super(service.id, session); } callback(...) { ... } Copy Methods# callback callback(/ , reason / CallbackReason) Resolves with void Rejects with void Time Interface# Methods# addObserver get getElapsedRealTime removeObserver set setTimezone addObserver(/ , reason / CallbackReason/ , observer / TimeObserver) Resolves with void Rejects with void get() Resolves with Date Rejects with void getElapsedRealTime() Resolves with integer Rejects with void removeObserver(/ , reason / CallbackReason/ , observer / TimeObserver) Resolves with void Rejects with void set(/ , time / Date) Resolves with void Rejects with void setTimezone(/ , timezone / string) Resolves with void Rejects with void Events# TIME_CHANGED TIMEZONE_CHANGED The TIME_CHANGED event emits a void To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.TIME_CHANGED_EVENT, handleEvent); target.removeEventListener(target.TIME_CHANGED_EVENT, handleEvent); Copy The TIMEZONE_CHANGED event emits a void To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.TIMEZONE_CHANGED_EVENT, handleEvent); target.removeEventListener(target.TIMEZONE_CHANGED_EVENT, handleEvent); Copy","keywords":""},{"title":"BluetoothDiscoveryHandle","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothdiscoveryhandle/BluetoothDiscoveryHandle","content":"Description# The BluetoothDiscoveryHandle interface of the Bluetooth API is used to notify the current application about the discovery of a remote bluetooth device. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothDiscoveryHandle : EventTarget { attribute EventHandler ondevicefound; }; Copy Properties# BluetoothDiscoveryHandle.ondevicefound Defines an event handler to trigger each time the devicefound event is fired; this occurs when a remote bluetooth device is discovered. Its parameter is either a BluetoothDeviceEvent or BluetoothLeDeviceEvent, depending on the type of device discovered.","keywords":""},{"title":"BluetoothConnectionHandle","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothconnectionhandle/BluetoothConnectionHandle","content":"Description# Properties# Methods# accept()Accept the bluetooth profile connection request. reject()Reject the bluetooth profile connection request. Example#","keywords":""},{"title":"AppsManager service","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/daemon-api/appmanager/daemon-api-appsmanager","content":"Instanciating the service# Load the following scripts: <script src=\"http://127.0.0.1:8081/api/v1/shared/core.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/shared/session.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/apps/service.js\"></script> Copy You can then get an instance of the service with code similar to: function getService() { return new Promise((resolve, reject) => { let session = new lib_session.Session(); let sessionstate = { onsessionconnected() { lib_apps.AppsManager.get(session).then(resolve, reject); }, onsessiondisconnected() { reject(\"Session Disconnected\"); } }; // On desktop version, set ENV WS_RUNTIME_TOKEN=secrettoken when running the api-daemon. session.open(\"websocket\", \"localhost:8081\", \"secrettoken\", sessionstate); }); } let instance = getService().then(apps => { ... }); Copy This service implements the AppsEngine interface. AppsInstallState enumeration# { INSTALLED, INSTALLING, PENDING, } AppsServiceError enumeration# { APP_NOT_FOUND, CLEAR_DATA_ERROR, DISK_SPACE_NOT_ENOUGH, DOWNLOAD_MANIFEST_FAILED, DOWNLOAD_PACKAGE_FAILED, DUPLICATED_ACTION, INVALID_APP_NAME, INVALID_START_URL, INVALID_STATE, INVALID_MANIFEST, INVALID_PACKAGE, INVALID_SIGNATURE, NETWORK_FAILURE, FILESYSTEM_FAILURE, PACKAGE_CORRUPT, REGISTRATION_ERROR, REINSTALL_FORBIDDEN, UPDATE_ERROR, UNKNOWN_ERROR, } AppsServiceState enumeration# { INITIALIZING, RUNNING, TERMINATING, } AppsStatus enumeration# { ENABLED, DISABLED, } AppsUpdateState enumeration# { IDLE, AVAILABLE, DOWNLOADING, UPDATING, PENDING, } ClearType enumeration# { BROWSER, STORAGE, } ConnectionType enumeration# { WI_FI_ONLY, ANY, } AppsObject dictionnary# { name: string, installState: AppsInstallState, manifestUrl: string, status: AppsStatus, updateState: AppsUpdateState, updateUrl: string, allowedAutoDownload: boolean, } AppsOptions dictionnary# { autoInstall: boolean?, } AppsEngine Interface# Methods# checkForUpdate clear getAll getApp getState installPackage installPwa setEnabled setUpdatePolicy uninstall update checkForUpdate(/ , updateUrl / string/ , appsOption / AppsOptions) Resolves with boolean Rejects with AppsServiceError clear(/ , manifestUrl / string/ , dataType / ClearType) Resolves with boolean Rejects with AppsServiceError getAll() Resolves with [AppsObject]? Rejects with AppsServiceError getApp(/ , manifestUrl / string) Resolves with AppsObject Rejects with AppsServiceError getState() Resolves with AppsServiceState Rejects with void installPackage(/ , updateUrl / string) Resolves with AppsObject Rejects with AppsServiceError installPwa(/ , manifestUrl / string) Resolves with AppsObject Rejects with AppsServiceError setEnabled(/ , manifestUrl / string/ , status / AppsStatus) Resolves with AppsObject Rejects with AppsServiceError setUpdatePolicy(/ , enabled / boolean/ , allowedType / ConnectionType/ , delay / integer) Resolves with boolean Rejects with void uninstall(/ , manifestUrl / string) Resolves with string Rejects with AppsServiceError update(/ , manifestUrl / string) Resolves with AppsObject Rejects with AppsServiceError Events# APP_DOWNLOAD_FAILED APP_INSTALLED APP_INSTALLING APP_UNINSTALLED APP_UPDATE_AVAILABLE APP_UPDATED APPSTATUS_CHANGED The APP_DOWNLOAD_FAILED event emits a AppsObject To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.APP_DOWNLOAD_FAILED_EVENT, handleEvent); target.removeEventListener(target.APP_DOWNLOAD_FAILED_EVENT, handleEvent); Copy The APP_INSTALLED event emits a AppsObject To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.APP_INSTALLED_EVENT, handleEvent); target.removeEventListener(target.APP_INSTALLED_EVENT, handleEvent); Copy The APP_INSTALLING event emits a AppsObject To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.APP_INSTALLING_EVENT, handleEvent); target.removeEventListener(target.APP_INSTALLING_EVENT, handleEvent); Copy The APP_UNINSTALLED event emits a string To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.APP_UNINSTALLED_EVENT, handleEvent); target.removeEventListener(target.APP_UNINSTALLED_EVENT, handleEvent); Copy The APP_UPDATE_AVAILABLE event emits a AppsObject To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.APP_UPDATE_AVAILABLE_EVENT, handleEvent); target.removeEventListener(target.APP_UPDATE_AVAILABLE_EVENT, handleEvent); Copy The APP_UPDATED event emits a AppsObject To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.APP_UPDATED_EVENT, handleEvent); target.removeEventListener(target.APP_UPDATED_EVENT, handleEvent); Copy The APPSTATUS_CHANGED event emits a AppsObject To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.APPSTATUS_CHANGED_EVENT, handleEvent); target.removeEventListener(target.APPSTATUS_CHANGED_EVENT, handleEvent); Copy","keywords":""},{"title":"ServiceWorker","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/others/ServiceWorker/other-ServiceWorker","content":"RefService Worker# Description# The ServiceWorker interface of the Service Worker API provides a reference to a service worker. Multiple browsing contexts (e.g. pages, workers, etc.) can be associated with the same service worker, each through a unique ServiceWorker object. A ServiceWorker object is available in the ServiceWorkerRegistration.active property, and the ServiceWorkerContainer.controller property — this is a service worker that has been activated and is controlling the page (the service worker has been successfully registered, and the controlled page has been reloaded.) The ServiceWorker interface is dispatched a set of lifecycle events — install and activate — and functional events including fetch. A ServiceWorker object has an associated ServiceWorker.state, related to its lifecycle. Properties# The ServiceWorker interface inherits properties from its parent, Worker. ServiceWorker.scriptURL Returns the ServiceWorker serialized script URL defined as part of ServiceWorkerRegistration. The URL must be on the same origin as the document that registers the ServiceWorker. ServiceWorker.state Returns the state of the service worker. It returns one of the following values: installing, installed, activating, activated, or redundant. Event handlers# ServiceWorker.onstatechange An EventListener property called whenever an event of type statechange is fired; it is basically fired anytime the ServiceWorker.state changes. Methods# The ServiceWorker interface inherits methods from its parent, Worker, with the exception of Worker.terminate — this should not be accessible from service workers. Examples# This code snippet is from the service worker registration-events sample (live demo). The code listens for any change in the ServiceWorker.state and returns its value. if ('serviceWorker' in navigator) { navigator.serviceWorker.register('service-worker.js', { scope: './' }).then(function (registration) { var serviceWorker; if (registration.installing) { serviceWorker = registration.installing; document.querySelector('#kind').textContent = 'installing'; } else if (registration.waiting) { serviceWorker = registration.waiting; document.querySelector('#kind').textContent = 'waiting'; } else if (registration.active) { serviceWorker = registration.active; document.querySelector('#kind').textContent = 'active'; } if (serviceWorker) { // logState(serviceWorker.state); serviceWorker.addEventListener('statechange', function (e) { // logState(e.target.state); }); } }).catch (function (error) { // Something went wrong during registration. The service-worker.js file // might be unavailable or contain a syntax error. }); } else { // The current browser doesn't support service workers. } Copy Related Topic# ServiceWorker API","keywords":""},{"title":"ContactsManager service","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/daemon-api/contacts/daemon-api-contacts","content":"Instanciating the service# Load the following scripts: <script src=\"http://127.0.0.1:8081/api/v1/shared/core.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/shared/session.js\"></script> <script src=\"http://127.0.0.1:8081/api/v1/apps/service.js\"></script> Copy You can then get an instance of the service with code similar to: function getService() { return new Promise((resolve, reject) => { let session = new lib_session.Session(); let sessionstate = { onsessionconnected() { lib_contacts.ContactsManager.get(session).then(resolve, reject); }, onsessiondisconnected() { reject(\"Session Disconnected\"); } }; // On desktop version, set ENV WS_RUNTIME_TOKEN=secrettoken when running the api-daemon. session.open(\"websocket\", \"localhost:8081\", \"secrettoken\", sessionstate); }); } let instance = getService().then(contacts => { ... }); Copy This service implements the ContactsFactory interface. ChangeReason enumeration# { CREATE, UPDATE, REMOVE, } FilterByOption enumeration# { NAME, GIVEN_NAME, FAMILY_NAME, TEL, EMAIL, CATEGORY, } FilterOption enumeration# { EQUALS, CONTAINS, MATCH, STARTS_WITH, FUZZY_MATCH, } Order enumeration# { ASCENDING, DESCENDING, } SortOption enumeration# { GIVEN_NAME, FAMILY_NAME, NAME, } Address dictionnary# { atype: string, streetAddress: string?, locality: string?, region: string?, postalCode: string?, countryName: string?, pref: boolean?, } BlockedNumberChangeEvent dictionnary# { reason: ChangeReason, number: string, } BlockedNumberFindOptions dictionnary# { filterValue: string, filterOption: FilterOption, } ContactField dictionnary# { atype: string, value: string, pref: boolean, } ContactFindSortOptions dictionnary# { sortBy: SortOption, sortOrder: Order, sortLanguage: string, filterValue: string, filterOption: FilterOption, filterBy: FilterByOption, onlyMainData: boolean, } ContactInfo dictionnary# { id: string, published: Date, updated: Date, bday: Date, anniversary: Date, sex: string, genderIdentity: string, ringtone: string, photoType: string, photoBlob: arraybuffer, addresses: [Address]?, email: [ContactField]?, url: [ContactField]?, name: string, tel: [ContactTelField]?, honorificPrefix: [string]?, givenName: string, phoneticGivenName: string, additionalName: [string]?, familyName: string, phoneticFamilyName: string, honorificSuffix: [string]?, nickname: [string]?, category: [string]?, org: [string]?, jobTitle: [string]?, note: [string]?, groups: [string]?, icePosition: integer, } ContactSortOptions dictionnary# { sortBy: SortOption, sortOrder: Order, sortLanguage: string, } ContactTelField dictionnary# { atype: string, value: string, pref: boolean, carrier: string, } ContactsChangeEvent dictionnary# { reason: ChangeReason, contacts: [ContactInfo]?, } GroupChangeEvent dictionnary# { reason: ChangeReason, group: GroupInfo, } GroupInfo dictionnary# { id: string, name: string, } IceInfo dictionnary# { position: integer, contactId: string, } SimContactInfo dictionnary# { id: string, tel: string, email: string, name: string, } SimContactLoadedEvent dictionnary# { removeCount: integer, updateCount: integer, } SpeedDialChangeEvent dictionnary# { reason: ChangeReason, speeddial: SpeedDialInfo, } SpeedDialInfo dictionnary# { dialKey: string, tel: string, contactId: string, } ContactCursor Interface# Methods# next next() Resolves with [ContactInfo] Rejects with void ContactsFactory Interface# Methods# add addBlockedNumber addGroup addSpeedDial clearContacts find findBlockedNumbers get getAll getAllBlockedNumbers getAllGroups getAllIce getContactidsFromGroup getCount getSpeedDials hasNumber importVcf remove removeBlockedNumber removeGroup removeIce removeSpeedDial setIce update updateGroup updateSpeedDial add(/ , contacts / [ContactInfo]) Resolves with void Rejects with void addBlockedNumber(/ , number / string) Resolves with void Rejects with void addGroup(/ , name / string) Resolves with void Rejects with void addSpeedDial(/ , dialKey / string/ , tel / string/ , contactId / string) Resolves with void Rejects with void clearContacts() Resolves with void Rejects with void find(/ , params / ContactFindSortOptions/ , batchSize / integer) Resolves with ContactCursor Rejects with void findBlockedNumbers(/ , options / BlockedNumberFindOptions) Resolves with [string]? Rejects with void get(/ , id / string/ , onlyMainData / boolean) Resolves with ContactInfo Rejects with void getAll(/ , options / ContactSortOptions/ , batchSize / integer/ , onlyMainData / boolean) Resolves with ContactCursor Rejects with void getAllBlockedNumbers() Resolves with [string]? Rejects with void getAllGroups() Resolves with [GroupInfo]? Rejects with void getAllIce() Resolves with [IceInfo]? Rejects with void getContactidsFromGroup(/ , groupId / string) Resolves with [string]? Rejects with void getCount() Resolves with integer Rejects with void getSpeedDials() Resolves with [SpeedDialInfo]? Rejects with void hasNumber(/ , number / string) Resolves with boolean Rejects with void importVcf(/ , vcf / string) Resolves with integer Rejects with void remove(/ , contactIds / [string]) Resolves with void Rejects with void removeBlockedNumber(/ , number / string) Resolves with void Rejects with void removeGroup(/ , id / string) Resolves with void Rejects with void removeIce(/ , contactId / string) Resolves with void Rejects with void removeSpeedDial(/ , dialKey / string) Resolves with void Rejects with void setIce(/ , contactId / string/ , position / integer) Resolves with void Rejects with void update(/ , contacts / [ContactInfo]) Resolves with void Rejects with void updateGroup(/ , id / string/ , name / string) Resolves with void Rejects with void updateSpeedDial(/ , dialKey / string/ , tel / string/ , contactId / string) Resolves with void Rejects with void Events# BLOCKEDNUMBER_CHANGE CONTACTS_CHANGE GROUP_CHANGE SIM_CONTACT_LOADED SPEEDDIAL_CHANGE The BLOCKEDNUMBER_CHANGE event emits a BlockedNumberChangeEvent To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.BLOCKEDNUMBER_CHANGE_EVENT, handleEvent); target.removeEventListener(target.BLOCKEDNUMBER_CHANGE_EVENT, handleEvent); Copy The CONTACTS_CHANGE event emits a ContactsChangeEvent To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.CONTACTS_CHANGE_EVENT, handleEvent); target.removeEventListener(target.CONTACTS_CHANGE_EVENT, handleEvent); Copy The GROUP_CHANGE event emits a GroupChangeEvent To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.GROUP_CHANGE_EVENT, handleEvent); target.removeEventListener(target.GROUP_CHANGE_EVENT, handleEvent); Copy The SIM_CONTACT_LOADED event emits a SimContactLoadedEvent To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.SIM_CONTACT_LOADED_EVENT, handleEvent); target.removeEventListener(target.SIM_CONTACT_LOADED_EVENT, handleEvent); Copy The SPEEDDIAL_CHANGE event emits a SpeedDialChangeEvent To manage this event, use code similar to: function handleEvent(value) { ... } target.addEventListener(target.SPEEDDIAL_CHANGE_EVENT, handleEvent); target.removeEventListener(target.SPEEDDIAL_CHANGE_EVENT, handleEvent); Copy","keywords":""},{"title":"BluetoothAdapter","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothadapter/BluetoothAdapter","content":"Description# The BluetoothAdapter interface of the Web Bluetooth API is used to handle all the operations requested by Bluetooth networks. A Bluetooth adapter is the physical interface which is used to interact with local Bluetooth device. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothAdapter: EventTarget { readonly attribute BluetoothAdapterState state; readonly attribute DOMString name; readonly attribute boolean discoverable; readonly attribute boolean discovering; attribute EventHandler onattributechanged; attribute EventHandler ondevicepaired; attribute EventHandler ondeviceunpaired; attribute EventHandler onpairingaborted; attribute EventHandler ona2dpstatuschanged; attribute EventHandler onhfpstatuschanged; attribute EventHandler onscostatuschanged; attribute EventHandler onrequestmediaplaystatus; [NewObject] Promise<void> setDiscoverable(boolean aDiscoverable); [NewObject] Promise<BluetoothDiscoveryHandle> startDiscovery(); [NewObject] Promise<void> stopDiscovery(); [NewObject] Promise<void> pair(DOMString aAddress); [NewObject] Promise<void> unpair(DOMString aAddress); sequence<BluetoothDevice> getPairedDevices(); // BLE methods [NewObject] Promise<BluetoothDiscoveryHandle> startLeScan(sequence<DOMString> aServiceUuids); [NewObject] Promise<void> stopLeScan(BluetoothDiscoveryHandle aDiscoveryHandle); }; Copy Properties# BluetoothAdapter.discoverable {.read-only} A boolean indicating if the device is discoverable (true) or not (false) by other Bluetooth devices. BluetoothAdapter.discovering {.read-only} A boolean indicating if the device's adapter is in the process of discovering (true) or not (false) surrounding Bluetooth devices. BluetoothAdapter.name {.read-only} A string indicating the human readable name of the device's adapter. BluetoothAdapter.state {.read-only .no-link} Returns the state of the local bluetooth adapter. Event Handlers# BluetoothAdapter.onattributechangedA handler for the attributechanged event; it is triggered when one of the local bluetooth adapter's properties has changed BluetoothAdapter.ondevicepairedA handler for the devicepaired event; it is triggered when a remote device gets paired with the local bluetooth adapter. BluetoothAdapter.ondeviceunpairedA handler for the deviceunpaired event; it is triggered when a remote device gets unpaired from the local bluetooth adapter. BluetoothAdapter.onpairingabortedA handler for the pairingaborted event; it is triggered when pairing fails due to authentication failure, the remote device being down (bluetooth ACL becomes disconnected), or some kind of internal error. BluetoothAdapter.ona2dpstatuschangedA handler for the a2dpstatuschanged event; it is triggered when an A2DP connection status changes. BluetoothAdapter.onhfpstatuschangedA handler for the hfpstatuschanged event; it is triggered when an HFP connection status changes. BluetoothAdapter.onrequestmediaplaystatusA handler for the requestmediaplaystatus event; it is triggered when a remote Bluetooth device queries the current media play status. BluetoothAdapter.onscostatuschangedA handler for the scostatuschanged event; it is triggered when a SCO connection status changes. Note: Because the BluetoothAdapter interface inherits from the EventTarget interface, all these events can be listened by using the addEventListener method. Methods# BluetoothAdapter.getPairedDevices()Allows retrieving a full list of all devices paired with the device's adapter. BluetoothAdapter.pair()Allows to start pairing a remote device with the device's adapter. BluetoothAdapter.setDiscoverable()Allows to change the value of the discoverable property. BluetoothAdapter.startDiscovery()Allows the device's adapter to start seeking for remote devices. BluetoothAdapter.startLeScan()Instructs the device's adapter to start seeking for remote LE devices advertising given services. BluetoothAdapter.stopDiscovery()Allows the device's adapter to stop seeking for remote devices. BluetoothAdapter.stopLeScan()Instructs the device's adapter to stop scanning for remote LE devices. BluetoothAdapter.unpair()Allows to unpair a remote device from the device's adapter.","keywords":""},{"title":"BluetoothGatt","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothgatt/BluetoothGatt","content":"Description# The BluetoothGatt interface of the Bluetooth API handles initial communications and connections with Gatt services. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothGatt : EventTarget { [Cached, Pure] readonly attribute sequence<BluetoothGattService> services; readonly attribute BluetoothConnectionState connectionState; attribute EventHandler oncharacteristicchanged; attribute EventHandler onconnectionstatechanged; [NewObject] Promise<void> connect(); [NewObject] Promise<void> disconnect(); [NewObject] Promise<void> discoverServices(); [NewObject] Promise<short> readRemoteRssi(); }; Copy Properties# BluetoothGatt.services Returns the list of GATT services offered by the remote LE device. This property is set to an empty array by default before a connection is established. BluetoothGatt.connectionState The current connection state of GATT client to the remote LE device. This property is set to disconnected by default, before a connection is established. Event handlers# BluetoothGatt.oncharacteristicchanged Defines a handler to trigger as a result of the characteristicchanged event firing; this occurs when a remote characteristic changes. BluetoothGatt.onconnectionstatechanged Defines a handler to trigger as a result of the connectionstatechanged event firing; this occurs when the connection state of the GATT client to the remote LE device (i.e. the BluetoothGatt.connectionState property) changes. Methods# BluetoothGatt.connect() Connects to the remote LE device. BluetoothGatt.disconnect() Disconnects an already-established connection to a remote LE device. BluetoothGatt.discoverServices() Discovers services, characteristics, and descriptors offered by the remote GATT server. BluetoothGatt.readRemoteRssi() Reads the RSSI for a connected remote LE device.","keywords":""},{"title":"AudioChannelClient","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/others/AudioChannelClient/other-AudioChannelClient","content":"Description# TBD Interfaces# interface AudioChannelClient : EventTarget { [Throws] constructor(AudioChannel aChannel); // Called when APP wants to occupy the audio channel which is specified in the // constructor. After calling this function, it doesn't mean that this channel // is immediately unmuted. APP may want to hook onstatechange handler in order // to be notified when muted state changes. // This function is useful for APP which wants background music/FM to be // muted. [Throws] void requestChannel(); // Called when APP no longer wants to occupy the audio channel. APP must call // this function if it has called requestChannel(). [Throws] void abandonChannel(); // This event is dispatched when muted state changes. APP should check // channelMuted attribute to know current muted state. attribute EventHandler onstatechange; // When channelMuted is false, it means APP is allowed to play content through // this channel. It also means the competing channel may be muted, or its // volume may be reduced. // If the channel owned by us is suspended (muted), or APP did not request // channel, or APP has abandoned the channel, channelMuted is set to true. readonly attribute boolean channelMuted; }; Copy Examples# navigator.b2g.AudioChannelManager.volumeControlChannel = 'normal' AudioChannelClient('normal') HTMLMediaElement.mozAudioChannelType = 'normal' AudioContext.mozAudioChannelType = 'normal' Copy navigator.b2g.AudioChannelManager.volumeControlChannel = 'content' AudioChannelClient('content') HTMLMediaElement.mozAudioChannelType = 'content' AudioContext.mozAudioChannelType = 'content' Copy navigator.b2g.AudioChannelManager.volumeControlChannel = 'notification' AudioChannelClient('notification') HTMLMediaElement.mozAudioChannelType = 'notification' AudioContext.mozAudioChannelType = 'notification' Copy navigator.b2g.AudioChannelManager.volumeControlChannel = 'alarm' AudioChannelClient('alarm') HTMLMediaElement.mozAudioChannelType = 'alarm' AudioContext.mozAudioChannelType = 'alarm' Copy navigator.b2g.AudioChannelManager.volumeControlChannel = 'system' AudioChannelClient('system') HTMLMediaElement.mozAudioChannelType = 'system' AudioContext.mozAudioChannelType = 'system' Copy","keywords":""},{"title":"BluetoothDevice","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothdevice/BluetoothDevice","content":"Description# The BluetoothDevice interface of the Bluetooth API provides information regarding a given Bluetooth device. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothDevice: EventTarget { readonly attribute DOMString address; readonly attribute BluetoothClassOfDevice cod; readonly attribute DOMString name; readonly attribute boolean paired; readonly attribute BluetoothDeviceType type; [Cached, Pure] readonly attribute sequence<DOMString> uuids; readonly attribute BluetoothGatt? gatt; attribute EventHandler onattributechanged; [NewObject] Promise<sequence<DOMString>> fetchUuids(); }; Copy Properties# BluetoothDevice.addressA string representing the address of the device on the Bluetooth micro-network.BluetoothDevice.codReturns a BluetoothClassOfDevice object containing information about the device's capabilities.BluetoothDevice.gattReturns a BluetoothGatt object that allows JavaScript to conduct GATT client operations on a remote LE device. This property will return null for devices of type classic or unknown.BluetoothDevice.nameThe human readable name of the device.BluetoothDevice.paired {.read-only} A boolean indicating if the device is paired to the adapter (true) or not (false).BluetoothDevice.type {.read-only} Returns the device type of the remote device.BluetoothDevice.uuids {.read-only} An Array of strings indicating the UUIDs of each Bluetooth service the device is able to provide. Event handlers# BluetoothDevice.onattributechangedDefines a handler for the attributechanged event; triggers when a remote device's properties have changed (has a BluetoothAttributeEvent as a parameter.) Methods# BluetoothDevice.fetchUuidsFetches the up-to-date UUID list of services that the device provides. If the fetchUuids operation succeeds, an onattributechanged would be triggered right before the Promise is resolved to indicate device.uuids has changed.","keywords":""},{"title":"BluetoothGattService","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothgattservice/BluetoothGattService","content":"Description# The BluetoothGattService interface of the Bluetooth API represents a service provided by a GATT server, including the service definition, a list of referenced services, and a list of the characteristics of this service. Interface overview# [CheckAnyPermissions=\"bluetooth\", Constructor(boolean isPrimary, DOMString uuid)] interface BluetoothGattService { [Cached, Pure] readonly attribute sequence<BluetoothGattCharacteristic> characteristics; [Cached, Pure] readonly attribute sequence<BluetoothGattService> includedServices; readonly attribute boolean isPrimary; readonly attribute DOMString uuid; readonly attribute unsigned short instanceId; [NewObject] Promise<BluetoothGattCharacteristic> addCharacteristic(DOMString uuid, GattPermissions permissions, GattCharacteristicProperties properties, ArrayBuffer value); [NewObject] Promise<void> addIncludedService(BluetoothGattService service); }; Copy Properties# BluetoothGattService.characteristics Returns a cached array of BluetoothServiceCharacteristic objects representing the characteristics of this service. BluetoothGattService.includedServices Returns a cached array of BluetoothGattService objects representing the included services referenced by this service. BluetoothGattService.isPrimary Returns a Boolean Indicating whether this is a primary or secondary service. The default value is false, indicating a secondary service. BluetoothGattService.uuid Returns a DOMString representing the UUID of this service. BluetoothGattService.instanceId Returns a number representing the instance id of this service. Methods# BluetoothGattService.addCharacteristic() Adds a characteristic to this service. BluetoothGattService.addIncludedService() Adds a referenced included service to this service.","keywords":""},{"title":"BluetoothClassOfDevice","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothclassofdevice/BluetoothClassOfDevice","content":"Description# The BluetoothClassOfDevice interface of the Bluetooth API provides identifying/classification information about a given remote Bluetooth device, available at discovery stage. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothClassOfDevice { // Major service class const unsigned short LIMITED_DISCOVERABILITY = 0x0001; const unsigned short POSITIONING = 0x0008; const unsigned short NETWORKING = 0x0010; const unsigned short RENDERING = 0x0020; const unsigned short CAPTURING = 0x0040; const unsigned short OBJECT_TRANSFER = 0x0080; const unsigned short AUDIO = 0x0100; const unsigned short TELEPHONY = 0x0200; const unsigned short INFORMATION = 0x0400; // Major device class const octet MISC = 0x00; const octet COMPUTER = 0x01; const octet PHONE = 0x02; const octet NETWORK = 0x03; const octet AUDIO_VIDEO = 0x04; const octet PERIPHERAL = 0x05; const octet IMAGING = 0x06; const octet WEARABLE = 0x07; const octet TOY = 0x08; const octet HEALTH = 0x09; const octet UNCATEGORIZED = 0x1F; readonly attribute unsigned short majorServiceClass; readonly attribute octet majorDeviceClass; readonly attribute octet minorDeviceClass; }; Copy Properties# BluetoothClassOfDevice.majorDeviceClass {.read-only .no-link} Represents the Major Device Class of the CoD field of a Bluetooth Device; \"the highest level of granularity for defining a Bluetooth device\". [1] BluetoothClassOfDevice.minorDeviceClass {.read-only .no-link} Represents the Minor Device Class of the CoD field of a Bluetooth Device; \"interpreted only in the context of the Major Device Class (but independently of the Service Class field)\". [1] BluetoothClassOfDevice.majorServiceClass {.read-only .no-link} Represents the Major Service Class of the CoD field of a Bluetooth Device; \"the general families of devices with which Bluetooth SIG members want their applications to be associated\". [1] [1] https://www.bluetooth.org/en-us/specification/assigned-numbers/baseband","keywords":""},{"title":"BluetoothGattCharacteristicEvent","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothgattcharacteristicevent/BluetoothGattCharacteristicEvent","content":"Description# The BluetoothGattCharacteristicEvent interface of the Bluetooth API provides access to an updated BluetoothGattCharacteristic object as the parameter of the BluetoothGatt.oncharacteristicchanged, handler, when the characteristicchanged event is fired. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothGattCharacteristicEvent : Event { readonly attribute BluetoothGattCharacteristic? characteristic; }; Copy Properties# BluetoothGattCharacteristicEvent.characteristic Returns a BluetoothGattCharacteristic representing the characteristic that has been updated as a result of a remote notification event.","keywords":""},{"title":"BluetoothGattDescriptor","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothgattdescriptor/BluetoothGattDescriptor","content":"Description# The BluetoothGattDescriptor interface of the Web Bluetooth API represents a GATT descriptor, which contains related information about a characteristic value. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothGattDescriptor { readonly attribute BluetoothGattCharacteristic characteristic; readonly attribute DOMString uuid; readonly attribute ArrayBuffer? value; [Cached, Constant] readonly attribute GattPermissions permissions; [NewObject] Promise<ArrayBuffer> readValue(); [NewObject] Promise<void> writeValue(ArrayBuffer value); }; Copy Properties# BluetoothGattDescriptor.characteristic Returns the BluetoothGattCharacteristic object representing the characteristic this descriptor belongs to. BluetoothGattDescriptor.uuid Returns the UUID of this descriptor. BluetoothGattDescriptor.value Stores the cached value of this descriptor. This value can be updated via the BluetoothGattDescriptor.readValue() method. BluetoothGattDescriptor.permissions Returns a bit mask that describes the operations allowed on the characteristic. Methods# BluetoothGattDescriptor.readValue() Reads the descriptor value from the remote device. The cached BluetoothGattDescriptor.value is also updated after retrieving the value. BluetoothGattDescriptor.writeValue() Writes the descriptor value to the GATT server. If the local device is the GATT client, the value will be written to the remote GATT server. On the other hand, if the local device is the GATT server, the value will be written to BluetoothGattDescriptor.value.","keywords":""},{"title":"BluetoothManager","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothmanager/BluetoothManager","content":"Description# The BluetoothManager interface of the Bluetooth API allows to access all Bluetooth adapters available on the device. Adapters are the connection interface to connect a Bluetooth device to that device. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothManager: EventTarget { readonly attribute BluetoothAdapter? defaultAdapter; attribute EventHandler onattributechanged; attribute EventHandler onadapteradded; attribute EventHandler onadapterremoved; sequence<BluetoothAdapter> getAdapters(); }; Copy Properties# BluetoothManager.defaultAdapter A BluetoothAdapter object selected by default. The value would be null if the device doesn't have any Bluetooth chip. Event Handlers# BluetoothManager.onadapteradded A handler for the adapteradded event; it is triggered when a Bluetooth adapter is enabled on the device. BluetoothManager.onadapterremoved A handler for the adapterremoved event; it is triggered when a Bluetooth adapter is disabled on the device, or removed. BluetoothManager.onattributechanged A handler for the attributechanged event; it is triggered when the BluetoothManager.defaultAdapter property changes. Note: Because the BluetoothManager interface inherits from the EventTarget interface, all these events can be listened by using the addEventListener method. Methods# BluetoothManager.getAdapters() Returns a list of the current BluetoothAdapters in use on the device.","keywords":""},{"title":"BluetoothDeviceEvent","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothdeviceevent/BluetoothDeviceEvent","content":"Description# The BluetoothDeviceEvent interface of the Web Bluetooth API provides access to a found/paired device (BluetoothDevice) object or the address or an unpaired device as the parameter of a devicefound, devicepaired or deviceunpaired event handler (see BluetoothDiscoveryHandle.ondevicefound, BluetoothAdapter.ondevicepaired, and BluetoothAdapter.ondeviceunpaired), when fired. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothDeviceEvent : Event { readonly attribute BluetoothDevice? device; readonly attribute DOMString? address; }; Copy Properties# BluetoothDeviceEvent.device Returns a BluetoothDevice object representing the paired remote device. Returns null for the BluetoothAdapter.ondeviceunpaired event handler since the that only requires the address of the unpaired device. BluetoothDeviceEvent.address Returns a DOMString representing the address of the unpaired remote device. Returns null for the BluetoothDiscoveryHandle.ondevicefound and BluetoothAdapter.ondevicepaired event handlers since a found/paired remote device already has an BluetoothDevice.address property.","keywords":""},{"title":"OS ENV Setup","type":0,"sectionRef":"#","url":"docs/02.getting-started/01.env-setup/os-env-setup","content":"Instructions for users who have access to a debug device Windows Install Firefox Download firefox v59 before installing make sure the previous version of firefox is uninstalled. Disabling auto updates once Firefox is installed. (Menu -> options -> general) Install ADB Visit this Google page to Download the ADB ZIP file for Windows. Unzip the folder on your Windows C Drive (C:\\platform-tools). Connecting to Device Connect your device with the laptop using USB cable. Make sure it is in debug mode. Open the Settings app and follow this flow: Device > Developer > Debugger > ADB and DevTools Open command prompt of your laptop. Run $ cd /path/to/extracted/folder/ Run $ adb devices You should see your device has been detected. Run $ adb root $ adb forward tcp:6000 localfilesystem:/data/local/debugger-socket This is to establish a path between your device and the laptop. Open Firefox Web IDE. Click on “Remote Runtime” on the right side. Press “OK”. A warning about old connected runtime version would pop up. Ignore it. You are ready to install an app on your device Install your first app Open Firefox Web IDE and make sure you have connected your device and executed the commands $ adb root $ adb forward tcp:6000 localfilesystem:/data/local/debugger-socket If you have packaged app stored on your laptop, click “Open Packaged App” on the left side and select your project folder. Your project folder must have a manifest.webapp file. Otherwise, the IDE cannot open your app. Check here to create manifest.webapp file. After selecting your app, you should be able to see your app. Install the app on your device with RUN button and Debugger button to debug top center of WebIDE. Install the app. Then, you are available to use the basic tools in the web IDE for development, such as Inspector, Console, JavaScript Debugger, Style Editor, Scratchpad. macOS Install ADB You can follow this link install ADB tools for macOS. Install and Run app Download firefox v59 open terminal and run these commands $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" $ brew cask install android-platform-tools connect device and run adb devices You should see 1 device connected. disconnect from internet, install downloaded firefox, go to prefferences and disable updates (download or check): Connect to internet Go to about:config, turn the following preferences: xpinstall.signatures.required = false, extensions.legacy.enabled = true Go to this link and download install adb helper In Firefox Tools > Add on > Extension and add the downloaded adb_helper.xpi file In firefox go to Tools > Web Developer > WebIDE On right should see \"USB Devices\" and should have one device On the left have \"Open Packaged App\" - click it, and choose some app (a folder) Middle top click the play button... that's it, app should be on your phone and you should notice it. Linux Install Firefox You will need to get the Firefox v59 or older version for KaiOS implementations, to download these versions, you can get them through Mozilla FTP. After downloading the chosen version, you must unpack the package with the command: $ tar jxvf firefox-*.tar.bz2 -C /opt Create a shortcut to facilitate program execution $ sudo ln -sf /opt/firefox/firefox /usr/bin/firefox Setting WebIDE Firefox's WebIDE is a necessary development tool to inspect your app, as well as see the console, debugger, and others. Follow the instructions in WebIDE to setup and learn more about WebIDE. Installing make(Optional) Make is a necessary tool to run KaiOS. Execute the following commands on the terminal to install it. $ wget http://ftp.us.debian.org/debian/pool/main/m/make-dfsg/make_3.81-8.2_amd64.deb $ sudo dpkg -i make_3.81-8.2_amd64.deb $ sudo apt-mark hold make Setting the required architectures(Optional) $ sudo dpkg --add-architecture i386 $ sudo dpkg --add-architecture amd64 Installing dependencies(Optional) There are some necessary dependencies to complete your environment for running Gaia. Execute the command below on your terminal and all these dependencies will be installed. $ sudo apt install --no-install-recommends autoconf2.13 bison bzip2 ccache curl flex gawk gcc g++ g++-multilib git lib32ncurses5-dev lib32z1-dev libgconf2-dev zlib1g:amd64 zlib1g-dev:amd64 zlib1g:i386 zlib1g-dev:i386 libgl1-mesa-dev libx11-dev make zip lzop libxml2-utils openjdk-8-jdk nodejs unzip python Setting ccache(Optional) $ ccache -M 10G Installing ADB and fastboot $ sudo apt install android-tools-adb android-tools-fastboot Setting USB access $ wget -S -O - https://raw.githubusercontent.com/cm-b2g/B2G/1230463/tools/51-android.rules | sudo tee >/dev/null /etc/udev/rules.d/51-android.rules; sudo udevadm control --reload-rules Plug the device in your computer using a USB cable Use the command $ lsusb on the terminal to get the Vendor ID. Example of a result: Bus 001 Device 014: ID 22b8:2e76 Motorola PCS ===> vendor ID is 22b8 Log in as root and edit this file: /etc/udev/rules.d/51-android.rules In the file above put a new line using the vendor ID that you got before. Example: SUBSYSTEM==\"usb\", ATTR{idVendor}==\"22b8\", MODE=\"0666\", GROUP=\"plugdev\" Now execute: $ sudo chmod a+r /etc/udev/rules.d/51-android.rules Create the following file in your HOME dir (not as root) $ nano ~/.android/adb_usb.ini Put the value of vendor ID on this file using hex format. Example: 0x22b8, where 22b8 is the vendor ID that you got before. Use the command 'adb devices' on the terminal to list all devices connected on your PC. Your device should be listed and is ready to receive Gaia apps or use it on WebIDE. Connection Errors For more information about the ADB connection fail error see this link This extension will re-enable extensions that were disabled on May 3, 2019 for Firefox versions 52 - 56.","keywords":""},{"title":"BlueTooth","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/permission-table-bluetooth","content":"Description# The Bluetooth API lets a packaged app discover, pair with, and connect to Bluetooth devices. As it is a experimental and non-standard API, the API is currently available for certified and privileged apps only. Notice that 'bluetooth' permission is required for using Bluetooth API. Note: App developers who wish to send data to a Bluetooth device can use the share activity. This activity allows sharing of images, audio, video and vCard content only. API overview# The main entry point for the API is the Navigator.mozBluetooth property, which returns a BluetoothManager object. Basic interfaces# The following interfaces provide an app with basic Bluetooth functionality BluetoothManagerAllows access to all Bluetooth adapters available on the device. Adapters are the connection interface to connect another Bluetooth-enabled device to the current device.BluetoothAdapterUsed to handle all the operations requested by Bluetooth networks.BluetoothClassOfDeviceProvides identifying/classification information about a given remote Bluetooth device, available at discovery stage.BluetoothDeviceProvides information regarding a given remote Bluetooth device.BluetoothDiscoveryHandleUsed to notify the current application about the discovery of a remote bluetooth device. Gatt interfaces# The following interfaces allow KaiOS to communicate with and consume Gatt (Generic Attribute Profile)-based services on remote Smart/LE (low energy) devices. BluetoothGattHandles initial communications and connections with Gatt services.BluetoothGattServiceRepresents a service provided by a GATT server, including the service definition, a list of included services, and a list of the characteristics of this service.BluetoothGattCharacteristicRepresents a GATT service characteristic, which includes characteristic definition, value, properties and configuration info, and a list of descriptors that provide related information.BluetoothGattDescriptorRepresents a GATT descriptor, which contains related information about a characteristic value. Bluetooth event interfaces# These objects represent different events occuring within a Bluetooth interaction. BluetoothAdapterEventProvides access to a BluetoothAdapter object and its address as the parameter of a adapteradded or adapterremoved event handler (see BluetoothManager.onadapteradded and BluetoothManager.onadapterremoved), when fired.BluetoothAttributeEventProvides access to changed attributes and their new values as the parameter of attributechanged event handlers (including BluetoothManager.onattributechanged, BluetoothAdapter.onattributechanged, and BluetoothDevice.onattributechanged), when fired.BluetoothDeviceEventProvides access to a found/paired device (BluetoothDevice) object or the address or an unpaired device as the parameter of a devicefound, devicepaired or deviceunpaired event handler (see BluetoothDiscoveryHandle.ondevicefound, BluetoothAdapter.ondevicepaired, BluetoothAdapter.ondeviceunpaired), when fired.BluetoothGattCharacteristicEventProvides access to an updated BluetoothGattCharacteristic object as the parameter of the BluetoothGatt.oncharacteristicchanged, handler, when the characteristicchanged event is fired.BluetoothLeDeviceEventProvides access to an LE device BluetoothDevice object and its RSSI value and advertisement record, as the parameter of a devicefound event handler (see BluetoothDiscoveryHandle.ondevicefound), when fired.","keywords":""},{"title":"HTMLMediaElement","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/others/HTMLMediaElement/other-HTMLMediaElement","content":"Ref HTMLMediaElement# The HTMLMediaElement interface adds to HTMLElement the properties and methods needed to support basic media-related capabilities that are common to audio and video. The HTMLVideoElement and HTMLAudioElementelements both inherit this interface. Properties# This interface also inherits properties from its ancestors HTMLElement,Element, Node, and EventTarget. HTMLMediaElement.audioTracks A AudioTrackListthat lists the AudioTrack objects contained in the element. HTMLMediaElement.autoplay A Boolean that reflects the autoplay HTML attribute, indicating whether playback should automatically begin as soon as enough media is available to do so without interruption. Note: Automatically playing audio when the user doesn't expect or desire it is a poor user experience and should be avoided in most cases, though there are exceptions. See the Autoplay guide for media and Web Audio APIs for more information. Keep in mind that browsers may ignore autoplay requests, so you should ensure that your code isn't dependent on autoplay working. HTMLMediaElement.buffered Read only Returns a TimeRanges object that indicates the ranges of the media source that the browser has buffered (if any) at the moment the buffered property is accessed. HTMLMediaElement.controller Is a MediaController object that represents the media controller assigned to the element, or null if none is assigned. HTMLMediaElement.controls Is a Boolean that reflects the controls HTML attribute, indicating whether user interface items for controlling the resource should be displayed. HTMLMediaElement.controlsList Read only Returns a DOMTokenList that helps the user agent select what controls to show on the media element whenever the user agent shows its own set of controls. The DOMTokenList takes one or more of three possible values: nodownload, nofullscreen, and noremoteplayback. HTMLMediaElement.crossOrigin A DOMString indicating the CORS setting for this media element. HTMLMediaElement.currentSrc Read only Returns a DOMString with the absolute URL of the chosen media resource. HTMLMediaElement.currentTime A double-precision floating-point value indicating the current playback time in seconds; if the media has not started to play and has not been seeked, this value is the media's initial playback time. Setting this value seeks the media to the new time. The time is specified relative to the media's timeline. HTMLMediaElement.defaultMuted A Boolean that reflects the muted HTML attribute, which indicates whether the media element's audio output should be muted by default. HTMLMediaElement.defaultPlaybackRate A double indicating the default playback rate for the media. HTMLMediaElement.disableRemotePlayback A Boolean that sets or returns the remote playback state, indicating whether the media element is allowed to have a remote playback UI. HTMLMediaElement.duration Read only A read-only double-precision floating-point value indicating the total duration of the media in seconds. If no media data is available, the returned value is NaN. If the media is of indefinite length (such as streamed live media, a WebRTC call's media, or similar), the value is +Infinity. HTMLMediaElement.ended Read only Returns a Boolean that indicates whether the media element has finished playing. HTMLMediaElement.error Read only Returns a MediaError object for the most recent error, or null if there has not been an error. HTMLMediaElement.loop A Boolean that reflects the loop HTML attribute, which indicates whether the media element should start over when it reaches the end. HTMLMediaElement.mediaGroup A DOMString that reflects the mediagroup HTML attribute, which indicates the name of the group of elements it belongs to. A group of media elements shares a common MediaController. HTMLMediaElement.mediaKeys Read only Returns a MediaKeys object or null. MediaKeys is a set of keys that an associated HTMLMediaElement can use for decryption of media data during playback. HTMLMediaElement.muted Is a Boolean that determines whether audio is muted. true if the audio is muted and false otherwise. HTMLMediaElement.networkState Read only Returns a unsigned short (enumeration) indicating the current state of fetching the media over the network. HTMLMediaElement.paused Read only Returns a Boolean that indicates whether the media element is paused. HTMLMediaElement.playbackRate Is a double that indicates the rate at which the media is being played back. HTMLMediaElement.played Read only Returns a TimeRanges object that contains the ranges of the media source that the browser has played, if any. HTMLMediaElement.preload Is a DOMString that reflects the preload HTML attribute, indicating what data should be preloaded, if any. Possible values are: none, metadata, auto. HTMLMediaElement.preservesPitch Is a Boolean that determines if the pitch of the sound will be preserved. If set to false, the pitch will adjust to the speed of the audio. This is implemented with prefixes in Firefox (mozPreservesPitch) and WebKit (webkitPreservesPitch). HTMLMediaElement.readyState Read only Returns a unsigned short (enumeration) indicating the readiness state of the media. HTMLMediaElement.seekable Read only Returns a TimeRanges object that contains the time ranges that the user is able to seek to, if any. HTMLMediaElement.seeking Read only Returns a Boolean that indicates whether the media is in the process of seeking to a new position. HTMLMediaElement.sinkId Read only Returns a DOMStringthat is the unique ID of the audio device delivering output, or an empty string if it is using the user agent default. This ID should be one of the MediaDeviceInfo.deviceid values returned from MediaDevices.enumerateDevices(),id-multimedia, or id-communications. HTMLMediaElement.src Is a DOMStringthat reflects the src HTML attribute, which contains the URL of a media resource to use. HTMLMediaElement.srcObject Is a MediaStream representing the media to play or that has played in the current HTMLMediaElement, or null if not assigned. HTMLMediaElement.textTracks Read only Returns the list of TextTrack objects contained in the element. HTMLMediaElement.videoTracks Read only Returns the list of VideoTrack objects contained in the element. HTMLMediaElement.volume Is a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest). Event handlers# HTMLMediaElement.onencrypted Sets the EventHandler called when the media is encrypted. HTMLMediaElement.onwaitingforkey Sets the EventHandler called when playback is blocked while waiting for an encryption key. Obsolete attributes# These attributes are obsolete and should not be used, even if a browser still supports them. HTMLMediaElement.initialTime Read only Returns a double that indicates the initial playback position in seconds. HTMLMediaElement.mozAudioCaptured Read only Returns a Boolean. Related to audio stream capture. HTMLMediaElement.mozChannels Read only Returns a double representing the number of channels in the audio resource (e.g., 2 for stereo). HTMLMediaElement.mozFragmentEnd Read only Is a double that provides access to the fragment end time if the media element has a fragment URI for currentSrc, otherwise it is equal to the media duration. HTMLMediaElement.mozFrameBufferLength Read only Is a unsigned long that indicates the number of samples that will be returned in the framebuffer of each MozAudioAvailable event. This number is a total for all channels, and by default is set to be the number of channels 1024 (e.g., 2 channels 1024 samples = 2048 total). The mozFrameBufferLength property can be set to a new value for lower latency, larger amounts of data, etc. The size given must be a number between 512 and 16384. Using any other size results in an exception being thrown. The best time to set a new length is after the loadedmetadata event fires, when the audio info is known, but before the audio has started or MozAudioAvailable events have begun firing. HTMLMediaElement.mozSampleRate Read only Returns a double representing the number of samples per second that will be played. For example, 44100 samples per second is the sample rate used by CD audio. Obsolete event handlers# HTMLMediaElement.onmozinterruptbegin Sets the EventHandler called when the media element is interrupted because of the Audio Channel manager. This was Firefox-specific, having been implemented for Firefox OS, and was removed in Firefox 55. HTMLMediaElement.onmozinterruptend Sets the EventHandler called when the interruption is concluded. This was Firefox-specific, having been implemented for Firefox OS, and was removed in Firefox 55. Methods# This interface also inherits methods from its ancestors HTMLElement,Element, Node, and EventTarget. HTMLMediaElement.addTextTrack() Adds a text track (such as a track for subtitles) to a media element. HTMLMediaElement.captureStream() Returns MediaStream, captures a stream of the media content. HTMLMediaElement.canPlayType() Given a string specifying a MIME media type (potentially with the codecs parameter included),canPlayType() returns the string probably if the media should be playable, maybe if there's not enough information to determine whether the media will play or not, or an empty string if the media cannot be played. HTMLMediaElement.fastSeek() Directly seeks to the given time. HTMLMediaElement.load() Resets the media to the beginning and selects the best available source from the sources provided using the src attribute or the <source> element. HTMLMediaElement.pause() Pauses the media playback. HTMLMediaElement.play() Begins playback of the media. HTMLMediaElement.seekToNextFrame() Seeks to the next frame in the media. This non-standard, experimental method makes it possible to manually drive reading and rendering of media at a custom speed, or to move through the media frame-by-frame to perform filtering or other operations. HTMLMediaElement.setMediaKeys() Returns Promise. Sets the MediaKeys keys to use when decrypting media during playback. HTMLMediaElement.setSinkId() Sets the ID of the audio device to use for output and returns a Promise. This only works when the application is authorized to use the specified device. Obsolete methods# HTMLMediaElement.mozCaptureStream() [enter description] HTMLMediaElement.mozCaptureStreamUntilEnded() [enter description] HTMLMediaElement.mozGetMetadata() Returns Object, which contains properties that represent metadata from the playing media resource as {key: value} pairs. A separate copy of the data is returned each time the method is called. This method must be called after the loadedmetadata event fires. HTMLMediaElement.mozLoadFrom() This method, available only in Mozilla's implementation, loads data from another media element. This works similarly to load() except that instead of running the normal resource selection algorithm, the source is simply set to the other element's currentSrc. This is optimized so this element gets access to all of the other element's cached and buffered data; in fact, the two elements share downloaded data, so data downloaded by either element is available to both. Events# Inherits methods from its parent, HTMLElement , defined in the GlobalEventHandlers mixin. Listen to these events using addEventListener() or by assigning an event listener to the oneventname property of this interface. abort Fired when the resource was not fully loaded, but not as the result of an error. canplay Fired when the user agent can play the media, but estimates that not enough data has been loaded to play the media up to its end without having to stop for further buffering of content. canplaythrough Fired when the user agent can play the media, and estimates that enough data has been loaded to play the media up to its end without having to stop for further buffering of content. durationchange Fired when the duration attribute has been updated. emptied Fired when the media has become empty; for example, when the media has already been loaded (or partially loaded), and the HTMLMediaElement.load() method is called to reload it. ended Fired when playback stops when end of the media (<audio> or <video>) is reached or because no further data is available. error Fired when the resource could not be loaded due to an error. loadeddata Fired when the first frame of the media has finished loading. loadedmetadata Fired when the metadata has been loaded. loadstart Fired when the browser has started to load a resource. pause Fired when a request to pause play is handled and the activity has entered its paused state, most commonly occurring when the media's HTMLMediaElement.pause() method is called. play Fired when the paused property is changed from true to false, as a result of the HTMLMediaElement.play() method, or the autoplay attribute. playing Fired when playback is ready to start after having been paused or delayed due to lack of data. progress Fired periodically as the browser loads a resource. ratechange Fired when the playback rate has changed. seeked Fired when a seek operation completes. seeking Fired when a seek operation begins. stalled Fired when the user agent is trying to fetch media data, but data is unexpectedly not forthcoming. suspend Fired when the media data loading has been suspended. timeupdate Fired when the time indicated by the currentTime attribute has been updated. volumechange Fired when the volume has changed. waiting Fired when playback has stopped because of a temporary lack of data.","keywords":""},{"title":"Notification","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/others/notification/other-Notification","content":"Ref Notifications# Description# The Notification interface of the Notifications API is used to configure and display desktop notifications to the user. These notifications' appearance and specific functionality vary across platforms but generally they provide a way to asynchronously provide information to the user. Constructor# Notification() Creates a new instance of the Notification object. Properties# Static properties# These properties are available only on the Notification object itself. Notification.permission Read only A string representing the current permission to display notifications. Possible values are: denied — The user refuses to have notifications displayed.granted — The user accepts having notifications displayed.default — The user choice is unknown and therefore the browser will act as if the value were denied. Notification.maxActions Read only Instance properties# These properties are available only on instances of the Notification object. Notification.actions Read only The actions array of the notification as specified in the constructor's options parameter. Notification.badge Read only The URL of the image used to represent the notification when there is not enough space to display the notification itself. Notification.body Read only The body string of the notification as specified in the constructor's options parameter. Notification.data Read only Returns a structured clone of the notification’s data. Notification.dir Read only The text direction of the notification as specified in the constructor's options parameter. Notification.lang Read only The language code of the notification as specified in the constructor's options parameter. Notification.tag Read only The ID of the notification (if any) as specified in the constructor's options parameter. Notification.icon Read only The URL of the image used as an icon of the notification as specified in the constructor's options parameter. Notification.image Read only The URL of an image to be displayed as part of the notification, as specified in the constructor's options parameter. Notification.renotify Read only Specifies whether the user should be notified after a new notification replaces an old one. Notification.requireInteraction Read only A Boolean indicating that a notification should remain active until the user clicks or dismisses it, rather than closing automatically. Notification.silent Read only Specifies whether the notification should be silent — i.e., no sounds or vibrations should be issued, regardless of the device settings. Notification.timestamp Read only Specifies the time at which a notification is created or applicable (past, present, or future). Notification.title Read only The title of the notification as specified in the first parameter of the constructor. Notification.vibrate Read only Specifies a vibration pattern for devices with vibration hardware to emit. Event handlers# Notification.onclick A handler for the click event. It is triggered each time the user clicks on the notification. Notification.onclose A handler for the close event. It is triggered when the user closes the notification. Notification.onerror A handler for theerrorevent. It is triggered each time the notification encounters an error. Notification.onshow A handler for the show event. It is triggered when the notification is displayed. Methods# Static methods# These methods are available only on the Notification object itself. Notification.requestPermission() Requests permission from the user to display notifications. Instance methods# These properties are available only on an instance of the Notification object or through its prototype. The Notification object also inherits from the EventTarget interface. Notification.close() Programmatically closes a notification instance. Examples# Assume this basic HTML: <button onclick=\"notifyMe()\">Notify me!</button> Copy It's possible to send a notification as follows — here we present a fairly verbose and complete set of code you could use if you wanted to first check whether notifications are supported, then check if permission has been granted for the current origin to send notifications, then request permission if required, before then sending a notification. function notifyMe() { // Let's check if the browser supports notifications if (!(\"Notification\" in window)) { alert(\"This browser does not support desktop notification\"); } // Let's check whether notification permissions have already been granted else if (Notification.permission === \"granted\") { // If it's okay let's create a notification var notification = new Notification(\"Hi there!\"); } // Otherwise, we need to ask the user for permission else if (Notification.permission !== \"denied\") { Notification.requestPermission().then(function (permission) { // If the user accepts, let's create a notification if (permission === \"granted\") { var notification = new Notification(\"Hi there!\"); } }); } // At last, if the user has denied notifications, and you // want to be respectful there is no need to bother them any more. } Copy We no longer show a live sample on this page, as Chrome and Firefox no longer allow notification permissions to be requested from cross-origin <iframe>s, with other browsers to follow. To see a example in action, check out our To-do list example (also see the app running live.) Note: In the above example we spawn notifications in response to a user gesture (clicking a button). This is not only best practice — you should not be spamming users with notifications they didn't agree to — but going forward browsers will explicitly disallow notifications not triggered in response to a user gesture. Firefox is already doing this from version 72, for example.","keywords":""},{"title":"Development Environment","type":0,"sectionRef":"#","url":"docs/02.getting-started/01.env-setup/development-env","content":"Text editor / Integrated Development Environment (IDE) Visual Studio Code Visual Studio Code is a source code editor developed by Microsoft for Windows, Linux and macOS. It includes support for debugging, embedded Git control, syntax highlighting, intelligent code complementation, snippets, and code refactoring. It is also customizable, allowing users to change the editor theme, shortcut keys, and preferences. WebStorm WebStorm is a cross-platform IDE primarily for web, JavaScript and TypeScript development. Many of JetBrain's other IDEs include the feature set of WebStorm via plugins. Atom Atom is an open source text editor available for Linux, MacOS and Microsoft Windows platforms, developed by GitHub under the MIT license. The tool was created using Electron and web technologies like HTML, JavaScript and CSS. Allows the installation of extensions developed with Node.js. Sublime Text Sublime Text is a multiplatform text editing software, however used by many developers to edit source code. Vim Vim is designed for use both from a command-line interface and as a standalone application in a graphical user interface. Vim is free and open-source software and is released under a license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. Node To get started, you need to have the node installed on your computer, if you do not have it on your computer, follow these steps, choosing your operating system. Install Yarn (Optional) Yarn is a JavaScript Package Manager, a direct competitor of npm, and it’s one of the Facebook Open Source projects. It’s compatible with npm packages, so it has the great advantage of being a drop-in replacement for npm. When it launched it used to be way faster than npm due to parallel download and caching, to install follow these steps. Git Git is a file version control system. Through Git, we can develop projects in which multiple people can simultaneously contribute to the same by editing and creating new files and allowing them to exist without the risk of their changes being overwritten. Follow the steps in the documentation to install.","keywords":""},{"title":"BluetoothGattCharacteristic","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothgattcharacteristic/BluetoothGattCharacteristic","content":"Description# The BluetoothGattCharacteristic interface of the Bluetooth API represents a GATT service characteristic, which includes characteristic definition, value, properties and configuration info, and a list of descriptors that provide related information. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothGattCharacteristic { readonly attribute BluetoothGattService service; [Cached, Pure] readonly attribute sequence<BluetoothGattDescriptor> descriptors; readonly attribute DOMString uuid; readonly attribute unsigned short instanceId; readonly attribute ArrayBuffer? value; [Cached, Constant] readonly attribute Permissions permissions; [Cached, Constant] readonly attribute GattCharacteristicProperties properties; [NewObject] Promise<ArrayBuffer> readValue(); [NewObject] Promise<void> writeValue(ArrayBuffer value); [NewObject] Promise<void> startNotifications(); [NewObject] Promise<void> stopNotifications(); [NewObject] Promise<BluetoothGattDescriptor> addDescriptor(DOMString uuid, Permissions permissions, ArrayBuffer value); }; Copy Properties# BluetoothGattCharacteristic.service Returns the BluetoothGattService that this characteristic belongs to. BluetoothGattCharacteristic.descriptors Returns a cached array containing the BluetoothGattDescriptor objects that describe this characteristic. BluetoothGattCharacteristic.uuid Returns a DOMString representing the UUID of this characteristic. BluetoothGattCharacteristic.instanceId Returns a number representing the instance id of this characteristic. BluetoothGattCharacteristic.value Returns The cached value of this characteristic. This value can be updated via the BluetoothGattCharacteristic.readValue() method, characteristic notification, or indication from the remote device. BluetoothGattCharacteristic.permissions Returns a bit mask that describes the operations permitted on this characteristic. BluetoothGattCharacteristic.properties Returns a bit mask that describes how to use the characteristic value. Methods# BluetoothGattCharacteristic.readValue() Reads the characteristic value from the remote device. The cached value property will also be updated after retrieving the value. BluetoothGattCharacteristic.writeValue() Writes the characteristic value to the GATT server. If the local device is the GATT client, the value will be written to the remote GATT server. On the other hand, if the local device is the GATT server, the value will be written to BluetoothGattCharacteristic.value. BluetoothGattCharacteristic.startNotifications() Registers notifications/indications for this characteristic. BluetoothGattCharacteristic.stopNotifications() Unregisters notifications/indications for this characteristic. BluetoothGattCharacteristic.addDescriptor() Adds a descriptor to this characteristic.","keywords":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"docs/","content":"KaiOS Product is decoupled into two components : Core and App Profile. App Profile A collection of built-in web apps, which represents the user interfacing functions of KaiOS for a given device form factor. Core The underlying platform that consists of the Web application runtime, i.e. Gecko, plus the hardware adaptation layer and a few other supporting module.","keywords":""},{"title":"A Short History of KaiOS","type":0,"sectionRef":"#","url":"docs/01.introduction/history","content":"About KaiOS In just three years, KaiOS has become the world’s third-largest mobile operating system, running on over 130 million smart feature phones in over 100 countries worldwide. Here’s the story of our name, our connection with Firefox, and our purpose. Our name KaiOS isn’t the same as Firefox OS. Although our operating system is based on the original Mozilla project, KaiOS has evolved into something different. When the current stakeholders took over the project from Mozilla, we decided to look for a name that reflected our aspiration of creating a platform that was accessible to everyone. We wanted it to work in both Western and Asian languages. We chose Kai, which is Chinese for open – 开 (kāi). Kai is easy to pronounce in almost any language and captures the idea of being inclusive. Our mission Over four billion people in the world still have no internet access. That’s more than half of the world’s population left out of the digital revolution. What's keeping them disconnected? Smartphones are expensive. Data plans cost too much. Advanced touchscreen devices and apps are intimidating to first-time internet users. That’s where we come in. Through partnerships with carriers, manufacturers, and developers worldwide, we bring the best of smartphones to easy-to-use, affordable devices. Our smart feature phones enable outdoor workers, senior citizens, and families living in remote areas to take advantage of all that the internet has to offer to improve their lives. This includes apps that bring important and useful information on topics such as health, digital skills, personal finance, women empowerment, and more. We believe that access to the internet can change lives, which is why our team of 300 people around the world go to work every day – to help more people join the digital revolution. KaiOS, enable tomorrow","keywords":""},{"title":"BluetoothLeDeviceEvent","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothledeviceevent/BluetoothLeDeviceEvent","content":"Description# The BluetoothLeDeviceEvent interface of the Bluetooth API provides access to an LE device BluetoothDevice object and its RSSI value and advertisement record, as the parameter of a devicefound event handler (see BluetoothDiscoveryHandle.ondevicefound), when fired. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothLeDeviceEvent : Event { readonly attribute BluetoothDevice? device; readonly attribute short rssi; [Throws] readonly attribute ArrayBuffer? scanRecord; }; Copy Properties# BluetoothLeDeviceEvent.device Returns a BluetoothDevice representing the discovered remote LE device. BluetoothLeDeviceEvent.rssi Returns the RSSI value for the remote LE device as reported by the bluetooth hardware. The value is given as 0 if no RSSI value is available. BluetoothLeDeviceEvent.scanRecord Returns an ArrayBuffer representing the content of the advertisement record offered by the remote LE device.","keywords":""},{"title":"BluetoothGattServer","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothgattserver/BluetoothGattServer","content":"Description# The BluetoothGattServer interface of the Bluetooth API provides Bluetooth GATT server functionality to allow creation of Bluetooth Smart/LE services and characteristics. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothGattServer { [Cached, Pure] readonly attribute sequence<BluetoothGattService> services; attribute EventHandler ondeviceconnectionstatechanged; attribute EventHandler onattributereadreq; attribute EventHandler onattributewritereq; [NewObject] Promise<void> connect(DOMString address); [NewObject] Promise<void> disconnect(DOMString address); [NewObject] Promise<void> addService(BluetoothGattService service); [NewObject] Promise<void> removeService(BluetoothGattService service); [NewObject] Promise<void> notifyCharacteristicChanged(DOMString address, DOMString uuid, int instanceId, bool confirm); [NewObject] Promise<void> sendResponse(DOMString address, int status, int requestId, ArrayBuffer value); }; Copy Properties# BluetoothGattServer.services Returns an array of the services offered by this device. Event handlers# BluetoothGattServer.ondeviceconnectionstatechanged Defines a handler to trigger as a result of the deviceconnectionstatechanged event firing; this occurs when a remote LE device has been connected or disconnected. BluetoothGattServer.onattributereadreq Defines a handler to trigger as a result of the attributereadreq event firing; this occurs when a remote client has requested to read a server's characteristic or descriptor. BluetoothGattServer.onattributewritereq Defines a handler to trigger as a result of the attributewritereq event firing; this occurs when a remote client has requested to write a server's characteristic or descriptor. Methods# BluetoothGattServer.connect() Initiates a connection to a remote LE device. BluetoothGattServer.disconnect() Disconnects an already-established connection to a remote LE device. BluetoothGattServer.addservice() Adds a BluetoothGattService to the server's list of provided services. BluetoothGattServer.removeservice() Removes a BluetoothGattService from the server's list of provided services. BluetoothGattServer.notifyCharacteristicChanged() Sends a notification/indication that a local characteristic has been updated. BluetoothGattServer.sendResponse() Sends a response to a remote LE device's read or write request.","keywords":""},{"title":"navigator.b2g.downloadManager","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/b2g/downloadManager/navigator-b2g-downloadManager","content":"Description# This class simplifies the access of the Download Manager window. Interfaces# DownloadManager# enum DownloadState { \"downloading\", \"stopped\", \"succeeded\", \"finalized\" }; Copy interface DownloadManager : EventTarget { // This promise returns an array of downloads with all the current // download objects. Promise<sequence<DownloadObject>> getDownloads(); // Removes one download from the downloads set. Returns a promise resolved // with the finalized download. Promise<DownloadObject> remove(DownloadObject download); // Removes all completed downloads. This kicks off an asynchronous process // that will eventually complete, but will not have completed by the time this // method returns. If you care about the side-effects of this method, know // that each existing download will have its onstatechange method invoked and // will have a new state of \"finalized\". (After the download is finalized, no // further events will be generated on it.) void clearAllDone(); // Add completed downloads from applications that must perform the download // process themselves. For example, email. The method is resolved with a // fully populated DownloadObject instance on success, or rejected in the // event all required options were not provided. // // The adopted download will also be reported via the ondownloadstart event // handler. // // Applications must currently be certified to use this, but it could be // widened at a later time. // // Note that \"download\" is not actually optional, but WebIDL requires that it // be marked as such because it is not followed by a required argument. The // promise will be rejected if the dictionary is omitted or the specified // file does not exist on disk. Promise<DownloadObject> adoptDownload(optional AdoptDownloadDict download = {}); // Fires when a new download starts. attribute EventHandler ondownloadstart; }; Copy DownloadObject# interface DownloadObject : EventTarget { // The full size of the resource. readonly attribute long long totalBytes; // The number of bytes that we have currently downloaded. readonly attribute long long currentBytes; // The url of the resource. readonly attribute DOMString url; // The full path in local storage where the file will end up once the download // is complete. This is equivalent to the concatenation of the 'storagePath' // to the 'mountPoint' of the nsIVolume associated with the 'storageName' // (with delimiter). readonly attribute DOMString path; // The DeviceStorage volume name on which the file is being downloaded. readonly attribute DOMString storageName; // The DeviceStorage path on the volume with 'storageName' of the file being // downloaded. readonly attribute DOMString storagePath; // The state of the download. One of: downloading, stopped, succeeded, or // finalized. A finalized download is a download that has been removed / // cleared and is no longer tracked by the download manager and will not // receive any further onstatechange updates. readonly attribute DownloadState state; // The mime type for this resource. readonly attribute DOMString contentType; // The timestamp this download started. readonly attribute object startTime; // An opaque identifier for this download. All instances of the same // download (eg. in different windows) will have the same id. readonly attribute DOMString id; // The manifestURL of the application that added this download. Only used for // downloads added via the adoptDownload API call. readonly attribute DOMString? sourceAppManifestURL; // A DOM error object, that will be not null when a download is stopped // because something failed. readonly attribute DOMException? error; // Pauses the download. Promise<DownloadObject> pause(); // Resumes the download. This resolves only once the download has // succeeded. Promise<DownloadObject> resume(); // This event is triggered anytime a property of the object changes: // - when the transfer progresses, updating currentBytes. // - when the state and/or error attributes change. attribute EventHandler onstatechange; }; Copy AdoptDownloadDict# // Used to initialize the DownloadObject object for adopted downloads. // fields directly maps to the DownloadObject fields. dictionary AdoptDownloadDict { // The URL of this resource if there is one available. An empty string if // the download is not accessible via URL. An empty string is chosen over // null so that existinc code does not need to null-check but the value is // still falsey. (Note: If you do have a usable URL, you should probably not // be using the adoptDownload API and instead be initiating downloads the // normal way.) DOMString url; // The storageName of the DeviceStorage instance the file was saved to. // Required but marked as optional so the bindings don't auto-coerce the value // null to \"null\". DOMString? storageName; // The path of the file within the DeviceStorage instance named by // 'storageName'. This is used to automatically compute the 'path' of the // download. Note that when DeviceStorage gives you a path to a file, the // first path segment is the name of the specific device storage and you do // *not* want to include this. For example, if DeviceStorage tells you the // file has a path of '/sdcard1/actual/path/file.ext', then the storageName // should be 'sdcard1' and the storagePath should be 'actual/path/file.ext'. // // The existence of the file will be validated will be validated with stat() // and the size the file-system tells us will be what we use. // // Required but marked as optional so the bindings don't auto-coerce the value // null to \"null\". DOMString? storagePath; // The mime type for this resource. Required, but marked as optional because // WebIDL otherwise auto-coerces the value null to \"null\". DOMString? contentType; // The time the download was started. If omitted, the current time is used. object? startTime; }; Copy Examples# const downloadManager = navigator.b2g.downloadManager; if (!downloadManager) { console.error('navigator.b2g.downloadManager not supported!'); return; } downloadManager.clearAllDone(); function onDownloadStart(ev) { // start download process } downloadManager.addEventListener('downloadstart', onDownloadStart); Copy","keywords":""},{"title":"Technologies","type":0,"sectionRef":"#","url":"docs/01.introduction/technologies","content":"KaiOS apps are based on web technologies – HTML, CSS, and JavaScript and are run by Gecko runtime. If you have written a web page you already know the basics. Rendering is done by parsing HTML/CSS and painted using graphic APIs. JavaScript are executed by the JS engine SpiderMonkey and connected to C++ components by XPConnect and WebIDL bindings. Applications and the core process communicate only through IPC protocols defined by IPDL. Additionally a set of core components including file and memory management, threads and data structures etc. are provided through the XPCOM component object model.","keywords":""},{"title":"Simulator","type":0,"sectionRef":"#","url":"docs/02.getting-started/01.env-setup/simulator","content":"The simulator lets you run Gaia and Web apps in a Gecko-based environment somewhat similar to an actual device. It doesn't emulate device hardware, so it's not adequate for testing device APIs and it isn't a replacement for testing on actual hardware. It can, therefore, be useful during the development of your application, or while working on the application user interface itself. This article covers downloading of the simulator, as well as how to use it. Resources Linux Simulator Build Release information Revision: kaiosrt-v2.5-ubuntu_Sep19 (Sep. 2019) Release note: Support Ubuntu.Embed adb in simulator debugger feature and support debugging device with simulator.UI modification.Screenshot function supported.Fix app uninstall function(from option menu).By design: Only support system and basic app (Settings) for development.Only support PC keyboard to type text, can’t input text with keypad.Hardware related function not supported, ex. BT, Modem related, GPS, etc.In web view design, developer can click on device screen to focus and scroll. In native view, developer can use D-pad to go up/down/left/right. Known issues: Contacts function is not working.When device is become black and no response, click on device screen to wake it up. Launch KaiOS Runtime (Kaiosrt) app Linux Unzip the Kaiosrt_ubuntu.zip file firstEnter the kaiosrt folderRun kaiosrt file Create a new app With Kaiosrt opened, click on New App... on the left side Choose a template and name your project Name the project and select the folder to save it Install and run the app After app is created, click on the Install and run button (the play icon at the top of the Kaiosrt window) Kaiosrt will be updated as below Debugging runtime apps Click on the Debug App button (the wrench icon at the top of the Kaiosrt window) and the console panel will show up below it","keywords":""},{"title":"BluetoothStatusChangedEvent","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/next-new-apis/permissionAPIs/BlueTooth/bluetoothstatuschangedevent/BluetoothStatusChangedEvent","content":"Description# The BluetoothStatusChangedEvent API provides access to information regarding any change to the status of a Bluetooth device. A status change occurs when one of the following events is triggered: a2dpstatuschange : It occurs when an A2DP connection status changes. See BluetoothAdapter.ona2dpstatuschanged for more information.hfpstatuschange : It occurs when an HFP connection status changes. See BluetoothAdapter.onhfpstatuschanged for more information.scostatuschange : It occurs when an SCO connection status changes. See BluetoothAdapter.onscostatuschanged for more information. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothStatusChangedEvent : Event { readonly attribute DOMString address; readonly attribute boolean status; }; Copy Properties# BluetoothStatusChangedEvent.address A string representing the address of the device for which the status has changed in the Bluetooth micro-network. BluetoothStatusChangedEvent.status] A boolean representing the current status of the connection. It can be enabled (true) or disabled (false).","keywords":""},{"title":"Building with Web technologies","type":0,"sectionRef":"#","url":"docs/02.getting-started/03.build-your-first-package-app/building-with-web-technologies","content":"To build an application for KaiOS, you need to learn three technologies: HTML - (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. CSS - (Cascading Style Sheets) is a language that describes the style of an HTML document, describes how HTML elements should be displayed. JavaScript - is a lightweight interpreted or just-in-time compiled programming language with first-class functions. JavaScript is a prototype-based, multi-paradigm, dynamic language, supporting object-oriented, imperative, and declarative styles.","keywords":""},{"title":"Permission Changes","type":0,"sectionRef":"#","url":"docs/sfp-3.0/09.migration-from-2.5/permission-change","content":"Permission Name\t2.5 Manifest Permission\tWeb App\tPriviliged App\t3.0 Manifest Permission\tPWA\tSigned AppAlarm\talarms\tALLOW_ACTION\tALLOW_ACTION\talarms\tALLOW_ACTION\tALLOW_ACTION Audio Capture\taudio-capture\tPROMPT_ACTION\tPROMPT_ACTION\taudio-capture\tPROMPT_ACTION\tPROMPT_ACTION Audio Channels\taudio-channel-normal\tALLOW_ACTION\tALLOW_ACTION\taudio-channel-normal\tALLOW_ACTION\tALLOW_ACTION Audio Channels\taudio-channel-content\tALLOW_ACTION\tALLOW_ACTION\taudio-channel-content\tALLOW_ACTION\tALLOW_ACTION Audio Channels\taudio-channel-notification\tDENY_ACTION\tALLOW_ACTION\taudio-channel-notification\tDENY_ACTION\tALLOW_ACTION Audio Channels\taudio-channel-alarm\tDENY_ACTION\tALLOW_ACTION\taudio-channel-alarm\tDENY_ACTION\tALLOW_ACTION Audio Channels\taudio-channel-system\tDENY_ACTION\tALLOW_ACTION\taudio-channel-system\tDENY_ACTION\tALLOW_ACTION Bluetooth\tbluetooth\tDENY_ACTION\tALLOW_ACTION\tbluetooth\tDENY_ACTION\tALLOW_ACTION Camera\tcamera\tDENY_ACTION\tPROMPT_ACTION\tcamera\tDENY_ACTION\tPROMPT_ACTION Contacts\tcontacts\tDENY_ACTION\tALLOW_ACTION\tcontacts\tDENY_ACTION\tPROMPT_ACTION Data Call\tdatacall\tDENY_ACTION\tALLOW_ACTION\tdatacall\tDENY_ACTION\tALLOW_ACTION Device Storage\tdevice-storage:pictures\tDENY_ACTION\tPROMPT_ACTION\tdevice-storage:pictures\tPROMPT_ACTION\tPROMPT_ACTION Device Storage\tdevice-storage:videos\tDENY_ACTION\tPROMPT_ACTION\tdevice-storage:videos\tDENY_ACTION\tPROMPT_ACTION Device Storage\tdevice-storage:music\tDENY_ACTION\tPROMPT_ACTION\tdevice-storage:music\tDENY_ACTION\tPROMPT_ACTION Device Storage\tdevice-storage:sdcard\tDENY_ACTION\tPROMPT_ACTION\tdevice-storage:sdcard\tDENY_ACTION\tPROMPT_ACTION Download Manager\tdownloads\tDENY_ACTION\tDENY_ACTION\tdownloads\tDENY_ACTION\tALLOW_ACTION External API\texternalapi\tDENY_ACTION\tALLOW_ACTION\texternalapi\tDENY_ACTION\tALLOW_ACTION FM Radio\tfmradio\tDENY_ACTION\tALLOW_ACTION\tfmradio\tDENY_ACTION\tALLOW_ACTION Feature Detection\tfeature-detection\tDENY_ACTION\tALLOW_ACTION\tfeature-detection\tDENY_ACTION\tALLOW_ACTION Geolocation\tgeolocation\tPROMPT_ACTION\tPROMPT_ACTION\tgeolocation\tPROMPT_ACTION\tPROMPT_ACTION getUserMedia\tvideo-capture\tPROMPT_ACTION\tPROMPT_ACTION\tvideo-capture\tPROMPT_ACTION\tPROMPT_ACTION IME\tinput-manage\tDENY_ACTION\tDENY_ACTION\tinput-manage\tDENY_ACTION\tALLOW_ACTION Keyboard\tinput\tDENY_ACTION\tALLOW_ACTION\tinput\tDENY_ACTION\tALLOW_ACTION Mobile Message Manager\tsms\tDENY_ACTION\tDENY_ACTION\tsms\tDENY_ACTION\tDENY_ACTION Mobile Network\tmobilenetwork\tDENY_ACTION\tALLOW_ACTION\tmobilenetwork\tDENY_ACTION\tALLOW_ACTION Notification\tdesktop-notification\tALLOW_ACTION\tALLOW_ACTION\tdesktop-notification\tALLOW_ACTION\tPROMPT_ACTION ServiceWorker\tserviceworker\tALLOW_ACTION\tALLOW_ACTION\tserviceworker\tALLOW_ACTION\tDon't need permission Speaker Control\tspeaker-control\tDENY_ACTION\tALLOW_ACTION\tspeaker-control\tDENY_ACTION\tALLOW_ACTION SystemXHR\tsystemXHR\tDENY_ACTION\tALLOW_ACTION\tsystemXHR\tDENY_ACTION\tALLOW_ACTION TCP Socket\ttcp-socket\tDENY_ACTION\tALLOW_ACTION\ttcp-socket\tDENY_ACTION\tALLOW_ACTION Vibration\tvibration\tALLOW_ACTION\tALLOW_ACTION\tvibration\tALLOW_ACTION\tALLOW_ACTION Video Capture\tvideo-capture\tPROMPT_ACTION\tPROMPT_ACTION\tvideo-capture\tPROMPT_ACTION\tPROMPT_ACTION Virtual Cursor\tspatialnavigation-app-manage\tDENY_ACTION\tALLOW_ACTION\tvirtualcursor\tDENY_ACTION\tALLOW_ACTION Volume Manager\tvolumemanager\tDENY_ACTION\tALLOW_ACTION\tvolumemanager\tDENY_ACTION\tALLOW_ACTION","keywords":""},{"title":"First hosted App","type":0,"sectionRef":"#","url":"docs/02.getting-started/04.build-your-first-hosted-app/your-first-hosted-app","content":"Let's create a simple hosted app, using only JavaScript (Vanilla). it’s there to provide you with the most basic features to get started with building an app from scratch, or tools to port your existing web app. The idea is also to avoid any dependency on external libraries or resources, but rather be self-contained. It contains: Web Activities - lots of examples and use casesWebAPIS in actionOffline support It’s available on GitHub: Code for KaiOS hosted AppLive demo of KaiOS hosted App How to use it The easiest way to get started, installing it and testing the various features, is to open the WebIDE Open Hosted APP with this URL and install either in device or simulator: https://firegnu.github.io/kaios-hosted-sample/manifest.webapp ## Running it locally Once you’re ready to get started developing, download the code and run it on a web server(Sample code use Github pages service), Using WebIDE to install the app in device or simulator . Note: make sure that the paths in the manifest file are valid on your localhost – bear in mind that these paths are relative to the root of the web site they are being served at. Also make sure to configure your server to send the manifest file with the right Content-type: application/x-web-app-manifest+json. This is, for instance, easy to set up in an .htaccess file in Apache: AddType application/x-web-app-manifest+json .webapp Need to notice Responsive Design Current KaiOS devices support QVGA resolutions in portrait (240x320 pixels) or landscape (320x240 pixels). If you want adapter your hosted app to KaiOS app, You should process carefully. You can refer more details about responsive design throughResponsive Design on Google Developer and Multiple Resolutions. Navigation Fow now,You can add \"cursor: true\" to manifest.webapp file for the navigation purpose(Emulated Cursor), Certainly you can use D-pad for navigationD-pad navigation. Offline support This Sample provided an .appcache file for enabling offline support (App Caching). To enable offline capabilities, just add this to the index.html file: <html manifest=\"manifest.appcache\"> Remember that the .appcache file has to be served as a text/cache-manifest file: AddType text/cache-manifest .appcache ","keywords":""},{"title":"Security access level","type":0,"sectionRef":"#","url":"docs/02.getting-started/02.main-concepts/security-access-level","content":"In this section you will have an overview of KaiOS security framework, which is designed to protect mobile devices from threats to the platform, apps, and data. KaiOS has implemented a comprehensive security model, integrated, and multi-layered security model that delivers best-of-breed protection against security risks to mobile phones. Platform Security The KaiOS platform uses a multi-layered security model that is designed to mitigate exploitation risks at every level. Front-line countermeasures are combined with a defense-in-depth strategy that provides comprehensive protection against threats. The KaiOS connects web-based applications to the underlying hardware. It is an integrated technology stack consisting of the following levels: Gaia: The suite of web apps that make up the user experience (apps consist of HTML5, CSS, JavaScript, images, media, and so on).Gecko: The application runtime layer that provides the framework for app execution, and implements the Web APIs used to access features in the mobile device.Gonk: The underlying Linux kernel, system libraries, firmware, and device drivers that everything runs on top of.The mobile device: The mobile phone running KaiOS. Gecko is the gatekeeper that enforces security policies designed to protect the mobile device from misuse. The Gecko layer acts as the intermediary between web apps (at the Gaia layer) and the phone. Gonk delivers features of the underlying mobile phone hardware directly to the Gecko layer. Web apps access mobile phone functionality only through the Web APIs, and only if Gecko allows the access request — there is no direct access, no “back door” into the phone. Gecko enforces permissions and prevents access to unauthorized requests. App Security KaiOS uses a defense-in-depth security strategy to protect the mobile phone from intrusive or malicious applications. This strategy employs a variety of mechanisms, including implicit permission levels based on an app trust model, sandboxed execution at run time, API-only access to the underlying mobile phone hardware, a robust permissions model, and secure installation and update processes. For technical details, refer to Application security. In KaiOS, all applications are web apps — programs written using HTML5, JavaScript, CSS, media, and other open web technologies (pages running within the browser are not referred to as web apps in this context). Because there are no binary (\"native\") applications installed by the user, all system access is mediated strictly through the Web APIs. Even access to the file system happens only through Web APIs and a back-end SQLite database — there is no direct access from apps to files stored on the SD card. KaiOS limits and enforces the scope of resources that can be accessed or used by an app, while also supporting a wide range of apps with varying permission levels. Mozilla has implemented tight control over what type of applications can access which APIs. For example, only certified apps (shipped with the phone) can have access to the Telephony API. The Dialer app has privileges to access the Telephony API in order to make phone calls, but not all certified apps can access this API. This prevents a situation, for example, in which an arbitrary third-party app gets installed, dials a pay-per-use phone number (900 and 910), and racks up a large cell phone bill. Other OEM apps might be selectively given access to the Telephony API, however. For example, an operator might provide a systems management application that allows a customer to manage their account, including the ability to phone the Operator’s billing or support office directly. Trusted and Untrusted Apps KaiOS categorizes apps according to the following types: Type\tTrust Level\tDescriptionCertified\tHighly Trusted\tSystem apps that have been approved by the Operator or OEM (due to risk of device corruption or risk to critical functionality). System apps and services only; not intended for third-party applications. This designation is reserved for just a small number of critical applications. Examples: SMS, Bluetooth, camera, system clock, telephony, and the default dialer (to ensure that emergency services are always accessible). Privileged\tTrusted\tThird-party apps that have been reviewed, approved, and digitally signed by an authorized KaiStore. Web (everything else)\tUntrusted\tRegular web content. Includes both installed apps (stored on the mobile phone) and hosted apps (stored remotely, with only an app manifest stored on the mobile phone). The manifest for hosted apps can be obtained through a KaiStore. An application’s trust level determines, in part, its ability to access mobile phone functionality. Certified apps have permissions to most Web API operations.Privileged apps have permissions to a subset of the Web API operations accessible to Certified apps.Untrusted apps have permissions to a subset of the Web API operations accessible to Privileged apps — only those Web APIs that contain sufficient security mitigations to be exposed to untrusted web content. Some operations, such as network access, are assumed to be an implicit permission for all apps. In general, the more sensitive the operation (for example, dialing a phone number or accessing the Contacts list), the higher the app trust level required to execute it. Note: for more information on the APIs available and their permission levels, consult App permissions. Principle of Least Permissions For web apps, the KaiOS security framework follows the principle of least permissions: start with the absolute minimum permissions, then selectively grant additional privileges only when required and reasonable. By default, an app starts with very low permissions, which is comparable to untrusted web content. If the app makes Web API calls that require additional permissions, it must enumerate these additional permissions in its manifest (described later in this document). Gecko will consider granting Web API access to an application only if the applicable privileges are explicitly requested in its manifest. Gecko will grant the requested permission only if the type of the Web App (certified, trusted, or web) is sufficiently qualified for access. Packaged and Hosted Apps Apps for KaiOS can be either packaged (stored on the mobile phone) or hosted (stored on a remote web server, with just a manifest stored on the mobile phone). There are some differences in the way in which security is managed for each. Nonetheless, packaged and hosted apps are both subject to application sandboxing, which is described later in this document. Packaged Apps A packaged app consists of a ZIP file containing application resources (HTML5, CSS, JavaScript, images, media), as well as a manifest that provides an explicit list of assets and their corresponding hashes. Certified and privileged apps must be packaged apps because the app manifest needs to be digitally signed. When a user obtains a packaged app, the ZIP file is downloaded onto the mobile phone, and the manifest is read from a known location inside the ZIP file. During the install process, app assets are verified and remain stored locally in the package. All explicit permissions are requested at runtime, showing the user the app's data usage intentions, and persisted by default. To refer to app resources in a packaged app, the URL begins with app: using the following format: app://identifier/path_within_zipfile/file.html where app:// represents the mount point for the ZIP file, and identifier is a UUID that is generated when the app is installed on the mobile phone. This mechanism ensures that resources referred to with an app: URL are contained in the ZIP file. The path within an app: is relative, so relative links to resources in the ZIP file are allowed. While packaged apps are primarily intended to be used for Certified or Privileged apps, regular web apps can also be packaged. However, they do not gain any increase in trust or permissions access simply because they are packaged. Hosted Apps Hosted apps are located on a web server and loaded via HTTP. Only the app manifest is stored on the mobile phone. Everything else is stored remotely. Certain APIs are available only to privileged and certified apps, which requires the app to be packaged due to signing requirements. Therefore, a hosted app will not have access to any of the Web API operations that require privileged or certified app status. From a security point of view, hosted apps work very much like normal websites. A hosted app is loaded by invoking a hard-coded, fully-qualified URL that points to the startup page in the root directory of the app on that web server. Once a hosted app is loaded, the mobile phone links to pages using the same URLs that are used when browsing the web site. Security Settings in the App Manifest The manifest can also contain other settings, including the following security settings: Field\tDescriptionpermissions\tPermissions required by the app. An app must list every Web API it intends to use that requires user permission. Most permissions make sense for privileged apps or certified apps, but not for hosted apps. Properties per API: description: A string specifying the intent behind requesting use of this API. Required. access: A string specifying the type of access required for the permission. Implicit permissions are granted at install time. Required for only a few APIs. Accepted values: read, readwrite, readcreate, and createonly. csp\tContent Security Policy (CSP). Applied to all pages loaded in the app. Used to harden the app against bugs that would allow an attacker to inject code into the app. If unspecified, privileged and certified apps have system-defined defaults. type\tType of application (web, privileged, or certified). KaiOS requires that the manifest be served with a specific mime-type application/x-web-app-manifest+json and from the same fully-qualified host name (origin) from which the app is served. This restriction is relaxed when the manifest app (and thus the app manifest) is same-origin with the page that requested the app to be installed. This mechanism is used to ensure that it's not possible to trick a website into hosting an application manifest. Security Infrastructure The following figure shows the components of the KaiOS security framework: Permission Manager: Gateway to accessing functionality in the Web API, which is the only access to the underlying hardware.Access Control List: Matrix of roles and permissions required to access Web API functionality.Credential Validation: Authentication of apps/users.Permissions Store: Set of privileges required to access Web API functionality.","keywords":""},{"title":"Testing your apps","type":0,"sectionRef":"#","url":"docs/02.getting-started/03.build-your-first-package-app/test-your-apps","content":"There are two ways to test your application. with the Real device and Simulator as alternative. WebIDE with real device Open your WebIDE to connect in your device Connect by remote runtime First, check if your device is on the list of adb devices command. Connect your device to your computer using a USB port, then run the following command from your terminal: $ adb root && adb forward tcp:6000 localfilesystem:/data/local/debugger-socket Note: You can change the port, changing the tcp value of the command (tcp:PORT). Then click in Remote runtime option Insert the IP and port (localhost:PORT) and click on OK button Click on the Open Package App option and open the folder with your project, after opening your project it will be added in the session my projects. Click on the play icon to open the app on the device Click the button with the wrench icon to open the debugging tools The basic tools available in your WebIDE are: The Inspector to examine and modify the HTML and CSS of a page. The Console for logs information associated with a web page and enables you to interact with a web page by executing JavaScript expressions in the context of the page. The JavaScript Debugger enables you to step through JavaScript code and examine or modify its state to help track down bugs. Style Editor enables you to view and edit all the stylesheets associated with a page, create new stylesheets from scratch and import existing stylesheets and apply them. The Scratchpad provides an environment for experimenting with JavaScript code. You can write, run, and examine the results of code that interacts with the web page. Just as in a web page, any changes you make in the tools are visible immediately in the app, but are not persistent. Conversely, any changes you make in the editor pane can be saved straight back to disk, but are not visible without restarting the app. Simulator as alternative The simulator lets you run Gaia and Web apps in a Gecko-based environment somewhat similar to an actual device, for more details and to download the simulator consult the page of the simulator. Running and debugging apps Open the simulator Click the simulator option on the right side of the screen Click on the Open Package App option and open the folder with your project Your project will open, displaying a tree with the files Click on the play icon to open the app on simulator Click the button with the wrench icon to open the debugging tools","keywords":""},{"title":"D-Pad navigation","type":0,"sectionRef":"#","url":"docs/03.core-developer-topics/dpad-navigation","content":"On non-touch devices, the preferred method of app navigation is to use the available hardware keys. KaiOS feature phones generally come up with 4 directional arrow keys and confirmation keys. The steps below are guidelines on how to have your webapp respond to directional keys instead of using a cursor or touch controls. Step 1 Use same class to group elements and make them a navigation candidate pool. <div class=\"items\">1</div> <div class=\"items\">2</div> <div class=\"items\">3</div> <div class=\"items\">4</div> <input type=\"text\" class=\"items\"/> <a href=\"more.html\" class=\"items\">more..</a> Step 2 Make every element focusable HTMLAnchorElement/HTMLAreaElement with an href HTMLInputElement/HTMLSelectElement/HTMLTextAreaElement/HTMLButtonElement without disabled HTMLIFrameElement Any element with a tabindex e.g.: <div class=\"items\" tabIndex=\"1\"></div> Step 3 Let target element execute focus() to become active element. After calling focus you can confirm it via document.activeElement. Step 4 Active element listen keydown or keyup event: document.activeElement.addEventListener('keydown', handleKeydown); Step 5 Handle ArrowUp, ArrowRight, ArrowLeft and ArrowDown keys: function handleKeydown(e) { switch(e.key) { case 'ArrowUp': nav(-1); break; case 'ArrowDown': nav(1); break; case 'ArrowRight': nav(1); break; case 'ArrowLeft': nav(-1); break; } } Step 6 Find next target element: function nav (move) { const currentIndex = document.activeElement.tabIndex; const next = currentIndex + move; const items = document.querySelectorAll('.items'); const targetElement = items[next]; targetElement.focus(); } ","keywords":""},{"title":"Softkeys","type":0,"sectionRef":"#","url":"docs/03.core-developer-topics/softkeys","content":"The software key appears at the bottom of the screen, which corresponds to the center, right, and left hardware keys. Each key may or may not appear depending on the availability of features. Structure This is a simple structure of a softkey use, see the UI Components section for the style example of the component. <body id=\"app\"> <!-- Your app's code --> <footer class=\"softkey\"> <div id=\"softkey-left\">Back</div> <div id=\"softkey-center\">SELECT</div> <div id=\"softkey-right\">Options</div> </footer> </body> Actions User actions on the keyboard can lead to a new state of your application. For more understanding see the simple example below, where you can hear the device keyboard actions. const softkeyCallback = { left: function() { console.log('You click on SoftLeft') }, center: function() { console.log('You click on Enter') }, right: function() { console.log('You click on SoftRight') } }; function handleKeyDown(evt) { switch (evt.key) { case 'SoftLeft': // Action case press left key softkeyCallback.left(); break; case 'SoftRight': // Action case press right key softkeyCallback.right(); break; case 'Enter': // Action case press center key softkeyCallback.center(); break; } }; document.addEventListener('keydown', handleKeyDown); In case your application needs to update the softkey, according to a state, view or navigation, this can be done using a function like the following example: function updateSoftKey(props) { const keys = Object.keys(props); keys.forEach(function(key) { const button = document.getElementById('softkey-' + key); button.textContent = props[key].label; softkeyCallback[key] = props[key].callback; }); } /* This function is call that way */ updateSoftKey({ left: { label: 'Left text', callback: function(){ /* Code */ } }, center: { label: 'Center text', callback: function(){ /* Code */ } }, right: { label: 'Right text', callback: function(){ /* Code */ } } }); ","keywords":""},{"title":"Caching","type":0,"sectionRef":"#","url":"docs/03.core-developer-topics/caching","content":"KaiOS supports standard and non-standard web cache. Standard The Cache interface provides a storage mechanism for Request/Response objects. Non-standard HTML5 provides application caching that lets web applications run offline. The application cache mechanism allows offline browsing, increases loading speed, and reduces server load.","keywords":""},{"title":"Action icon","type":0,"sectionRef":"#","url":"docs/04.design-guide/action-icon","content":"Action icons are used to represent common actions in your app. KaiOS provides many common action icons, such as add, cancel, search, next, and so on. We highly recommend using these icons in your apps. If none of the standard action icons meet your app’s needs, you can design your own action icons by following the design principles in the following sections. Size & format An action icon must be 32 x 32 pixels in SVG format. Always keep free space (5 pixels) around the icon. However, the icon can be extended into free space due to visual weight balance. Normal & focus states Each icon has normal and focussed states, differentiated by their color compositions. Avoid using the same color for both states so they are easily recognizable. Style The icon should be two-dimensional and filled with a solid color. Avoid decorative details or using visual effects like drop shadow, gradient, and glow. Also, ensure that the size of your icon is readable and clear on a small-sized display. Shape An action icon should represent its desired function as simply and clearly as possible, while avoiding overly complex or compound ideas, such as intricate details or thin outline strokes.","keywords":""},{"title":"Network State Changes","type":0,"sectionRef":"#","url":"docs/03.core-developer-topics/network-state-changes","content":"In order to build a good offline-capable web application, you need to know when your application is actually offline. You also need to know when your application has returned to an 'online' status again. Effectively, the requirements break down as follows: You need to know when the user comes back online so that you can re-synchronize with the server.You need to know when the user is offline so that you can queue your server requests for a later time. It is this process that online/offline events help to simplify. NavigatorOnLine navigator.onLine navigator.onLine is a property that maintains a true/false value (true for online, false for offline). This property is updated whenever the user switches into \"Offline Mode\". Additionally, this property should update whenever a browser is no longer capable of connecting to the network. According to the specification: The navigator.onLine attribute must return false if the user agent will not contact the network when the user follows links or when a script requests a remote page (or knows that such an attempt would fail)... online and offline events You can register listeners for these events in a few familiar ways: Using addEventListener on the window, document, or document.bodyBy setting the .ononline or .onoffline properties on document or document.body to a JavaScript Function object. (Note: using window.ononline or window.onoffline will not work for compatibility reasons.)By specifying ononline=\"...\" or onoffline=\"...\" attributes on the <body> tag in the HTML markup. Example window.addEventListener('load', function() { let status = document.getElementById(\"status\"); let log = document.getElementById(\"log\"); function updateOnlineStatus(event) { let condition = navigator.onLine ? \"online\" : \"offline\"; status.className = condition; status.innerHTML = condition.toUpperCase(); log.insertAdjacentHTML(\"beforeend\", \"Event: \" + event.type + \"; Status: \" + condition); } window.addEventListener('online', updateOnlineStatus); window.addEventListener('offline', updateOnlineStatus); }); Network Information The Network Information API provides information about the system's connection in terms of general connection type (e.g., 'wifi', 'cellular', etc.). This can be used to select high definition content or low definition content based on the user's connection. The entire API consists of the addition of the NetworkInformation interface and a single property to the Navigator interface: Navigator.connection. Examples Detect connection changes This example watches for changes to the user's connection. var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection; var type = connection.type; function updateConnectionStatus() { console.log(\"Connection type changed from \" + type + \" to \" + connection.type); } connection.addEventListener('change', updateConnectionStatus); Preload large resources The connection object is useful for deciding whether to preload resources that take large amounts of bandwidth or memory. This example would be called soon after page load to check for a connection type where preloading a video may not be desirable. If a cellular connection is found, then the preloadVideo flag is set to false. For simplicity and clarity, this example only tests for one connection type. A real-world use case would likely use a switch statement or some other method to check all of the possible values of NetworkInformation.type. Regardless of the type value you can get an estimate of connection speed through the NetworkInformation.effectiveType property. let preloadVideo = true; var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection; if (connection) { if (connection.type === 'cellular') { preloadVideo = false; } } Interfaces NetworkInformation Provides information about the connection a device is using to communicate with the network and provides a means for scripts to be notified if the connection type changes. The NetworkInformation interfaces cannot be instantiated. It is instead accessed through the Navigator interface.","keywords":""},{"title":"App Permissions","type":0,"sectionRef":"#","url":"docs/03.core-developer-topics/permissions","content":"The permissions field in the app manifest controls the app's access to various sensitive APIs on the device (sometimes called WebAPIs). The permissions are described in the following tables. The three levels of permission, in brief, are: Web apps: These only have a basic level of permissions, and don't have access to privileged or internal APIs.Privileged apps: These have all the permissions of web apps plus more. Hosted apps can't be privileged — they must be packaged apps. Hosted app and privileged app permissions Manifest permission\tAPI name\tMinimum app type required\taccess property\tDefault grantedalarms\tAlarm\thosted\tnone\tAllow audio-capture\tgetUserMedia, Web Speech API\thosted for getUserMedia, privileged for Web Speech API\tnone\tPrompt for all installed App types for getUserMedia, Allow for Web Speech API. audio-channel-alarm\tAudioChannels\tprivileged\tnone\tAllow audio-channel-content\tAudioChannels\thosted\tnone\tAllow audio-channel-normal\tAudioChannels\thosted\tnone\tAllow audio-channel-notification\tAudioChannels\tprivileged\tnone\tAllow browser\tBrowser\tprivileged\tnone\tAllow camera\tCamera\tprivileged in KaiOS certified\tnone\tPrompt for all installed App types.` contacts\tContacts\tprivileged\treadonly, readwrite, readcreate, or createonly\tPrompt for all installed App types. desktop-notification\tNotification\thosted\tnone\tPrompt for Web content. Allow for all installed App types. device-storage:music\tDevice Storage\tprivileged\treadonly, readwrite, readcreate, or createonly\tPrompt device-storage:pictures\tDevice Storage\tprivileged\treadonly, readwrite, readcreate, or createonly\tPrompt device-storage:sdcard\tDevice Storage\tprivileged\treadonly, readwrite, readcreate, or createonly\tPrompt device-storage:videos\tDevice Storage\tprivileged\treadonly, readwrite, readcreate, or createonly\tPrompt fmradio\tFM Radio\thosted\tnone\tAllow geolocation\tGeolocation\thosted\tnone\tPrompt (even for certified Apps) input\tKeyboard\tprivileged\tnone\tAllow mobileid\tMobile identity\tprivileged\tnone\tPrompt mobilenetwork\tMobile Network\tprivileged\tnone\tAllow moz-firefox-accounts\tFirefox Accounts\tprivileged\tnone\tPrompt for all installed App types. nfc\tNFC API\tprivileged\tnone\tAllow nfc-share\tNFC API\tprivileged\tnone\tAllow nfc-read, nfc-write\tNFC API\tWas certified/internal at this stage in development.\tnone\tAllow push\tSimple Push\thosted\tnone\tAllow speech-recognition\tWeb Speech API\tprivileged\tnone\tAllow systemXHR\tSystemXHR\tprivileged\tnone\tAllow tcp-socket\tTCP Socket\tprivileged\tnone\tAllow video-capture\tGetUserMedia\thosted\tnone\tPrompt for all installed App types. Certified app permissions Manifest permission\tAPI name\tMinimum app type required\taccess propertyattention\tAttention Screen\tcertified\tnone audio-channel-ringer\tAudioChannels\tcertified\tnone audio-channel-telephony\tAudioChannels\tcertified\tnone audio-channel-publicnotification\tAudioChannels\tcertified\tnone background-sensors\tBackground Sensor\tcertified\tnone backgroundservice (Deprecated)\tBackground Services\tcertified\tnone bluetooth certified\tnone browser:embedded-system-app\tBrowser\tcertified\tnone camera\tCamera\tcertified\tnone cellbroadcast certified\tnone No permission needed, but datastores-access/datastores-owned needs to be set in the manifest (see Data Store API Manifest fields.)\tData Store\tcertified\tdatastores-access/ datastores-owned device-storage:apps\tDevice Storage\tcertified\tread embed-apps\tEmbed Apps\tcertified\tnone idle\tIdle\tcertified\tnone mobileconnection\tMobile Connection\tcertified\tnone network-events\tNetwork Events\tcertified\tnone networkstats-manage\tNetwork Stats\tcertified\tnone open-remote-window\tOpen out-of-process windows\tcertified\tnone permissions\tPermissions (Firefox OS)\tcertified\tnone power\tPower Management\tcertified\tnone presentation-device-manage\tPresentation\tcertified\tnone settings\tSettings\tcertified\treadonly or readwrite sms\tWebSMS\tcertified\tnone telephony\tWeb Telephony\tcertified\tnone time\tTimeManager\tcertified\tnone voicemail\tVoicemail\tcertified\tnone webapps-manage\tOpen Webapps\tcertified\tnone wifi-manage\tWiFi Management\tcertified\tnone wappush\tWAP Push\tcertified\tnone","keywords":""},{"title":"Launcher Icon","type":0,"sectionRef":"#","url":"docs/04.design-guide/launcher-icon","content":"The launcher icon is the first visual expression of your app, as it directly and, hopefully, effectively communicates its main purpose to the user. Unified graphic elements allow you to create simple, intuitive, consistent icons that reflect product characteristics and quality. It can also help your app stand out from other apps. The design principles in the following pages serve as a guide for icon design. KaiOS App Icon Template resource sketch file is here for you to design your KaiOS app icon. It includes screenshot preview and helps quickly export multiple icon sizes. The resource file requires Sketch 51 or higher version. Sizes Baseline icon Every app must supply a baseline icon at 56 x 56 pixels for use on the All Apps grid and list views, the KaiStore, Notices, and throughout the system once the app has been installed. Large icon Every app should also provide a larger icon at 112 x 112 pixels (you can make the baseline icon 2x bigger proportionally) for display in the All Apps single view and the app launch screen. Image Size (px)\tFile Name\tUse For56 x 56 (Baseline)\tAppName_56.png\tAll Apps (grid view) All Apps (List view) KaiOS Store Notices In-app Notices 112 x 112\tAppName_112.png\tAll Apps (Single view) Launch Screen Shape The app icon image is provided at 56 x 56 pixels in 24-bit png format. Icon shape is limited to 46 x 46 pixels round shape or 44 x 44 pixels square shape which casts a soft shadow around it. Usage Normal & focus states Each icon has normal and focussed states, differentiated by color composition. Avoid using the same color for both states so they are easily distinguishable. Appropriate icon size It is important to keep the icon design area between 44x44 and 46x46 pixels; an oversized icon will obstruct the view while an app is being selected. Concise icon style All colors should be solid color elements with minimal flair; three- dimensional designs and textures will cause the icons to become overly complex and lead to inconsistencies on low resolution devices. Transparency of icon The launcher icon and focused color background should not be transparent, as it will expose the wallpaper and make it hard to recognize the icon. Focus State Color your own Our unique transition design animates when an app is selected by users. It helps users stay focused while navigating to the app they are looking for. The focus color in the All Apps view can be changed individually and customized to suit any brand need, as shown in the following illustration.","keywords":""},{"title":"Basic Navigation","type":0,"sectionRef":"#","url":"docs/04.design-guide/basic-navigation","content":"Emulated Cursor Navigation You can use Emulated Cursor Navigation，Just add this line to manifest.webapp。 \"cursor\": true List View A list view typically contains items listed vertically where we can press UP and DOWN keys to navigate. Since a list view might accommodate many items, continuous key actions — the events that happen after a button has been pressed — and a list view loop are introduced to improve the experience. When we press and hold one of the D-pad keys, key events are dispatched continuously, from slow to fast. This feature allows us to scroll a list without pressing the D-pad numerous times. We can start slow to target accuracy, then speed up for efficiency. At the end of a list, pressing DOWN will navigate to the top. This list view loop also applies when you press UP at the beginning of the list. Grid View A grid view displays items in a two-dimensional grid, where we can press the D-pad keys to navigate. We’ve introduced Z-navigation and no-row-skipping to improve this experience. We usually have to use four D-pad keys to navigate a grid view since it has only two dimensions. With Z-navigation, pressing the RIGHT key at item three brings you to item four instead of item one. This allows users to navigate through all items by using only the LEFT and RIGHT keys. When you press the DOWN key at item nine, it goes to 11 instead of item three. Similarly, pressing the UP key at item three brings you to item 11 instead of item nine. No-row-skipping helps users not to miss the last row which is especially useful when that row falls outside of the screen. Tab View When an app has a lot of content that needs to be organized by grouping, tab view is the appropriate solution.","keywords":""},{"title":"Storage","type":0,"sectionRef":"#","url":"docs/03.core-developer-topics/storage","content":"There is no limit to application size or storage size, except for physical storage constraints. App size range depends on the complexity of the app. Below some internal KaiOS apps’ sizes for your reference: Calculator: 200KBSettings: 10MB Data Storage The aim of this guideline is to provide information for app developer saving data in a better way due to smart feature phone is not like smart phone usually with large data storage. To prevent user hit storage full issue with unexpected scenario, KaiOS needs app developer’s support to follow the guideline below for better user experience. Media file should be saved in media storage, NOT in application data as indexedDB. KaiOS system will block DB writing once remaining data storage size is lower than 30MB, so each app must do error handling. (the number may be difference based on device) App developer should handle the content carefully and set some limitation especially for low storage devices. For example, to limit the total size of content such as the number of messages to 10000 or contact number to 1000, once the number is close to the limit, to show the error message or overwrite the older data. KaiOS provides a preventive action to keep device working normal as usual when storage is full by large size of indexedDB. It will perform data storage clean up by deleting old, removable indexedDB. To delete the object properly, KaiOS needs app to mark indexedDB when creating DB for those data which is considered “can be deleted” while storage full. App Developer should be aware of: * The storage type for these IDB is \"temporary\" which will be all removed when available space is lower than a threshold. * For IDB guideline, developer could refer [this link](https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase) since the rest of usage is the same as normal database. * App should support error handling and upgrade situation when the indexedDB is removed. * Method to Create/Delete removable indexedDB as following: To request opening a connection to a database that able to be deleted when space needed: Syntax: var IDBOpenDBRequest = indexedDB.open(name, { version, storageType }); var db; var DBOpenRequest = indexedDB.open('MyTestDatabase'); DBOpenRequest.onerror = function(event) { alert(\"Why didn't you allow my web app to use IndexedDB?!\"); }; DBOpenRequest.onsuccess = function(event) { db = event.target.result; }; To request deletion of a database which in temporary storage type: Syntax: var IDBOpenDBRequest = indexedDB.deleteDatabase(name, { version, storageType }); var DBDeleteRequest = window.indexedDB.deleteDatabase('toDoList', { version: 4, storage: 'temporary' }); DBDeleteRequest.onerror = function(event) { console.log('Error deleting database.'); }; DBDeleteRequest.onsuccess = function(event) { console.log('Database deleted successfully'); console.log(event.result); // should be undefined }; For small size records and application data, the Web Storage APIprovides access to session storage or local storage, allowing you to add, modify, or delete stored items. Session storage: Window.sessionStorageLocal storage: Window.localStorage Device Storage For access to specific files in a specific storage area on the device, the DeviceStorage interface is used. navigator.getDeviceStorage() will return a DeviceStorage object which you can then use to access content of the storage area. MDN Resource You can refer Using IndexedDB for more information.","keywords":""},{"title":"Multiple Resolutions","type":0,"sectionRef":"#","url":"docs/03.core-developer-topics/supporting-multiple","content":"Applications on KaiOS should adapt to different resolutions. Current KaiOS devices support QVGA resolutions in portrait (240x320 pixels) or landscape (320x240 pixels). Media query The best and easiest way to develop a responsive UI on KaiOS is by making use of CSS media queries. The following are examples of media queries considering device orientation, with KaiOS supported resolutions in mind: /* KaiOS portrait devices (240x320) */ @media only screen and (orientation : portrait) { /* styles */ } /* KaiOS landscape devices (320x240) */ @media screen and (orientation: landscape) { /* styles */ } If you need more help, make use of some the below tips to build your responsive KaiOS app: Using media queries The building blocks of responsive design","keywords":""},{"title":"Manifest","type":0,"sectionRef":"#","url":"docs/02.getting-started/02.main-concepts/manifest","content":"The manifest.webapp file provides important information about the app, such as version, name, description, icon location, locale strings, domains the app can be installed from, and much more. Most importantly, it contains a list of APIs that your app needs. This allows users to make informed decisions about apps before installing them. Your app's manifest.webapp file should be placed in the root of your app directory, and contain a simple JSON structure. A simple App Manifest JSON looks like this: { \"version\": \"1.0.0\", \"name\": \"KaiOS App\", \"description\": \"A file simple example manifest.webapp\", \"type\": \"web\", \"launch_path\": \"/your/repository/index.html\", \"icons\": { \"56\": \"/your/repository/icons/ic_Appname_56.png\", \"112\": \"/your/repository/icons/ic_Appname_112.png\" }, \"developer\": { \"name\": \"Your Name\", \"url\": \"http://yourawesomeapp.com\" }, \"locales\": { \"en-US\": { \"name\": \"KaiOS App\", \"subtitle\": \"Short description for the user\", \"description\": \"Brief description of your app\" } }, \"default_locale\": \"en-US\" } Required fields The fields in your manifest can be in any order. Fields in the manifest other than the ones listed below will be ignored. name Note: Required for all app manifests. A human-readable name for the app. Maximum length is 20 characters. If you change the name of your app after distribution, the name will not be updated for any existing installations. \"name\": \"The Open Web!\" version A specialized string that represents the version of the app. Must be integers separated by dots. \"version\": \"1.2.0\" description Note: Required for all app manifests. A human-readable description for the app. It should be a short and strong message. \"description\": \"My elevator pitch goes here\" icons Note: One icon sized 56×56 is required for all app manifests. One icon sized 112×112 is recommended for all app manifests. A map of icon sizes to URIs of the icons. Remember that internal paths to icons must be absolute from the app's origin, while paths to externally hosted icons must be fully qualified. Icons must be square and in .png format. Icons should not have solid backgrounds that extend to all four corners of the icon. For more details about app icon check Launcher Icon section in Design Guide. \"icons\": { \"56\": \"/img/ic_Appname_56.png\", \"112\": \"/img/ic_Appname_112.jpg\" } developer Note: Only the name is required for all app manifests. name: The name of the developer. Required for all app manifests.url: The URL of a website containing information about the app's developer. Optional. \"developer\": { \"name\": \"The Open Web!\", \"url\": \"http://www.mywebapp.com\" } localesA map of one or more language-specific overrides of the field values in your app manifest. Keys for locales use the same language tags as for default_locale (RFC 4646). \"locales\": { \"it-IT\": { \"name\": \"L'Open Web\", \"description\": \"Eccitante azione di sviluppo web open!\" }, \"de-DE\": { \"name\": \"Der Open Web\", \"description\": \"Spannende offene Web-Entwicklung-Action!\" } } default_locale A language tag (RFC 4646) that defines the language you used in the field values of your app manifest. Please refer to the list below of language identification codes used in the KaiOS system. We strongly suggest to use the same language identification codes throughout to avoid misalignment issues or incorrect results when users change language settings in the system: af-ZA\tAfrikaans ar-SA\tعربي az-Latn-AZ\tAzərbaycan be-BY\tБеларуская bg-BG\tБългарски bn-IN\tবাংলা (IN) bn-BD\tবাংলা-BD bs-BA\tBosanski cs-CZ\tČesky da-DK\tDansk de-DE\tDeutsch el-GR\tΕλληνικά en-GB\tEnglish (GB) en-US\tEnglish (US) es-US\tEspañol (US) et-EE\tEesti es-ES\tEspañol (ES) fa-IR\tفارسی (IR) fi-FI\tSuomi fil-PH\tTagalog fr-CA\tFrench (CA) fr-FR\tFrançais (FR) he-IL\tעברית hi-HI\tहिन्दी hr-HR\tHrvatski hu-HU\tMagyar hy-AM\tՀայերեն id-ID\tBahasa Indonesia is-IS\tÍslenska it-IT\tItaliano It-LT\tLietuvių ka-GE\tქართული kk-KZ\tҚазақша km-KH\tភាសាខ្មែរ lo-LA\tລາວ lv-LV\tLatviešu mk-MK\tМакедонски mo-RO\tМолдовеняскэ ms-MY\tMelayu nb-NO\tNorsk (bokmål) ne-IN\tनेपाली nl-NL\tNederlands pl-PL\tPolski ps-AF\tپښتو pt-BR\tPortuguês (do Brasil) pt-PT\tPortuguês (Europeu) ro-RO\tRomână ru-RU\tРусский si-LK\tසිංහල sk-SK\tSlovenčina sl-SI\tSlovenščina sq-AL\tShqip sr-Latn-CS\tСрпски/Srpski sv-SE\tSvenska sw-ZA\tKiswahili ta-IN\tதமிழ் th-TH\tไทย tr-TR\tTürkçe uk-UA\tУкраїнська ur-PK\tاردو uz-Cyrl-UZ\tO'zbek vi-VN\tTiếng Việt xh-ZA\tisiXhosa zh-CN\t中文 (简体) zh-HK\t中文-HK zh-TW\t中文-TW zu-ZA\tisiZulu as-IN\tঅসমীয়া und-bod\tबोड़ो doi-IN\tडोगरी gu-IN\tગુજરાતી kn-IN\tಕನ್ನಡ ks-IN\tکأشُر kok-IN\tकोंकणी mai-IN\tमैथिली ml-IN\tമലയാളം mni-IN\tমণিপুরী mr-IN\tमराठी or-IN\tଓଡ଼ିଆ pa-IN\tਪੰਜਾਬੀ sa-IN\tसंस्कृत sat-IN\tᱥᱟᱱᱛᱟᱞᱤ sd-IN\tसिन्धी te-IN\tతెలుగు ko-KR\t한국어\" For example, if your app uses English, it's default_locale would be: \"default_locale\": \"en-US\" type The app's type, which defines its level of access to sensitive device APIs. If you do not define type, it will default to web as the type. web: A regular hosted app. This type has the least access to APIs. privileged: An authenticated app that has been approved by an app store such as the KaiStore. This type has greater access to APIs than a web app. subtitleYour app’s subtitle appears below your app name throughout the KaiStore. A subtitle is a short and striking or memorable message, and is intended to summarize your app in a concise phrase. A compelling subtitle can encourage product page views and installs. The maximum length of a subtitle is 40 characters. categoriesYour app's categories represent different categories that your app should be belongs to in the KaiStore. We have defined different type of Store apps. You must choose at least one type for your app. social gamesutilitieslife styleentertainmenthealthsportsbook/reference \"categories\": [ \"health\", \"sports\" ], Optional fields The following fields are optional. short_nameA human-readable name for the app. Can differ from name field. bgsA map of background images sizes to URIs of the icons. \"bgs\": { \"56\": \"/img/ic_Appname_56.png\", \"112\": \"/img/ic_Appname_112.jpg\" } launch_pathThe path within the app's origin that is loaded when the app starts. Specifies the starting point of the content local to the zip file containing the packaged app. For example, if the launch_path is /mywebapp/index.html, the app will open the file at /mywebapp/index.html when the app is launched. Tips: If your app is stored in the root of a Web server, for example mywebapp.github.com/, then launch_path must be set to /. If your app is stored in a subdirectory, for example mymarket.github.com/mywebapp/, then launch_path must be set to /mywebapp/. \"launch_path\": \"/index.html\" origin Note: Applies only to privileged or internal (certified) packaged apps. Packaged apps have a special internal protocol of app://UUID where UUID is a string unique to each device the app is installed on. UUID is not easily accessible at this time. The origin field allows you to replace this UUID value with a single domain name that will be used by each installed app. Remember: domain name must start with app://, and you must be the owner of the domain name you specify. \"origin\": \"app://mywebapp.com\" permissionsThe user permissions for sensitive device APIs that your app needs, for example, access to the user's Contacts. See a full list of API permissions/features. Each permission requires: name: the name of the permission description: the reason why your app needs to use this permission access: the level of access required, options being readonly, readwrite, readcreate, and createonly. Only a few APIs need this, for example Data Store. For example, here's a manifest entry for an app that needs permission to use the device's contacts and alarms. \"permissions\": { \"contacts\": { \"description\": \"Required for autocompletion in the share screen\", \"access\": \"readcreate\" }, \"alarms\": { \"description\": \"Required to schedule notifications\" } } Note: If an app tries to use one of these APIs without a corresponding entry in the permissions field, it will fail to run. There are many APIs, some of whom require the app type to be privileged or internal (certified). For example, systemXHR requires the type field to be set to privileged in order to work: \"type\": \"privileged\", \"permissions\": { \"systemXHR\": { \"description\": \"Required to download podcasts.\" } } fullscreenA control that tells the runtime whether or not to launch the app in full-screen mode. \"fullscreen\": \"true\" datastores-owned Note: Applies only to privileged/certified apps to be installed on KaiOS. When making use of the Data Store API, the app that owns the data store MUST include the datastores-owned field in its manifest to claim ownership, for example: \"datastores-owned\": { \"myData\": { \"access\": \"readwrite\", \"description\": \"my data store\" } } You can include multiple properties to represent different data stores, and each one can use an access of readonly/readwrite to specify whether the data store can be read/modified by other applications. A description is also included to describe the purpose of the data store. datastores-access Note: Applies only to privileged/certified apps to be installed on KaiOS. When making use of the Data Store API, any non-owner app that wants access to the the data store MUST include the datastores-access field in its manifest, for example: \"datastores-access\": { \"myData\": { \"access\": \"readwrite\", \"description\": \"Read and modify my data store\" } } Without this field being specified, the default behaviour is \"no access\". Again, multiple properties can be included if you want to access multiple data stores, and an access of readonly or readwrite can be set to declare what access type is needed by the app. messages Note: Applies only to apps to be installed on KaiOS. The system messages you allow the app to capture, and the pages in your app that will display when those messages occur. Below is an example from the KaiOS Dialer app. Every time an incoming call comes in (system message: telephony-new-call), the device shows the dialer's keypad (URL: /dialer/index.html#keyboard-view). \"messages\": [ { \"alarm\": \"/index.html\" } { \"notification\": \"/index.html\" } { \"telephony-new-call\": \"/dialer/index.html#keyboard-view\" } ] redirects Note: Applies only to privileged/certified apps that are to be installed on KaiOS. The internal URLs your app uses to handle external processes. For example, your app might use Facebook OAuth authentication to get a user's contacts. When the authentication is finished, the server usually redirects back to a URL that you control. Because packaged apps are not hosted on the web, a packaged app does not have a valid URL that can be redirected to. So you use the redirects field to redirect an external URL to an internal app URL. In the scenario above, the redirects field will look like this: \"redirects\": [ { \"from\": \"http://facebook.com/authentication/success.html\", \"to\": \"/app/main_interface.html\" } ] The scope of the redirects declared by redirects is limited to the app that declares them. That makes it so that several apps can redirect the same public URL to their own local resources, and it also prevents global hijacking of public URLs by an application. activitiesA set of Web Activities that your app supports (full list). It's structured like so: Each property in this field is an activityActivity names are free-form textEach activity is represented by an object For example, here's an entry with one activity named share. \"activities\": { \"share\": { \"filters\": { \"type\": [ \"image/png\", \"image/gif\" ] }, \"href\": \"foo.html\", \"disposition\": \"window\", \"returnValue\": true } } The object for the share activity in the example has filters, href, disposition and returnValue properties. These are described in Activity handler description. precompileThe path to JavaScript files containing asm.js code that you want compiled at install time. Compilation at install time makes the installation process longer, but reduces the time it takes to start up an app. \"precompile\": [ \"game.js\", \"database.js\" ] orientationThe positioning at which the application will stay locked. Illustration of possible values: Value\tApp will stay locked toportrait-primary portrait-secondary portrait landscape-primary landscape-secondary landscape \"orientation\": [ \"landscape-primary\" ] cspThis field can be used to define a Content Security Policy (CSP) that is applied to all pages in the app. The policies you can add to a CSP are listed in CSP policy directives, and for an app you'll need to include them in a line like so: \"csp\" : \"default-src *; script-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline'\" The default policies applied to KaiOS privileged and internal/certified apps are as follows: Privileged CSP default-src *; script-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' Certified/Internal CSP default-src *; script-src 'self'; object-src 'none'; style-src 'self' These defaults can’t be overridden, only added to, i.e. the CSP policy in the manifest can only make the actual CSP applied more restrictive in the case of privileged/internal apps. Serving manifest Note: This is applied to 'hosted app URL' The app manifest must be served from the same origin that the app is served from. The manifest should be stored with a file extension of .webapp. App manifests must be served with a Content-Type header of application/x-web-app-manifest+json. This is currently enforced by the KaiStore. The KaiStore only checks this if the origin of the page where the user triggers the install is different from the origin of the app itself. You don't need other headers such as Content-Security-Policy and X-UA-Compatible. Manifests can be served over SSL to mitigate certain classes of attacks. You can also serve the manifest with HTTP compression. The manifest should not be cached. The manifest must be in UTF-8 encoding in order for the app to be submitted to the KaiStore. It is recommended that you omit the byte order mark (BOM). Other encodings can be specified with a charset parameter on the Content-Type header. User Agents when possible should meaningfully message the site identity and TLS status when prompting a user to install an app. China Type Approval (CTA), and how does it affect your apps on the KaiStore According to the new regulation, when the users in China install an app from the KaiStore, the app needs to pop up a confirmation window to let users accept or deny the operation like data connection, Wi-Fi connection, access call log. If your app uses KaiAds, Analytics, leaderboards, or any features that need connection to the internet, then you will be required to update the app. Please modify the manifest file of your app in according to the below conditions: If your apps do not need a network connection or call log request, there is no need to make any modifications. Privilege app in Store that needs network connection or call log, should add below permissions in the app’s manifest.webapp file. \"permissions\": { \"mobiledata\":{}, \"wifidata\":{}, \"calllog\":{} } Web and Hosted apps in Store that needs a network connection, it should add the below permissions in the app’s manifest.webapp file. \"Permissions\": { \"mobiledata\":{}, \"wifidata\":{} }, Certified app does not need any modifications The affected OS versions are KaiOS/2.5.2.1 and KaiOS/2.5.4.1 which will be used in the China market, and in case your apps do not have the requested permissions, they won’t be published in these two OS versions.These changes do not affect any of the existing devices and users.","keywords":""},{"title":"Hosted App","type":0,"sectionRef":"#","url":"docs/04.design-guide/hosted-app","content":"This article provides an introduction to some behaviors of hosted app in KaiOS. Cursor If a hosted app needs cursor, developer can set cursor as true to enable OS provided cursor. Cursor behaviors are similar to Browser app: Press D-Pad to move the cursor. Press CSK to perform mouse click. Status Bar A hosted app can hide the status bar by setting fullscreen as true. Address Bar There is no address bar for hosted app. Developers can make it by themselves. Browser app has address bar. Loading Progress Bar By default OS doesn’t show loading progress bar for hosted app. Developers can make loading progress bar for a hosted app by themselves, or set loading progress bar as true to show OS provided loading progress bar. Software Key No OS provided software key bar for hosted app. Developers can make it by themselves. Pressing LSK: No predefined functions. App can listen to its key event.Pressing CSK: Perform mouse click.Pressing RSK: No predefined functions. App can listen to its key event. Browser app has software key bar. Pressing LSK: Start using search bar.Pressing CSK: Perform mouse click.Pressing RSK: Show Options menu. Shortcut Key Shortcut keys are not available in hosted app. Developers can make it by themselves. Browser app has shortcut keys by default when a page is loaded. Input When entering text edit mode, focus on the input and show OS-provided software key bar for text inputting. Pressing CSK: Send Enter key event.Pressing RSK: Leave text edit mode (blur from the input) and hide the text inputting software key bar. Full-Screen Video When entering full-screen video mode, hide cursor and show OS-provided softkey bar. Pressing LSK/BACK: Leave full-screen mode.Pressing CSK: Play/Pause.Pressing UP/DOWN: Volume up/down.Pressing LEFT/RIGHT: Jump 10 sec backward/forward. Error Handling When trying to change pages without internet connection, show this error message with 3 buttons. Error title and message change according to different errors. Select “Settings”: Go to connection settings.Select “Refresh”: Refresh the page.Select “Quit”: Quit the app directly. Volume App has ability to call vol up/down api to change system volume. When calling that api, OS will show volume panel (auto-detecting volume channel and show the corresponding panel) and change the volume levels, and then disappear after 2 sec timeout. However, app should handle when/how to change the volume. For example, pressing some key to vol up, app should listen the key by itself.","keywords":""},{"title":"Packaged or hosted App","type":0,"sectionRef":"#","url":"docs/02.getting-started/04.build-your-first-hosted-app/packaged-or-hosted","content":"While Packaged Apps are the recommended way to deliver your KaiOS apps, there may be benefits to using the Hosted App approach. This page provides a guide to the key differences between these delivery methods and offers advice on choosing between the two. The primary difference between Packaged Apps and Hosted Apps is fairly obvious: the former delivers all its content onto a user’s device, while the latter delivers the app‘s assets on demand from a web server. However, there are many more subtle differences that you should consider when choosing between the two. Packaged and Hosted apps compared Let’s start by looking at key features of Packaged Apps and Hosted Apps and see how they differ. Functionality The overriding reason for creating a Packaged App is the functionality it can offer to your users. Packaged Apps can use the Privileged APIs, which provide apps with the ability to integrate closely with hardware and software features on a KaiOS device. If, for example, your app wanted to allow the user to select and use details of contacts stored on the device, this can only be done in a Packaged App. Feature\tPackage Apps\tHosted AppsAPI support\tAll available KaiOS APIs\tNo access to Privileged and Internal APIs Device integration\tExcellent\tLimited Can access web resources\tYes\tYes Performance In general you should expect users to observe better response from Packaged Apps, as all the app’s assets are stored locally on their device. When accessing remote data from the Internet, generally there’ll be no significant difference between the two options. Feature\tPackage Apps\tHosted AppsStart-up time\tFast, all assets on the device\tNetwork limited, all assets downloaded Network impact\tRemote data only\tApp content(unless AppCached) and remote data Content optimization, e.g. screen size\tThrough redundant assets or multiple packages\tOn-the-fly Impact of data plan limits\tLow\tHigh Availability While KaiOS supports AppCache and local data storage, Packaged Apps provide the app’s assets locally by default, removing the need to explicitly design for application caching. Hosting The cost and effort of hosting a server to deliver Hosted Apps may be an issue for you, if it is then Packaged Apps have a clear advantage. Feature\tPackage Apps\tHosted AppsServer required\tNo\tYes Discovery Feature\tPackage Apps\tHosted AppsDiscovery\tThrough Marketplace\tThrough Marketplace and own site Direct access using a URL\tNo\tYes Delivery All apps need to be delivered to a user’s device, which will be affected by both the network bandwidth and the available storage memory on the device. Here the overall size of your app’s assets will be the primary decision driver, the larger your app the more likely you’ll want to deliver it as a Hosted App. Feature\tPackage Apps\tHosted AppsMarketplace review time\tLonger (when using Privileged APIs)\tShorter Self-publication\tYes\tYes App updates\tRequires a new package to be loaded onto Marketplace\tCore app changes delivered on-the-fly, new install details (e.g. name, icon) require a new Marketplace package App Asset/Content redundancy on device\tPossible\tNo, only used assets/content downloaded App asset limits\tPractical package size limit is device memory and network dependent, generally < 50Mb, <5Mb for low memory devices\tOnline: No practical limit AppCached: As for Packaged Apps Number of apps per device\tLimited by device memory\tOnline: Practically unlimited AppCached: As for Packaged Apps Asset extendibility\tLimited, except for data from XMLHttpRequest and browser links all assets must be on the device\tUnlimited, within Origin Remote content\tBy using iframes, but that content will not have access to privileged APIs nor will it have the default CSP applied to it.\tBy default Development Feature\tPackage Apps\tHosted AppsDelivery standard\tProprietary (albeit a simple ZIP)\tWeb standard Debugging\tEasier, no Origin limitations\teasy, Just like normal web app debug Reading JavaScript assets\tRequires use of XMLHttpRequest\tDirect Coding challenges\tOAuth functionality for Facebook, Dropbox, Twitter, etc. Manifest must specify a launch_path\tRequired\tOptional Apps per Origin\tDoesn’t apply\tDoesn't apply CSP\tEnforced\tOptional mozApps API install function\tApps.installPackage\tapps.install Making your choice The choice of Packaged App or Hosted App isn’t necessarily a simple one. There are however a few key factors that can be used to determine the option to use, as shown in this flowchart :","keywords":""},{"title":"Notifications","type":0,"sectionRef":"#","url":"docs/03.core-developer-topics/using-push-notifications","content":"Push API allow applications to receive asynchronous notifications and perform actions without staying in the foreground. W3C Push API Push API introduction Service Worker Cookbook - Web Push Payload","keywords":""},{"title":"Transform PWA to hosted app","type":0,"sectionRef":"#","url":"docs/02.getting-started/04.build-your-first-hosted-app/pwa-to-hosted-app","content":"What is PWA? Put it simply, Progressive Web Apps are web applications that load in a web browser just like web pages or websites. It gives you a rich mobile experience via native-like functionalities such as the ability to work offline, push notifications, and device hardware accessibility. It feels like a native app and offers the same experience as a native one. There is no need to download it from an app store. It loads, runs, and functions in a web browser. For more information about PWA, You can see also Progressive web apps on MDNProgressive web apps on Google DevelopersProgressive web apps details on Google DevelopersProgressive Web Apps Check ListThe Lighthouse Tool by Google Progressive Web Apps Promote Mobile-First Approach According to one Statista report, The number of mobile phone users is forecasted to reach 4.68 billion by 2019. Going further, in 2016, an estimated 62.9 percent of the population worldwide already owned a mobile phone. This will round up to 67 percent by 2019. 4 Things Every Progressive Web App Must Have There are 4 things every progressive web apps must have. Lets's start listing each of them, then we'll go over them one after the other: HTTPSWeb app manifestService workerResponsive design HTTPS A PWA must be safe and secure, hence the requirement to be served on HTTPS instead of HTTP. Gone are the days when getting an SSL certificate for a website is expensive and tedious. Every modern website today should be running on HTTPS, you will be doing your app such a great good by serving it on HTTPS. Web App Manifest The web app manifest is simply a JSON (manifest.json) file that is used to describe the application. The web app manifest provides information about an application (such as name, icon, and description etc.). The purpose of the manifest is to install web applications to the home screen of a device, providing users with quicker access and a richer experience such as theme, splash screen and the ability to run the app in full-screen mode and as a standalone application. A typical web app manifest can be as below: { \"name\": \"Weather\", \"short_name\": \"Weather\", \"icons\": [{ \"src\": \"/images/icons/icon-128x128.png\", \"sizes\": \"128x128\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-144x144.png\", \"sizes\": \"144x144\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-152x152.png\", \"sizes\": \"152x152\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-192x192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-256x256.png\", \"sizes\": \"256x256\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-512x512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" }], \"start_url\": \"/index.html\", \"display\": \"standalone\", \"background_color\": \"#3E4EB8\", \"theme_color\": \"#2F3BA2\" } Service Worker A service worker is vital to allow a PWA. So what is a service worker? A service worker is a script that runs in the background making the decision to serve network or cached content based on availability. Service worker provides offline support for applications through caching, which is essential for a PWA. In addition to the offline functionality, a service work also provides support for other features such as push notifications, and background sync. It is important to mention that service workers can only be registered on pages served over HTTPS. Though it can be registered on localhost while in development, as soon as you deploy to a live server, it will require HTTPS and not HTTP. Responsive Design Since a PWA can be somewhat installed on a device (mobile phone or tablet etc.), it should be responsive enough so as to display properly irrespective of the devices it is being viewed on. With the numerous CSS frameworks out there that support responsive design, making your app responsive on major screen sizes should be easy. Transform PWA to hosted app If you already have a PWA web app and want to publish it to hosted app under KaiOS，We will provide some instruction to help you transform PWA to KaiOS hosted app and submit to KaiStore. We assume you already be familiar with PWA.The under instruction only list some points you need focus on,Please refer above link about the details of PWA. Add new manifest.webapp Your PWA app manifest.json file may be looks like below: { \"name\": \"Weather\", \"short_name\": \"Weather\", \"icons\": [{ \"src\": \"/images/icons/icon-56x56.png\", \"sizes\": \"56x56\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-112x112.png\", \"sizes\": \"112x112\", \"type\": \"image/png\" }, { \"src\": \"/images/icons/icon-224x224.png\", \"sizes\": \"224x224\", \"type\": \"image/png\" }], \"start_url\": \"/index.html\", \"display\": \"standalone\", \"background_color\": \"#3E4EB8\", \"theme_color\": \"#2F3BA2\" } First we need add a new file manifest-hosted.app(any meaningful name will be accepted) and let this new manifest file be served through your server. { \"version\": \"1.0.0\", \"name\": \"KaiOS Hosted Weather APP\", \"description\": \"A sample hosted APP which transported for PWA\", \"type\": \"web\", \"launch_path\": \"/index.html\", \"icons\": { \"56\": \"/images/icons/icon-56x56.png\", \"112\": \"/images/icons/icon-112x112.png\", \"224\": \"/images/icons/icon-224x224.png\" }, \"developer\": { \"name\": \"KaiOS\", \"url\": \"http://www.kaiostech.com\" }, \"permissions\": { \"serviceworker\":{} }, \"cursor\": \"true\", \"locales\": { \"en-US\": { \"name\": \"KaiOS App\", \"subtitle\": \"Short description for the user\", \"description\": \"Brief description of your app\" } }, \"default_locale\": \"en-US\" } Certainly you can just add a REST API and return json like below: const hostedManifest = { \"version\": \"1.0.0\", \"name\": \"KaiOS Hosted Weather APP\", \"description\": \"A sample hosted APP which transported for PWA\", \"type\": \"web\", \"launch_path\": \"/index.html\", \"icons\": { \"56\": \"/images/icons/icon-56x56.png\", \"112\": \"/images/icons/icon-112x112.png\", \"224\": \"/images/icons/icon-224x224.png\" }, \"developer\": { \"name\": \"KaiOS\", \"url\": \"http://www.kaiostech.com\" }, \"permissions\": { \"serviceworker\":{} }, \"locales\": { \"en-US\": { \"name\": \"KaiOS App\", \"subtitle\": \"Short description for the user\", \"description\": \"Brief description of your app\" } }, \"default_locale\": \"en-US\", \"cursor\": true, }; function getHostedManifest(req, resp) { resp.json(hostedManifest); } app.get('/hosted-manifest', getHostedManifest); You can reference the details of this manifest file here.We will provide helper tool for you to transform PWA manifest.json file to hosted app manifest.webapp soon.The most important is you must specify ServiceWorker permission like blow or you can not use ServiceWorker in this hosted app. \"permissions\": { \"serviceworker\":{} } Offline Support The traditional offline of KaiOS app use appCache,For sure you can continue use this technology,In addition you can use Service Worker to implement like ServiceWorker Offline experience. Responsive Design Current KaiOS devices support QVGA resolutions in portrait (240x320 pixels) or landscape (320x240 pixels). If you want adapter your hosted app to KaiOS app, You should process your responsive design for small screen. You can refer more details about responsive design through Responsive Design on Google Developer. Navigation Fow now,You can add \"cursor: true\" to manifest.webapp file for the navigation purpose(Emulated Cursor), Certainly you can use D-pad for navigation(D-pad navigation). Install experience When a Progressive Web App is installed, it looks and behaves like all of the other installed apps. It launches from the same place as other apps launch. It runs in an app without an address bar or other browser UI. And like all other installed apps, it's a top level app in the task switcher.When you port your PWA to KaiOS hosted app, Currently you can only install your web app via submit to our KaiStore Submit To KaiStore. Certainly you can test through WebIDE install hosted app.","keywords":""},{"title":"Marketing Banner","type":0,"sectionRef":"#","url":"docs/04.design-guide/marketing-banner","content":"Your marketing banner is a background image appears behind the icon, app name, and subtitle. It plays an assistant role that communicates your app’s feature and purpose. Using an attractive image can encourage product page views and get users attention. The image should be simple and subtle, and it needs to ensure your icon, app name, and subtitle are legible, avoid adding unnecessary visual details to your marketing banner. KaiStore UI Design resource sketch file is here for you to design the Marketing Banner of your product. It includes screenshot preview and helps quickly export the product assets. The resource file requires Sketch 51 or higher version. Size Banner Image Requirements Format: JPG format, non alphaDimensions: Portrait/Landscape: 240 x 130 pixelsMaximum file size: 100 KBFile Name: Portrait/Landscape: img_AppName.jpg (e.g. img_weather.jpg, img_star_war.jpg) Your marketing banner will be displayed responsively on the Landing page and Product page in both portrait and landscape layouts. Usage Design Tips Suggest using photos, illustrationsAvoid adding text overlayKeep image’s ratio correct Theme color The color theme represents the background color of an app on Store Launch page and Product page. Also, It replaces the background image if your app does not have a background image submitted. Background Color Requirements Pick one color with Hex color codes, or choose one from below color palettes. The purple is the default option. Background Color & Focus Color Requirements Pick one color with Hex color codes, or choose one from below default color palettes. Purple\t#8500DC Rose\t#CD006F Red\t#FF0E0E Lime\t#6B9A23 Cyan\t#00B1B4 Blue\t#0071DD Orange\t#FF4B00 Dark Gray\t#323232","keywords":""},{"title":"Key","type":0,"sectionRef":"#","url":"docs/04.design-guide/key","content":"Overview Software Key (LSK, CSK, RSK) When a software key (LSK, CSK or RSK) has a function, there should be an indicator on software key bar to inform user what it will do when pressed. D-Pad (UP, DOWN, LEFT, RIGHT) D-pad is used to move highlight to different items on list views or grid views, switch tabs, adjust spinners or sliders, move text cursor, and move browser cursor. Long pressing a directional key will send keyDown event continuously and it speeds up. Call Key Call key is used to make a call or answer an incoming call. Independent Back Key Type And Combined Key Type Independent Back Key Type Back/Clear Key In an input, BACK/CLEAR key is used to clear one character. If the input is empty, pressing BACK/CLEAR key works like normal case.In normal case (not in an input), pressing BACK/CLEAR key goes to the upper level of an app. At the top level of the app, pressing BACK/CLEAR key leaves the app.In a dialog, if LSK is Cancel, BACK/CLEAR key works like LSK. Otherwise, pressing BACK/CLEAR key does nothing. End/Power Key END/POWER key is used to end a call, reject an incoming call, or leave an app.Long pressing END/POWER key invokes the sleep menu with actions including Lock, Restart, Power off, etc.When the device is off, long pressing END/POWER key powers on the device. Combined Key Type Back/Clear/End/Power Key In an input, BACK/CLEAR/END/POWER key is used to clear one character. If the input is empty, pressing BACK/CLEAR/END/POWER key works like normal case.In normal case (not in an input), pressing BACK/CLEAR/END/POWER key goes to the upper level of an app. At the top level of the app, pressing BACK/CLEAR/END/POWER key leaves the app.In a dialog, if LSK is Cancel, BACK/CLEAR/END/POWER key works like LSK. Otherwise, pressing BACK/CLEAR/END/POWER key does nothing.BACK/CLEAR/END/POWER key is used to end a call, reject an incoming call.In Homescreen, long pressing BACK/CLEAR/END/POWER key invokes the sleep menu with actions including Lock, Restart, Power off, etc.In an app, long pressing BACK/CLEAR/END/POWER key leaves the app.When the device is off, long pressing BACK/CLEAR/END/POWER key powers on the device. Number Pad Number pad is used to enter numbers or characters with certain input methods. Volume Key Volume key is used to control volume directly. There are 4 types of volume: Ringtones & Notice Alerts, Media, Alarm, and Telephony. When pressing volume key, system will adjust the proper type of volume by context. For devices without volume keys, app should provide at least one way to adjust volume. It is recommended to use UP/DOWN key to invoke volume panel directly and then user can adjust volume. Fallback solution is to use Options > Volume to invoke volume panel.","keywords":""},{"title":"Emulated Cursor","type":0,"sectionRef":"#","url":"docs/03.core-developer-topics/emulated-cursor","content":"KaiOS supports emulating a cursor in app, which user can control with d-pad. There are two types of settings to invoke emulated cursor in app. 1. Emulated Cursor Handled by System To enable emulated cursor in app, set cursor to true in manifest.webapp file: { \"cursor\": true } App with this setting will have the feature of emulated cursor just as browser tab does. For example, cursor is automatically turned off when focusing on input field, and is turned on after leaving input field. Note: This type of cursor usage is strongly recommended. 2. Emulated Cursor Handled by App Note: This type of cursor usage by design lets app have FULL CONTROL of emulated cursor, which means that system will NOT turn on or off cursor for app. That is, app has full responsibilities of when to show and when to hide the cursor. Furthermore, some key events are treated differently when cursor is on, please find more details in the followings: Turning on cursor will prevent default and stop propagation on key events of Enter, Up, Right, Down, Left.Turning on cursor will NOT prevent default or stop propagation on key event of RSK, in addition, it will trigger contextmenu event on key event of RSK.When focus is on an input element (IME is active), app should remember to turn cursor off by itself.Other than the case of focusing on input elements, there might be other cases that apps need to control. Emulated cursor handled by system makes the emulated cursor exist in the app all the time like browser tab. If app needs to control cursor on their own, another api spatialnavigation-app-manage is supported. To get permissions, app must be at least a privileged app. Set spatialnavigation-app-manage in manifest.webapp file: { \"type\": \"privileged\", // or \"certified\" \"permissions\": { \"spatialnavigation-app-manage\": {} } } To turn on cursor: navigator.spatialNavigationEnabled = true; To turn off cursor: navigator.spatialNavigationEnabled = false; ","keywords":""},{"title":"Other Web APIs","type":0,"sectionRef":"#","url":"docs/06.api/other-apis","content":"Web Application Programming Interfaces (Web APIs) are used to perform a variety of tasks, such as manipulating the DOM, playing audio or video, or generating 3D graphics. When writing code for the Web with JavaScript, there are a great many APIs available. This page has a list of all the interfaces that you may be able to use while developing your Web app.","keywords":""},{"title":"mozAlarms","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/alarm/mozAlarms","content":"Returns a MozAlarmsManager object you can use to schedule notifications or applications to be started at a specific time. Syntax# var alarms = window.navigator.mozAlarms; Copy Value# navigator.mozAlarms is a MozAlarmsManager object.","keywords":""},{"title":"Sample code","type":0,"sectionRef":"#","url":"docs/02.getting-started/03.build-your-first-package-app/sample-code","content":"Let's use a simple to-do app, using only JavaScript (Vanilla), React, Vue.js and Angular. Vanilla In Vanilla development, we use only the main technologies without any framework or library to aid development. Note: You can use the ArrowRight key to simulate the SoftRight key To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-vanilla.git Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub React Create React App (CRA) is a template with all the basic settings to start a project in React. First you need to have the create-react-app installed on your computer as a global package, in your terminal run the command: $ npm install -g create-react-app or with yarn $ yarn global add create-react-app Now you can run the following command to start your project using the official react template $ create-react-app my-first-kaios-react-app Open the folder created in your IDE or text editor of your preference. Now, you can look at the following app made by the create-react-app template Note: You can use the ArrowRight key to simulate the SoftRight key To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-react.git Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub Vue Vue CLI is a template with all the basic settings to start a project in Vue. First you need to have the Vue CLI installed on your computer as a global package, in your terminal run the command: $ npm install -g @vue/cli or with yarn $ yarn global add @vue/cli Now you can run the following command to start your project using the official react template $ vue create my-first-vue-app-kaios Open the folder created in your IDE or text editor of your preference. Now, you can look at the following app made by the Vue CLI template Note: You can use the ArrowRight key to simulate the SoftRight key To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-vue.git Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub Angular Angular CLI is a template with all the basic settings to start a project in Angular. First you need to have the Angular CLI and TypeScript installed on your computer as a global package, in your terminal run the command: $ npm install -g @angular/cli typescript or with yarn $ yarn global add @angular/cli typescript Now you can run the following command to start your project using the official react template $ ng new my-first-angular-app-kaios Open the folder created in your IDE or text editor of your preference. Now, you can look at the following app made by the Angular CLI template Note: You can use the ArrowRight key to simulate the SoftRight key To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-angular.git Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub Apps which use indexedDB IndexedDB is a low-level API for client-side storage of significant amounts of structured data, including files/blobs. This API uses indexes to enable high-performance searches of this data. While Web Storage is useful for storing smaller amounts of data, it is less useful for storing larger amounts of structured data. In this next example we will use the example of the app made with React and add the indexedDB to persist the to-do list Note: You can use the ArrowRight key to simulate the SoftRight key If you reload this page you will see that the tasks you added were stored. To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-react.git -b indexedDB Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub Theme apps App themes give the user a better experience, giving her the ability to choose the best theme of her choice. In this next example, we will use the example of the application made with Vanilla and we will add the light and dark themes. Note: You can use the ArrowRight key to simulate the SoftRight key and the ArrowLeft key to simulate the SoftLeft key. To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-vanilla.git -b theme Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub Apps with translation - l10n Currently KaiOS uses a modified version of the L10n.js library to localize the default apps that are available in KaiOS. In this next example, we will use the example of the application made with React and add the translations in en-US and pt-BR. Note: You can use the ArrowRight key to simulate the SoftRight key To run this application on your KaiOS device or simulator, follow these steps: Clone the project with the follow command: $ git clone https://github.com/kaiostech/sample-react.git -b l10n Install the project's dependencies with the command npm install or yarn To finish, execute the command npm run build or yarn build in your terminal, and test your application by sending the contents of the build folder to the device by WebIDE or load the contents of the build folder by Simulator. You can consult the source code of this project and other projects consulted the KaiOS Workspace in GitHub","keywords":""},{"title":"chargingTime","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/chargingtime","content":"Indicates the amount of time, in seconds, that remain until the battery is fully charged. Even if the time returned is precise to the second, browsers round them to a higher interval (typically to the closest 15 minutes) for privacy reasons. Syntax# var time = navigator.battery.chargingTime Copy On return, time is the remaining time in seconds until the battery, which is a BatteryManager object, is fully charged, or 0 if the battery is already fully charged. If the battery is currently discharging, this value is Infinity. Example# HTML Content# <div id=\"chargingTime\">(charging time unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { var time = battery.chargingTime; document.querySelector('#chargingTime').textContent = battery.chargingTime; }); Copy","keywords":""},{"title":"remove","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/alarm/mozAlarmsManager/remove","content":"The remove method is used to retrieve a list of pending alarms. Syntax# navigator.mozAlarms.remove(id); Copy Properties# id - A number representing the id of the alarm to be removed. Return# None. Example# var request = navigator.mozAlarms.getAll(); request.onsuccess = function() { // Remove all pending alarms this.result.forEach(function(alarm) { navigator.mozAlarms.remove(alarm.id); }); }; request.onerror = function() { console.log('operation failed: ' + this.error); }; Copy","keywords":""},{"title":"Typography","type":0,"sectionRef":"#","url":"docs/04.design-guide/typography","content":"KaiOSKaiOSKaiOSKaiOS The typography of KaiOS provides a great reading experience, conveys hierarchy, and facilitates understanding. Open Sans is the standard typeface on KaiOS. It provides high legibility and is well suited for high or low density displays. Noto Sans is the typeface to support other languages with harmonious look and feel. Typefaces Use font weight and size to emphasize important information in your app. Open Sans font weights KaiOS picks out 4 weights of Open Sans including Light, Regular, Semi-bold, and Bold. OPEN SANS LIGHT The Open Sans is optimized for legibility across print, web, and mobile interfaces. OPEN SANS REGULAR The Open Sans is optimized for legibility across print, web, and mobile interfaces. OPEN SANS SEMIBOLD The Open Sans is optimized for legibility across print, web, and mobile interfaces. OPEN SANS BOLD The Open Sans is optimized for legibility across print, web, and mobile interfaces. Noto Sans KaiOS picks out 2 weights of Noto Sans including Regular and Bold. NOTO SANS REGULAR The Noto Sans is optimized for legibility across print, web, and mobile interfaces. NOTO SANS BOLD The Noto Sans is optimized for legibility across print, web, and mobile interfaces. Font Sizes KaiOS uses a specific set of font sizes to balance content priority and readability. This is a list of the most common styles and the basics you may need. There are 11 default styles calculated for a 140 ppi screen, which is a QVGA resolution at 2.8 inch display. If you’re working with a different resolution you will need to convert the unit based on your device resolution. Label\tDescription\tTypeface\tPixelH1\tHeader text\tRegular/400\t17 H2\tHeader of body text\tSemibold/600\t17 H3\tTab text\tRegular/400\t14 H4\tSeparator text\tRegular/400\t14 H5\tSoftware key text\tSemibold/600\t14 P.PRI\tPrimary text\tRegular/400\t17 P.SEC\tSecondary text\tRegular/400\t14 P.THI\tTertiary text\tRegular/400\t12 P, UL\tBody text\tRegular/400\t17 P.LINK\tHyperlink text\tBold/700\t17 P.BTN\tButton text\tRegular/400\t17","keywords":""},{"title":"UI Component","type":0,"sectionRef":"#","url":"docs/04.design-guide/ui-component","content":"KaiOS apps are created from UI Components which define common interface elements. By following UI Components, apps achieve a consistent appearance across the system. The Units of spacing defined in KaiOS are specified in rem. On a screen with a density of 140, 1 rem is equal to 10 pixels, which is a baseline QVGA resolution on a 2.8-inch display and the resolution is 240*320. Header A header appears below the status bar. The text in the header is centered and displays the app name or page title. Tab A tab appears below the header, which separates grouped content and provides the ability to quickly switch between different sections of an app by tapping left or right on the navigation key. Software Key The software key appears at the bottom of the screen, which corresponds to the center, right, and left hardware keys. Each key may or may not appear depending on the availability of features. In certain conditions, it is allowed to use icon for the center key if it is of universal recognition, such as play or pause icon. List Lists are typically used to navigate to a new screen, or to display information or controls. Separator Separators are used to describe a subsection of content. The separator often appears between list or grid items, as it helps separate different groups of content. Controls - Checkbox and Radio Button Checkboxes allow users to select multiple options from a set. Radio buttons provide the ability to select one option from a set. Progress Progress represents how long the current operation will take, or appears as indeterminate when the completion status cannot be determined. Slider The slider is an extension of Progress that adds a draggable thumb. On a non-touch device, the user can press the Right and Left keys to set a new value for a given control, such as volume or brightness. Button The button is used to perform an explicit action. It can include a title or combine with an icon. Input Input is a data entry field and can be as simple as a text-only entry field in a list or a search input in the header. For multiple-line input, the center key is Enter for a new line. Option Menu Option Menu provides a list of choices on a pop-up component which may appear with controls such as a checkbox or radio button. It allows users to perform actions on objects without having to leave their current view. Value Selector The Value Selector provides an easy way to select single or multiple values from a pre-determined set of values. Date Value Selector and Time Value Selector can be used for specific scenarios. Dialog A Dialog provides the user with some important information, asks the user to take or confirm an action, or allows the user to make a choice or enter information. Notice Notice appears at the top of the screen like Toast, but with different layout. A Notice has an icon, primary text, and secondary text. After a Notice disappears from the top of the screen, users can still access it from Notices panel. Toast Toast appears at the top of the screen and provides important information, or alerts the user to a system event. It can’t be interacted with and will automatically time out depending on the length of the content. Capitalization for UI Components Three styles are used: Title Case, Sentence case, and ALL CAPS. Useful third-party component For some reason，We did't publish our official component，But there are some good design third-party component,They follow closely our design guideline. KaiUI from AdrianMachado or follow design at kai in medium Design at Kai","keywords":""},{"title":"DischargingTime","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/dischargingtime","content":"Indicates the amount of time, in seconds, that remain until the battery is fully charged. Even if the time returned is precise to the second, browsers round them to a higher interval (typically to the closest 15 minutes) for privacy reasons. Syntax# var time = navigator.battery.chargingTime Copy On return, time is the remaining time in seconds until the battery, which is a BatteryManager object, is fully charged, or 0 if the battery is already fully charged. If the battery is currently discharging, this value is Infinity. Example# HTML Content# <div id=\"chargingTime\">(charging time unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { var time = battery.chargingTime; document.querySelector('#chargingTime').textContent = battery.chargingTime; }); Copy","keywords":""},{"title":"batteryManager","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/batterymanager","content":"Description# The BatteryManager interface provides ways to get information about the system's battery charge level. The navigator.getBattery() method returns a battery promise that is resolved in a BatteryManager interface which you can use to interact with the Battery Status API. Properties# BatteryManager.charging read-onlyA Boolean value indicating whether or not the battery is currently being charged. BatteryManager.chargingTime read-only A number representing the remaining time in seconds until the battery is fully charged, or 0 if the battery is already fully charged. BatteryManager.dischargingTime read-only A number representing the remaining time in seconds until the battery is completely discharged and the system will suspend. BatteryManager.level read-only A number representing the system's battery charge level scaled to a value between 0.0 and 1.0. BatteryManager.health read-only Available since v2.5The health status of battery. BatteryManager.present read-only Available since v2.5A Boolean value indicating whether or not the battery is present BatteryManager.temperature read-only Available since v2.5A number representing the temperature of battery. Event Handlers# BatteryManager.onbatteryhealthchange Available since v2.5A handler for the batteryhealthchange event; This event is sent when the battery health is updated. BatteryManager.onchargingchange A handler for the chargingchange event; This event is sent when the battery charging state is updated. BatteryManager.onchargingtimechange A handler for the chargingtimechange event; This event is sent when the battery charging time is updated BatteryManager.ondischargingtimechange A handler for the dischargingtimechange event; This event is sent when the battery discharging time is updated. BatteryManager.onlevelchange A handler for the levelchange event; This event is sent when the battery level is updated. Methods# Inherited from EventTarget: EventTarget.addEventListener() Register an event handler of a specific event type on the EventTarget. EventTarget.removeEventListener() Removes an event listener from the EventTarget. EventTarget.dispatchEvent() Dispatch an event to this EventTarget. Additional methods for Mozilla chrome code# void setEventHandler(DOMString type, EventHandler handler)EventHandler getEventHandler(DOMString type) Mozilla extensions for use by JS-implemented event targets to implement on* properties. See also WebIDL bindings. Example#","keywords":""},{"title":"BatteryManager.health","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/health","content":"The health status of battery. Syntax# var health = navigator.battery.health Copy On return, health indicates the status of battery health, which is enum includes Good, Overheat, Cold, Warm, Cool and Unknown. Example# HTML Content# <div id=\"health\">(health status unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { var health = battery.health; document.querySelector('#health').textContent = health ; }); Copy","keywords":""},{"title":"BatteryManager.onchargingtimechange","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/onchargingtimechange","content":"Specifies an event listener to receive chargingtimechange events. These events occur when the battery chargingTime is updated. Syntax# battery.onchargingtimechange = funcRef Copy Where battery is a BatteryManager object, and funcRef is a function to be called when the chargingtimechange event occurs. Example# HTML Content# <div id=\"level\">(battery level unknown)</div> <div id=\"chargingTime\">(charging time unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { battery.onchargingtimechange = chargingTimeChange(); function chargingTimeChange(){ document.querySelector('#level').textContent = battery.level; document.querySelector('#chargingTime').textContent = battery.chargingTime; } }); Copy","keywords":""},{"title":"BatteryManager.onchargingchange","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/onchargingchange","content":"Specifies an event listener to receive chargingchange events. These events occur when the battery charging state is updated. Syntax# battery.onchargingchange = funcRef Copy Where battery is a BatteryManager object, and funcRef is a function to be called when the chargingchange event occurs. Example# HTML Content# <div id=\"level\">(battery level unknown)</div> <div id=\"chargingTime\">(charging time unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { battery.onchargingchange = chargingChange(); function chargingChange() { document.querySelector('#level').textContent = battery.level; document.querySelector('#chargingTime').textContent = battery.chargingTime; } }); Copy","keywords":""},{"title":"BatteryManager.onbatteryhealthchange","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/onbatteryhealthchange","content":"Specifies an event listener to receive batteryhealthchange events. These events occur when the battery health state is updated. Syntax# battery.onbatteryhealthchange = funcRef Copy Where battery is a BatteryManager object, and funcRef is a function to be called when the batteryhealthchange event occurs. Example# HTML Content# <div id=\"health\">(battery health unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { battery.onbatteryhealthchange = batteryhealthchange(); function batteryhealthchange() { document.querySelector('#health').textContent = battery.health; } }); Copy","keywords":""},{"title":"getAll","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/alarm/mozAlarmsManager/add","content":"The add method is used to retrieve a list of pending alarms. Syntax# var request = navigator.mozAlarms.add(date, respectTimezone[, data]); Copy Properties# date - A Date object representing the time the alarm must be fired. respectTimezone - A string that indicates if the alarm must be fired respecting the timezone set with the date. Possible values are ignoreTimezone or honorTimezone. data (Optional) - An arbitrary JavaScript object with data to be stored with the alarm. Return# A DOMRequest object to handle the success or failure of the method call. If the method call is successfull, the request's result will be a number representing the id of the alarm. Example# var alarm = { date: new Date('July 27, 2013 20:00:00'), respectTimezone: 'ignoreTimezone', data: { message: 'Do something dude!' } }; var request = navigator.mozAlarms.add( alarm.date, alarm.respectTimezone, alarm.data ); request.onsuccess = function() { console.log('A new alarm has been set:' + this.result); alarm.id = this.result; // get the id of the new alarm. }; request.onerror = function() { console.log('operation failed: ' + this.error); }; Copy Note: You need to use the same URL for setting and receiving an alarm. For example, If you invoke navigator.mozAlarms.add() on foo.html or index.html?foo=bar, but have { \"alarm\": \"/index.html\" } in your manifest messages field, you'll never receive the alarm.","keywords":""},{"title":"getAll","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/alarm/mozAlarmsManager/getAll","content":"The getAll method is used to retrieve a list of pending alarms. Syntax# var request = navigator.mozAlarms.getAll(); Copy Return# A DOMRequest object to handle the success or failure of the method call. If the method call is successful, the request's result will be an array of mozAlarm objects. mozAlarm# Those objects are anonymous JavaScript objects with the following properties: id - A number representing the id of the alarm date - A Date object representing the scheduled time for the alarm respectTimezone - A string indicating if the alarm must respect or ignore the timezone information of the date object. Its value can be ignoreTimezone or honorTimezone data - A JavaScript object contaning any data that were stored with the alarm Example# var request = navigator.mozAlarms.getAll(); request.onsuccess = function() { console.log('operation successful:' + this.result.length + 'alarms pending'); this.result.forEach(function(alarm) { console.log( alarm.id + ' : ' + alarm.date.toString() + ' : ' + alarm.respectTimezone ); }); }; request.onerror = function() { console.log('operation failed: ' + this.error); }; Copy","keywords":""},{"title":"BluetoothAdapter","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter","content":"Description# The BluetoothAdapter interface of the Web Bluetooth API is used to handle all the operations requested by Bluetooth networks. A Bluetooth adapter is the physical interface which is used to interact with local Bluetooth device. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothAdapter: EventTarget { readonly attribute BluetoothAdapterState state; readonly attribute DOMString name; readonly attribute boolean discoverable; readonly attribute boolean discovering; attribute EventHandler onattributechanged; attribute EventHandler ondevicepaired; attribute EventHandler ondeviceunpaired; attribute EventHandler onpairingaborted; attribute EventHandler ona2dpstatuschanged; attribute EventHandler onhfpstatuschanged; attribute EventHandler onscostatuschanged; attribute EventHandler onrequestmediaplaystatus; [NewObject] Promise<void> setDiscoverable(boolean aDiscoverable); [NewObject] Promise<BluetoothDiscoveryHandle> startDiscovery(); [NewObject] Promise<void> stopDiscovery(); [NewObject] Promise<void> pair(DOMString aAddress); [NewObject] Promise<void> unpair(DOMString aAddress); sequence<BluetoothDevice> getPairedDevices(); // BLE methods [NewObject] Promise<BluetoothDiscoveryHandle> startLeScan(sequence<DOMString> aServiceUuids); [NewObject] Promise<void> stopLeScan(BluetoothDiscoveryHandle aDiscoveryHandle); }; Copy Properties# BluetoothAdapter.discoverable read-onlyA boolean indicating if the device is discoverable (true) or not (false) by other Bluetooth devices. BluetoothAdapter.discovering read-onlyA boolean indicating if the device's adapter is in the process of discovering (true) or not (false) surrounding Bluetooth devices. BluetoothAdapter.name read-onlyA string indicating the human readable name of the device's adapter. BluetoothAdapter.state read-only no-linkReturns the state of the local bluetooth adapter. Event Handlers# BluetoothAdapter.onattributechangedA handler for the attributechanged event; it is triggered when one of the local bluetooth adapter's properties has changed BluetoothAdapter.ondevicepairedA handler for the devicepaired event; it is triggered when a remote device gets paired with the local bluetooth adapter. BluetoothAdapter.ondeviceunpairedA handler for the deviceunpaired event; it is triggered when a remote device gets unpaired from the local bluetooth adapter. BluetoothAdapter.onpairingabortedA handler for the pairingaborted event; it is triggered when pairing fails due to authentication failure, the remote device being down (bluetooth ACL becomes disconnected), or some kind of internal error. BluetoothAdapter.ona2dpstatuschangedA handler for the a2dpstatuschanged event; it is triggered when an A2DP connection status changes. BluetoothAdapter.onhfpstatuschangedA handler for the hfpstatuschanged event; it is triggered when an HFP connection status changes. BluetoothAdapter.onrequestmediaplaystatusA handler for the requestmediaplaystatus event; it is triggered when a remote Bluetooth device queries the current media play status. BluetoothAdapter.onscostatuschangedA handler for the scostatuschanged event; it is triggered when a SCO connection status changes. Note: Because the BluetoothAdapter interface inherits from the EventTarget interface, all these events can be listened by using the addEventListener method. Methods# BluetoothAdapter.getPairedDevices()Allows retrieving a full list of all devices paired with the device's adapter. BluetoothAdapter.pair()Allows to start pairing a remote device with the device's adapter. BluetoothAdapter.setDiscoverable()Allows to change the value of the discoverable property. BluetoothAdapter.startDiscovery()Allows the device's adapter to start seeking for remote devices. BluetoothAdapter.startLeScan()Instructs the device's adapter to start seeking for remote LE devices advertising given services. BluetoothAdapter.stopDiscovery()Allows the device's adapter to stop seeking for remote devices. BluetoothAdapter.stopLeScan()Instructs the device's adapter to stop scanning for remote LE devices. BluetoothAdapter.unpair()Allows to unpair a remote device from the device's adapter.","keywords":""},{"title":"AudioContext","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/audiocontext/audiocontext","content":"Description# The AudioContext interface represents an audio-processing graph built from audio modules linked together, each represented by an AudioNode. An audio context controls both the creation of the nodes it contains and the execution of the audio processing, or decoding. You need to create an AudioContext before you do anything else, as everything happens inside a context. Constructor# AudioContext() Creates and returns a new AudioContext object. Properties# Also inherits properties from its parent interface, BaseAudioContext. AudioContext.baseLatency read-only Returns the number of seconds of processing latency incurred by the AudioContext passing the audio from the AudioDestinationNode to the audio subsystem.AudioContext.outputLatency read-only Returns an estimation of the output latency of the current audio context. Methods# Also inherits methods from its parent interface, BaseAudioContext. AudioContext.close() Closes the audio context, releasing any system audio resources that it uses.AudioContext.createMediaElementSource() Creates a MediaElementAudioSourceNode associated with an HTMLMediaElement. This can be used to play and manipulate audio from <video> or <audio> elements.AudioContext.createMediaStreamSource() Creates a MediaStreamAudioSourceNode associated with a MediaStream representing an audio stream which may come from the local computer microphone or other sources.AudioContext.createMediaStreamDestination() Creates a MediaStreamAudioDestinationNode associated with a MediaStream representing an audio stream which may be stored in a local file or sent to another computer.AudioContext.createMediaStreamTrackSource() Creates a MediaStreamTrackAudioSourceNode associated with a MediaStream representing an media stream track.AudioContext.getOutputTimestamp() Returns a new AudioTimestamp object containing two correlated context's audio stream position values.AudioContext.requestCleanAfterRelease() AudioContext.resume() Resumes the progression of time in an audio context that has previously been suspended.AudioContext.suspend() Suspends the progression of time in the audio context, temporarily halting audio hardware access and reducing CPU/battery usage in the process. Examples# Basic audio context declaration: var audioCtx = new AudioContext(); Copy Cross browser variant: var AudioContext = window.AudioContext || window.webkitAudioContext; var audioCtx = new AudioContext(); var oscillatorNode = audioCtx.createOscillator(); var gainNode = audioCtx.createGain(); var finish = audioCtx.destination; // etc. Copy","keywords":""},{"title":"Bluetooth","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetooth","content":"Description# The Bluetooth API lets a packaged app discover, pair with, and connect to Bluetooth devices. As it is a experimental and non-standard API, the API is currently available for certified and privileged apps only. Notice that 'bluetooth' permission is required for using Bluetooth API. Note: App developers who wish to send data to a Bluetooth device can use the share activity. This activity allows sharing of images, audio, video and vCard content only. API overview# The main entry point for the API is the Navigator.mozBluetooth property, which returns a BluetoothManager object. Basic interfaces# The following interfaces provide an app with basic Bluetooth functionality BluetoothManagerAllows access to all Bluetooth adapters available on the device. Adapters are the connection interface to connect another Bluetooth-enabled device to the current device.BluetoothAdapterUsed to handle all the operations requested by Bluetooth networks.BluetoothClassOfDeviceProvides identifying/classification information about a given remote Bluetooth device, available at discovery stage.BluetoothDeviceProvides information regarding a given remote Bluetooth device.BluetoothDiscoveryHandleUsed to notify the current application about the discovery of a remote bluetooth device. Gatt interfaces# The following interfaces allow KaiOS to communicate with and consume Gatt (Generic Attribute Profile)-based services on remote Smart/LE (low energy) devices. BluetoothGattHandles initial communications and connections with Gatt services.BluetoothGattServiceRepresents a service provided by a GATT server, including the service definition, a list of included services, and a list of the characteristics of this service.BluetoothGattCharacteristicRepresents a GATT service characteristic, which includes characteristic definition, value, properties and configuration info, and a list of descriptors that provide related information.BluetoothGattDescriptorRepresents a GATT descriptor, which contains related information about a characteristic value. Bluetooth event interfaces# These objects represent different events occuring within a Bluetooth interaction. BluetoothAdapterEventProvides access to a BluetoothAdapter object and its address as the parameter of a adapteradded or adapterremoved event handler (see BluetoothManager.onadapteradded and BluetoothManager.onadapterremoved), when fired.BluetoothAttributeEventProvides access to changed attributes and their new values as the parameter of attributechanged event handlers (including BluetoothManager.onattributechanged, BluetoothAdapter.onattributechanged, and BluetoothDevice.onattributechanged), when fired.BluetoothDeviceEventProvides access to a found/paired device (BluetoothDevice) object or the address or an unpaired device as the parameter of a devicefound, devicepaired or deviceunpaired event handler (see BluetoothDiscoveryHandle.ondevicefound, BluetoothAdapter.ondevicepaired, BluetoothAdapter.ondeviceunpaired), when fired.BluetoothGattCharacteristicEventProvides access to an updated BluetoothGattCharacteristic object as the parameter of the BluetoothGatt.oncharacteristicchanged, handler, when the characteristicchanged event is fired.BluetoothLeDeviceEventProvides access to an LE device BluetoothDevice object and its RSSI value and advertisement record, as the parameter of a devicefound event handler (see BluetoothDiscoveryHandle.ondevicefound), when fired.","keywords":""},{"title":"BatteryManager.present","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/present","content":"A Boolean value indicating whether or not the device's battery is present Syntax# var present = navigator.battery.present Copy On return, present indicates whether or not the battery is present. If battery connects to device, the return value is true. Otherwise, the value is false. Example# HTML Content# <div id=\"present\">(present state unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { var present = battery.present; document.querySelector('#present').textContent = present ; }); Copy","keywords":""},{"title":"charging","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/charging","content":"A Boolean value indicating whether or not the device's battery is currently being charged. Syntax# var charging = navigator.battery.charging Copy On return, charging indicates whether or not the battery, which is a BatteryManager object, is currently being charged; if the battery is charging, this value is true. Otherwise, the value is false. Example# HTML Content# <div id=\"charging\">(charging state unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { var charging = battery.charging; document.querySelector('#charging').textContent = charging ; }); Copy","keywords":""},{"title":"BluetoothAdapter.discoverable","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/04.discoverable","content":"Description# The discoverable property indicates if the device is discoverable (true) or not (false) by other Bluetooth devices. Note: This property can be changed with the BluetoothAdapter.setDiscoverable() method. Syntax# var isDiscoverable = instanceOfBluetoothAdapter.discoverable Copy Value# Return a boolean.","keywords":""},{"title":"Run and debug your first App","type":0,"sectionRef":"#","url":"docs/05.run-and-debug","content":"Running apps When you're ready to run the app, follow these steps for executing: Start WebIDE. If everything is fine until now, you can see your device on 'USB Devices' section.Click on the device name and all apps will be listed on the left side.Choose one app to run, inspect, debug, test, etc. Debugging apps To debug the app, click the wrench icon and the Developer Tools Toolbox appears, connected to your app: The basic tools available in your WebIDE are: The Inspector to examine and modify the HTML and CSS of a page. The Console for logs information associated with a web page and enables you to interact with a web page by executing JavaScript expressions in the context of the page. The JavaScript Debugger enables you to step through JavaScript code and examine or modify its state to help track down bugs. Style Editor enables you to view and edit all the stylesheets associated with a page, create new stylesheets from scratch and import existing stylesheets and apply them. The Scratchpad provides an environment for experimenting with JavaScript code. You can write, run, and examine the results of code that interacts with the web page. Just as in a web page, any changes you make in the tools are visible immediately in the app, but are not persistent. Conversely, any changes you make in the editor pane can be saved straight back to disk, but are not visible without restarting the app. Performance If you're interested in the performance of your apps, there are a few ways to measure their impact on the runtime in WebIDE: The Performance tool gives you insight into your app's general responsiveness, JavaScript and layout performance. With the Performance tool you create a recording, or profile, of your app over a period of time. The Memory tool lets you take a snapshot of the current tab's memory heap. It then provides a number of views of the heap that can show you which objects account for memory usage and exactly where in your code you are allocating memory. Generating memory reports with B2G Another way to see the device's memory usage is creating a memory report with B2G tool. To create one follow the steps below: Clone mozilla/B2G git clone https://github.com/mozilla-b2g/B2G.git Apply this patch cd B2G/tools git apply path/to/memory.patch Run the get_about_memory.py script which will get information from the plugged device. ./get_about_memory.py -m A folder called about-memory-0 will be created into B2G/tools and inside then you will see a gzipped file. Open Firefox and type \"about:memory\" into the address bar and hit Enter. Click in \"Load...\" and open the gzipped created in step 3. You can diff two different files too.","keywords":""},{"title":"BatteryManager.onlevelchange","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/onlevelchange","content":"Specifies an event listener to receive levelchange events. These events occur when the battery level is updated. Syntax# navigator.battery.onlevelchange = funcRef Copy Where battery is a BatteryManager object, and funcRef is a function to be called when the levelchange event occurs. Example# HTML Content# <div id=\"level\">(battery level unknown)</div> <div id=\"stateBaterry\">(charging state unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { battery.onlevelchange = function(){ document.querySelector('#level').textContent = battery.level; if(battery.charging) document.querySelector('#stateBaterry').textContent = \"Charging time: \" + (battery.chargingTime / 60); else document.querySelector('#stateBaterry').textContent = \"Discharging time: \" + (battery.dischargingTime / 60); }; }); Copy","keywords":""},{"title":"Device APIs","type":0,"sectionRef":"#","url":"docs/06.api/web-apis","content":"Device APIs WebAPI is a term used to refer to a suite of device compatibility and access APIs. These allow Web apps and content to access device hardware (such as battery status or the device vibration hardware), as well as access to data stored on the device (such as the calendar or contacts list). By adding these APIs, we hope to expand what the Web can do today to also include what only proprietary platforms were able to do in the past. Jump to: ABCDGLMNSVW A AlarmAudioContext B BatteryManagerBluetooth C Clients D Data StoreDevice Storage G Geolocation L LargeText M MediaSourcemozHasPendingMessagemozSetMessageHandler N Network Stats S SEChannelSEManagerSEReaderSEResponseSESessionSpeedDial V VolumeManager W WiFi Information","keywords":""},{"title":"BatteryManager.temperature","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/temperature","content":"A number representing the temperature of battery. Syntax# var temperature = navigator.battery.temperature Copy Temperature indicates battery temperature, its range depends on the limit of battery driver. Example# HTML Content# <div id=\"temperature\">(battery temperature unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { var temperature = battery.temperature; document.querySelector('#temperature').textContent = temperature ; }); Copy","keywords":""},{"title":"mozAlarmManager","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/alarm/mozAlarmsManager","content":"The MozAlarmsManager API allows to schedule notifications or applications to be started at a specific time. Syntax# interface MozAlarmsManager { DOMRequest getAll(); DOMRequest add(Date date, DOMString respectTimezone, optional object data); void remove(unsigned long id); }; Copy Properties# None. Methods# MozAlarmsManager.getAll() - Gets the list of all alarms currently scheduled. MozAlarmsManager.add() - Allows to schedule a new alarm. MozAlarmsManager.remove() - Allows to remove an existing alarm.","keywords":""},{"title":"BluetoothAdapter.discovering","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/05.discovering","content":"Description# The discovering property indicates if the device is in the process of discovering (true) or not (false) surrounding Bluetooth devices. Syntax# var isDiscovering = instanceOfBluetoothAdapter.discovering Copy Value# Return a boolean.","keywords":""},{"title":"BluetoothAdapter.name","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/06.name","content":"Description# The name property provides the human readable name of the device's adapter. Note: The name of the device's adapter can be changed with the BluetoothAdapter.setName() method. Syntax# var name = instanceOfBluetoothAdapter.name Copy Value# Return a string.","keywords":""},{"title":"BluetoothAdapter.onhfpstatuschanged","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/12.onhfpstatuschanged","content":"Description# Specifies an event listener to receive hfpstatuschanged events. Those events occur when an HFP connection status changes. Syntax# instanceOfBluetoothAdapter.onhfpstatuschanged = funcRef Copy Where funcRef is a function to be called when the hfpstatuschanged event occurs. That function gets a BluetoothStatusChangedEvent object as its first parameter.","keywords":""},{"title":"BluetoothConnectionHandle","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothconnectionhandle","content":"Description# Properties# Methods# accept()Accept the bluetooth profile connection request. reject()Reject the bluetooth profile connection request. Example#","keywords":""},{"title":"BluetoothAdapter.ona2dpstatuschanged","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/10.ona2dpstatuschanged","content":"Description# Specifies an event listener to receive a2dpstatuschanged events. Those events occur when an A2DP connection status changes. Syntax# instanceOfBluetoothAdapter.ona2dpstatuschanged = funcRef Copy Where funcRef is a function to be called when the a2dpstatuschanged event occurs. That function gets a BluetoothStatusChangedEvent object as its first parameter.","keywords":""},{"title":"BluetoothAdapter.onrequestmediaplaystatus","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/14.onrequestmediaplaystatus","content":"Description# Specifies an event listener to receive requestmediaplaystatus events. Those events occur when a remote Bluetooth device queries the current media play status. Syntax# instanceOfBluetoothAdapter.onrequestmediaplaystatus = funcRef Copy Where funcRef is a function to be called when the requestmediaplaystatus event occurs.","keywords":""},{"title":"BluetoothAttributeEvent","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothattributeevent","content":"Description# The BluetoothAttributeEvent interface of the Bluetooth API provides access to changed attributes and their new values as the parameter of attributechanged event handlers (including BluetoothManager.onattributechanged, BluetoothAdapter.onattributechanged, and BluetoothDevice.onattributechanged), when fired. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothAttributeEvent : Event { [Cached, Constant] readonly attribute sequence<DOMString> attrs; }; Copy Properties# BluetoothAttributeEvent.attrs read-only no-linkReturns an array of changed attribute values, which may be BluetoothManagerAttributes, BluetoothAdapterAttributes, or BluetoothDeviceAttributes. BluetoothManagerAttributes \"unknown\" or \"defaultAdapter\" BluetoothAdapterAttributes \"unknown\", \"state\", \"address\", \"name\", \"discoverable\" or \"discovering\" BluetoothDeviceAttributes \"unknown\", \"cod\", \"name\", \"paired\" or \"uuids\" Example#","keywords":""},{"title":"BluetoothAdapter.setDiscoverable","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/18.setdiscoverable","content":"Description# The setDiscoverable method is used to change the value of the discoverable property for the device's adapter. Syntax# var request = instanceOfBluetoothAdapter.setDiscoverable(flag); Copy Parameters# flag A boolean indicating if the device is discoverable (true) or not (false). Returns# A DOMRequest object to handle the success or error of the operation. In case of success, if the value has been set to true, the device remains discoverable for the duration of the discoverableTimeout property.","keywords":""},{"title":"BluetoothAdapter.startDiscovery","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/19.startdiscovery","content":"Description# The startDiscovery method is used to have the device's adapter start seeking for remote devices. Syntax# var request = instanceOfBluetoothAdapter.startDiscovery(); Copy Returns# A DOMRequest object to handle the success or error of the operation. In case of success, the BluetoothAdapter.discovering property is set to true.","keywords":""},{"title":"BluetoothAdapter.stopDiscovery","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/21.stopdiscovery","content":"Description# The stopDiscovery method is used to have the device's adapter stop seeking for remote devices. Syntax# var request = instanceOfBluetoothAdapter.stopDiscovery(); Copy Returns# A DOMRequest object to handle the success or error of the operation. In case of success, the BluetoothAdapter.discovering property is set to false.","keywords":""},{"title":"BluetoothDevice","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdevice","content":"Description# The BluetoothDevice interface of the Bluetooth API provides information regarding a given Bluetooth device. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothDevice: EventTarget { readonly attribute DOMString address; readonly attribute BluetoothClassOfDevice cod; readonly attribute DOMString name; readonly attribute boolean paired; readonly attribute BluetoothDeviceType type; [Cached, Pure] readonly attribute sequence<DOMString> uuids; readonly attribute BluetoothGatt? gatt; attribute EventHandler onattributechanged; [NewObject] Promise<sequence<DOMString>> fetchUuids(); }; Copy Properties# BluetoothDevice.address read-onlyA string representing the address of the device on the Bluetooth micro-network.BluetoothDevice.cod read-onlyReturns a BluetoothClassOfDevice object containing information about the device's capabilities.BluetoothDevice.gatt read-onlyReturns a BluetoothGatt object that allows JavaScript to conduct GATT client operations on a remote LE device. This property will return null for devices of type classic or unknown.BluetoothDevice.name read-onlyThe human readable name of the device.BluetoothDevice.paired read-onlyA boolean indicating if the device is paired to the adapter (true) or not (false).BluetoothDevice.type read-onlyReturns the device type of the remote device.BluetoothDevice.uuids read-onlyAn Array of strings indicating the UUIDs of each Bluetooth service the device is able to provide. Event handlers# BluetoothDevice.onattributechangedDefines a handler for the attributechanged event; triggers when a remote device's properties have changed (has a BluetoothAttributeEvent as a parameter.) Methods# BluetoothDevice.fetchUuidsFetches the up-to-date UUID list of services that the device provides. If the fetchUuids operation succeeds, an onattributechanged would be triggered right before the Promise is resolved to indicate device.uuids has changed. BluetoothDevice by Mozilla Contributors is licensed under CC-BY-SA 2.5.","keywords":""},{"title":"BluetoothAdapter.onscostatuschanged","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/15.onscostatuschanged","content":"Description# Specifies an event listener to receive scostatuschanged events. Those events occur when a SCO connection status changes. Syntax# instanceOfBluetoothAdapter.onscostatuschanged = funcRef Copy Where funcRef is a function to be called when the scostatuschanged event occurs. That function gets a BluetoothStatusChangedEvent object as its first parameter.","keywords":""},{"title":"BatteryManager.level","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/level","content":"Indicates the current battery charge level as a value between 0.0 and 1.0. Syntax# var level = navigator.battery.level Copy On return, level is a number representing the system's battery charge level scaled to a value between 0.0 and 1.0. A value of 0 means the battery, which is a BatteryManager object, is empty and the system is about to be suspended. A value of 1.0 means the battery is full. A value of 1.0 is also returned if the implementation isn't able to determine the battery charge level or if the system is not battery-powered. Example# HTML Content# <div id=\"level\">(battery level unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { var level = battery.level; document.querySelector('#level').textContent = level; }); Copy","keywords":""},{"title":"BluetoothAdapter.pair","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/17.pair","content":"Description# The pair method is used to start pairing a remote device with the device's adapter. Syntax# var request = instanceOfBluetoothAdapter.pair(deviceAddress); Copy Parameters# deviceAddress The Bluetooth micro-network address of the device to pair with. Returns# A DOMRequest object to handle the success or error of the operation.","keywords":""},{"title":"BluetoothDevice.cod","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdevice/02.cod","content":"Description# The cod property is a BluetoothClassOfDevice object that provides much information about the device's capabilities. Value type# BluetoothClassOfDevice Default value# A BluetoothClassOfDevice object whose attributes are default values. Sample# var cod = device.cod; var majorDeviceClass = cod.BluetoothMajorDeviceClass; var majorServiceClass = cod.BluetoothMajorServiceClass; var minorDeviceClass = cod.BluetoothMinorDeviceClass; Copy","keywords":""},{"title":"BluetoothDevice.address","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdevice/01.address","content":"Description# The address property value provides the address of the device on the Bluetooth micro-network. Syntax# var address = instanceOfBluetoothDevice.address Copy Value# Return a string.","keywords":""},{"title":"BluetoothAdapter.getPairedDevices","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/16.getpaireddevices","content":"Description# The getPairedDevices method is used to retrieve the full list of all devices paired with the device's adapter. Syntax# var request = instanceOfBluetoothAdapter.getPairedDevices(); Copy Returns# A DOMRequest object to handle the success or error of the operation. In case of success, the request's result is an Array of BluetoothDevice objects.","keywords":""},{"title":"BluetoothDevice.uuids","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdevice/09.uuids","content":"Description# The uuids property provides the list of UUIDs of each Bluetooth service the device is able to provide. For a full list of possible Bluetooth services see the Bluetooth specification. Syntax# var uuids = instanceOfBluetoothDevice.uuids Copy Value# Return an Array of strings.","keywords":""},{"title":"BluetoothDevice.name","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdevice/03.name","content":"Description# The name property provides the human readable name of the device. Syntax# var name = instanceOfBluetoothDevice.name Copy Value# Return a string.","keywords":""},{"title":"BatteryManager.ondischargingtimechange","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/batterymanager/ondischargingtimechange","content":"Specifies an event listener to receive dischargingtimechange events. These events occur when the battery dischargingTime is updated. Syntax# battery.ondischargingtimechange = funcRef Copy Where battery is a BatteryManager object, and funcRef is a function to be called when the dischargingtimechange event occurs. Example# HTML Content# <div id=\"level\">(battery level unknown)</div> <div id=\"chargingTime\">(charging time unknown)</div> Copy JavaScript Content# navigator.getBattery().then(function(battery) { battery.ondischargingtimechange = dischargingTimeChange; function dischargingTimeChange(){ document.querySelector('#level').textContent = battery.level; document.querySelector('#chargingTime').textContent = battery.chargingTime; } }); Copy","keywords":""},{"title":"BluetoothDevice.fetchUuids()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdevice/12.fetchuuids","content":"Description# The method fetches the up-to-date UUID list of services that the device provides. If the fetchUuids operation succeeds, an onattributechanged would be triggered right before the Promise is resolved to indicate device.uuids has changed. Return# A Promise to indicate whether the operation is resolved or rejected. If the Promise is resolved, it returns a DOMString array representing the updated list of UUIDs. Sample# device.fetchUuids().then ( function onResolve(uuids) { console.log(\"Resolved with uuids:\"); for (var i = 0; i < uuids.length; i++) { console.log(\"uuid\", i, \"is\", uuids[i]); } }, function onReject(aReason) { console.log(\"Rejected with this reason: \" + aReason); }); Copy","keywords":""},{"title":"BluetoothGattDescriptor","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothgattdescriptor","content":"Description# The BluetoothGattDescriptor interface of the Web Bluetooth API represents a GATT descriptor, which contains related information about a characteristic value. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothGattDescriptor { readonly attribute BluetoothGattCharacteristic characteristic; readonly attribute DOMString uuid; readonly attribute ArrayBuffer? value; [Cached, Constant] readonly attribute GattPermissions permissions; [NewObject] Promise<ArrayBuffer> readValue(); [NewObject] Promise<void> writeValue(ArrayBuffer value); }; Copy Properties# BluetoothGattDescriptor.characteristic read-only no-linkReturns the BluetoothGattCharacteristic object representing the characteristic this descriptor belongs to. BluetoothGattDescriptor.uuid read-only no-linkReturns the UUID of this descriptor. BluetoothGattDescriptor.value read-only no-linkStores the cached value of this descriptor. This value can be updated via the BluetoothGattDescriptor.readValue() method. BluetoothGattDescriptor.permissions read-only no-linkReturns a bit mask that describes the operations allowed on the characteristic. Methods# BluetoothGattDescriptor.readValue()Reads the descriptor value from the remote device. The cached BluetoothGattDescriptor.value is also updated after retrieving the value. BluetoothGattDescriptor.writeValue()Writes the descriptor value to the GATT server. If the local device is the GATT client, the value will be written to the remote GATT server. On the other hand, if the local device is the GATT server, the value will be written to BluetoothGattDescriptor.value.","keywords":""},{"title":"BluetoothDiscoveryHandle","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdiscoveryhandle","content":"Description# The BluetoothDiscoveryHandle interface of the Bluetooth API is used to notify the current application about the discovery of a remote bluetooth device. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothDiscoveryHandle : EventTarget { attribute EventHandler ondevicefound; }; Copy Properties# BluetoothDiscoveryHandle.ondevicefound read-only no-linkDefines an event handler to trigger each time the devicefound event is fired; this occurs when a remote bluetooth device is discovered. Its parameter is either a BluetoothDeviceEvent or BluetoothLeDeviceEvent, depending on the type of device discovered.","keywords":""},{"title":"BluetoothGatt","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothgatt","content":"Description# The BluetoothGatt interface of the Bluetooth API handles initial communications and connections with Gatt services. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothGatt : EventTarget { [Cached, Pure] readonly attribute sequence<BluetoothGattService> services; readonly attribute BluetoothConnectionState connectionState; attribute EventHandler oncharacteristicchanged; attribute EventHandler onconnectionstatechanged; [NewObject] Promise<void> connect(); [NewObject] Promise<void> disconnect(); [NewObject] Promise<void> discoverServices(); [NewObject] Promise<short> readRemoteRssi(); }; Copy Properties# BluetoothGatt.services read-only no-linkReturns the list of GATT services offered by the remote LE device. This property is set to an empty array by default before a connection is established. BluetoothGatt.connectionState read-only no-linkThe current connection state of GATT client to the remote LE device. This property is set to disconnected by default, before a connection is established. Event handlers# BluetoothGatt.oncharacteristicchangedDefines a handler to trigger as a result of the characteristicchanged event firing; this occurs when a remote characteristic changes. BluetoothGatt.onconnectionstatechangedDefines a handler to trigger as a result of the connectionstatechanged event firing; this occurs when the connection state of the GATT client to the remote LE device (i.e. the BluetoothGatt.connectionState property) changes. Methods# BluetoothGatt.connect()Connects to the remote LE device. BluetoothGatt.disconnect()Disconnects an already-established connection to a remote LE device. BluetoothGatt.discoverServices()Discovers services, characteristics, and descriptors offered by the remote GATT server. BluetoothGatt.readRemoteRssi()Reads the RSSI for a connected remote LE device.","keywords":""},{"title":"Alarm","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/alarm/alarm","content":"Description# The Alarm API allows applications to schedule actions to be run in the future. For example, some applications like alarm-clock, calendar or auto-update might need to utilize the Alarm API to trigger particular device behaviors at specified time points. By itself, the Alarm API just allows to schedule alarms. An alarm is dispatched to applications through the System Message API, so applications which want to react to alarms have to register themselves to the alarm messages. Alarms are set using the Navigator.mozAlarms object which is an instance of the MozAlarmsManager interface. Note: The term alarm in the Alarms API is not the same as an alarm used by the Clock app. The Alarms API wakes up applications, the Clock wakes up humans. The Clock uses the Alarm API to be notified when the time is right to wake up humans. Schedule alarms# The first things to do when using alarm is to schedule alarms. There are two kind of alarms based on the respect of the time zone. In both case it's done using the MozAlarmsManager.add() method. Note: If an alarm is not targeted at a specific application, the system will dispatch all the alarms to all the applications listening for alarms. Note: You need to use the same URL for setting and receiving an alarm. For example, If you invoke navigator.mozAlarms.add() on foo.html or index.html?foo=bar, but have { \"alarm\": \"/index.html\" } in your manifest messages field, you'll never receive the alarm. Alarms ignoring time zones# Those kind of alarms is dispatched based on the local time of the device. If the user of the device changes its time zone, the alarm will be dispatched based on the new time zone. For example, if a user is in Paris and sets an alarm that should be dispatched at 12 PM CET (Central European Time) and that user travels to San Francisco, the alarm will be dispatched at 12 PM PDT (Pacific Daylight Time). // This the date to schedule the alarm var myDate = new Date('May 15, 2012 16:20:00'); // This is arbitrary data pass to the alarm var data = { foo: 'bar' }; // The \"ignoreTimezone\" string is what make the alarm ignoring it var request = navigator.mozAlarms.add(myDate, 'ignoreTimezone', data); request.onsuccess = function() { console.log('The alarm has been scheduled'); }; request.onerror = function() { console.log('An error occurred: ' + this.error.name); }; Copy Alarms honoring time zones# Those kind of alarms are dispatched based on the time in the time zone that defines when the alarm has been scheduled. If for some reason, the user of the device changes its time zone the alarm will be dispatched based on the original time zone. For example, if a user is in Paris and set an alarm that should be dispatched at 12pm CET (Central European Time) and if that user travel to San Francisco, the alarm will be dispatched at 3 AM PDT (Pacific Daylight Time). // This the date to schedule the alarm var myDate = new Date('May 15, 2012 16:20:00'); // This is arbitrary data pass to the alarm var data = { foo: 'bar' }; // The \"honorTimezone\" string is what make the alarm honoring it var request = navigator.mozAlarms.add(myDate, 'honorTimezone', data); request.onsuccess = function() { console.log('The alarm has been scheduled'); }; request.onerror = function() { console.log('An error occurred: ' + this.error.name); }; Copy Managing alarms# Once an alarm is scheduled, it's still possible to manage it. The MozAlarmsManager.getAll() method will return the complete list of alarms currently scheduled by the application. This list is an Array of mozAlarm objects. mozAlarm# Those objects are anonymous JavaScript objects with the following properties: id - A number representing the id of the alarm date - A Date object representing the scheduled time for the alarm respectTimezone - A string indicating if the alarm must respect or ignore the timezone information of the date object. Its value can be ignoreTimezone or honorTimezone data - A JavaScript object containing any data that were stored with the alarm var request = navigator.mozAlarms.getAll(); request.onsuccess = function() { this.result.forEach(function(alarm) { console.log('Id:', alarm.id); console.log('date:', alarm.date); console.log('respectTimezone:', alarm.respectTimezone); console.log('data:', JSON.stringify(alarm.data)); }); }; request.onerror = function() { console.log('An error occurred:', this.error.name); }; Copy The MozAlarmsManager.remove method is used to unschedule an existing alarm. var alarmId; // Set an alarm and store it's id var request = navigator.mozAlarms.add( new Date('May 15, 2012 16:20:00'), 'honorTimezone' ); request.onsuccess = function() { alarmId = this.result; }; // ... // Later on, removing the alarm if it exists if (alarmId) { navigator.mozAlarms.remove(alarmId); } Copy Handling alarms# Any application can react when an alarm is dispatched by the system. In order to be able to handle any alarms, an application must register itself as an alarm handler. This is done through the System Messaging API in two steps: First, the applications must include alarm to the messages property of its application manifest with the URL to the document which registers the callback function to be used when an alarm is dispatched. \"messages\": [ { \"alarm\": \"/index.html\" } ] Copy Second, the application must bind a callback function with the alarm message. This is done using the navigator.mozSetMessageHandler() method. This callback function will receive a mozAlarm object containing the data attached to the alarm. navigator.mozSetMessageHandler('alarm', function(mozAlarm) { alert('alarm fired:', JSON.stringify(mozAlarm.data)); }); Copy If an application wants to know if there is a pending alarm at the system level, it's possible to use the navigator.mozHasPendingMessage() method with the value alarm. navigator.mozHasPendingMessage('alarm'); Copy Permissions for the Alarm API# Please note that while the Alarm API is not privileged or certified, you should still include permissions and messages entries in your manifest.webapp file when including it in an installable open Web app. { \"permissions\": { \"alarms\": { \"description\": \"Required to schedule alarms\" } }, \"messages\": [ { \"alarm\": \"/index.html\" } ] } Copy","keywords":""},{"title":"BluetoothGattCharacteristicEvent","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothgattcharacteristicevent","content":"Description# The BluetoothGattCharacteristicEvent interface of the Bluetooth API provides access to an updated BluetoothGattCharacteristic object as the parameter of the BluetoothGatt.oncharacteristicchanged, handler, when the characteristicchanged event is fired. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothGattCharacteristicEvent : Event { readonly attribute BluetoothGattCharacteristic? characteristic; }; Copy Properties# BluetoothGattCharacteristicEvent.characteristic read-only no-linkReturns a BluetoothGattCharacteristic representing the characteristic that has been updated as a result of a remote notification event.","keywords":""},{"title":"BluetoothLeDeviceEvent","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothledeviceevent","content":"Description# The BluetoothLeDeviceEvent interface of the Bluetooth API provides access to an LE device BluetoothDevice object and its RSSI value and advertisement record, as the parameter of a devicefound event handler (see BluetoothDiscoveryHandle.ondevicefound), when fired. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothLeDeviceEvent : Event { readonly attribute BluetoothDevice? device; readonly attribute short rssi; [Throws] readonly attribute ArrayBuffer? scanRecord; }; Copy Properties# BluetoothLeDeviceEvent.device read-only no-linkReturns a BluetoothDevice representing the discovered remote LE device. BluetoothLeDeviceEvent.rssi read-only no-linkReturns the RSSI value for the remote LE device as reported by the bluetooth hardware. The value is given as 0 if no RSSI value is available. BluetoothLeDeviceEvent.scanRecord read-only no-linkReturns an ArrayBuffer representing the content of the advertisement record offered by the remote LE device.","keywords":""},{"title":"BluetoothStatusChangedEvent","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothstatuschangedevent","content":"Description# The BluetoothStatusChangedEvent API provides access to information regarding any change to the status of a Bluetooth device. A status change occurs when one of the following events is triggered: a2dpstatuschange : It occurs when an A2DP connection status changes. See BluetoothAdapter.ona2dpstatuschanged for more information.hfpstatuschange : It occurs when an HFP connection status changes. See BluetoothAdapter.onhfpstatuschanged for more information.scostatuschange : It occurs when an SCO connection status changes. See BluetoothAdapter.onscostatuschanged for more information. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothStatusChangedEvent : Event { readonly attribute DOMString address; readonly attribute boolean status; }; Copy Properties# BluetoothStatusChangedEvent.address read-only no-linkA string representing the address of the device for which the status has changed in the Bluetooth micro-network. BluetoothStatusChangedEvent.status read-only no-linkA boolean representing the current status of the connection. It can be enabled (true) or disabled (false).","keywords":""},{"title":"BluetoothManager","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothmanager","content":"Description# The BluetoothManager interface of the Bluetooth API allows to access all Bluetooth adapters available on the device. Adapters are the connection interface to connect a Bluetooth device to that device. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothManager: EventTarget { readonly attribute BluetoothAdapter? defaultAdapter; attribute EventHandler onattributechanged; attribute EventHandler onadapteradded; attribute EventHandler onadapterremoved; sequence<BluetoothAdapter> getAdapters(); }; Copy Properties# BluetoothManager.defaultAdapter read-only no-linkA BluetoothAdapter object selected by default. The value would be null if the device doesn't have any Bluetooth chip. Event Handlers# BluetoothManager.onadapteraddedA handler for the adapteradded event; it is triggered when a Bluetooth adapter is enabled on the device.BluetoothManager.onadapterremovedA handler for the adapterremoved event; it is triggered when a Bluetooth adapter is disabled on the device, or removed.BluetoothManager.onattributechangedA handler for the attributechanged event; it is triggered when the BluetoothManager.defaultAdapter property changes. Note: Because the BluetoothManager interface inherits from the EventTarget interface, all these events can be listened by using the addEventListener method. Methods# BluetoothManager.getAdapters()Returns a list of the current BluetoothAdapters in use on the device.","keywords":""},{"title":"BluetoothManager.onadapteradded","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothmanager/03.onadapteradded","content":"Description# Specifies an event listener to receive adapteradded events. Those events occur when a Bluetooth adapter is enabled on the device. Each time this event occurs, the BluetoothManager.getDefaultAdapter() method will be able to access the last enabled adapter. Syntax# navigator.mozBluetooth.onadapteradded = funcRef Copy Where funcRef is a function to be called when the adapteradded event occurs.","keywords":""},{"title":"BluetoothAdapter.unpair","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapter/22.unpair","content":"Description# The unpair method is used to remove the paired device from the paired device list of the device's adapter. Syntax# var request = instanceOfBluetoothAdapter.unpair(deviceAddress); Copy Parameters# deviceAddress The Bluetooth micro-network address of the device to unpair with. Returns# A DOMRequest object to handle the success or error of the operation.","keywords":""},{"title":"DataStore.name","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/01.name","content":"The name read-only property of the DataStore interface returns the name of the current data store. Syntax# myStoreName = store.name; Copy Value# A DOMString. Example# The following example gets all the data stores on the device called \"contacts\", then logs the data store name to the console: navigator.getDataStores('contacts').then(function(stores) { console.log(stores[0].name); }); Copy","keywords":""},{"title":"BluetoothDevice.onattributechanged","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdevice/11.onattributechanged","content":"Description# A handler to trigger when on of the remote device's properties has changed. Note access to the changed property in this event handler would get the updated value. Paramter# aAttributeEvent The event is a BluetoothAttributeEvent with property attrs that contains changed BluetoothDeviceAttributes. Sample# device.onattributechanged = function onDeviceAttributeChanged(evt) { for (var i in evt.attrs) { switch (evt.attrs[i]) { case 'name': console.log(\"device name changed to\", device.name); break; case 'paired': console.log(\"device paired changed to\", device.paired); break; default: break; } } } Copy","keywords":""},{"title":"BluetoothGattCharacteristic","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothgattcharacteristic","content":"Description# The BluetoothGattCharacteristic interface of the Bluetooth API represents a GATT service characteristic, which includes characteristic definition, value, properties and configuration info, and a list of descriptors that provide related information. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothGattCharacteristic { readonly attribute BluetoothGattService service; [Cached, Pure] readonly attribute sequence<BluetoothGattDescriptor> descriptors; readonly attribute DOMString uuid; readonly attribute unsigned short instanceId; readonly attribute ArrayBuffer? value; [Cached, Constant] readonly attribute Permissions permissions; [Cached, Constant] readonly attribute GattCharacteristicProperties properties; [NewObject] Promise<ArrayBuffer> readValue(); [NewObject] Promise<void> writeValue(ArrayBuffer value); [NewObject] Promise<void> startNotifications(); [NewObject] Promise<void> stopNotifications(); [NewObject] Promise<BluetoothGattDescriptor> addDescriptor(DOMString uuid, Permissions permissions, ArrayBuffer value); }; Copy Properties# BluetoothGattCharacteristic.service read-only no-linkReturns the BluetoothGattService that this characteristic belongs to. BluetoothGattCharacteristic.descriptors read-only no-linkReturns a cached array containing the BluetoothGattDescriptor objects that describe this characteristic. BluetoothGattCharacteristic.uuid read-only no-linkReturns a DOMString representing the UUID of this characteristic. BluetoothGattCharacteristic.instanceId read-only no-linkReturns a number representing the instance id of this characteristic. BluetoothGattCharacteristic.value read-only no-linkReturns The cached value of this characteristic. This value can be updated via the BluetoothGattCharacteristic.readValue() method, characteristic notification, or indication from the remote device. BluetoothGattCharacteristic.permissions read-only no-linkReturns a bit mask that describes the operations permitted on this characteristic. BluetoothGattCharacteristic.properties read-only no-linkReturns a bit mask that describes how to use the characteristic value. Methods# BluetoothGattCharacteristic.readValue()Reads the characteristic value from the remote device. The cached value property will also be updated after retrieving the value. BluetoothGattCharacteristic.writeValue()Writes the characteristic value to the GATT server. If the local device is the GATT client, the value will be written to the remote GATT server. On the other hand, if the local device is the GATT server, the value will be written to BluetoothGattCharacteristic.value. BluetoothGattCharacteristic.startNotifications()Registers notifications/indications for this characteristic. BluetoothGattCharacteristic.stopNotifications()Unregisters notifications/indications for this characteristic. BluetoothGattCharacteristic.addDescriptor()Adds a descriptor to this characteristic.","keywords":""},{"title":"Clients","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/clients/clients","content":"Description# The Clients interface of the Service Workers API represents a container for a list of Client objects. You should include an entry in your manifest.webapp file for Service Worker API including it in a KaiOS app. Methods:# Clients.get()Gets a service worker client matching a given id and returns it in a Promise. Clients.matchAll()Gets a list of service worker clients and returns them in a Promise. Include the options parameter to return all service worker clients whose origin is the same as the associated service worker's origin. If options are not included, the method returns only the service worker clients controlled by the service worker. Clients.openApp() Launches a web app with the same origin of its service worker scope. Clients.claim()Allows an active Service Worker to set itself as the active worker for a client page when the worker and the page are in the same scope. Examples# // When the user clicks a notification open the App if it does not exist onotificationclick = function(event) { var found = false; clients.matchAll().then(function(clients) { for (i = 0; i < clients.length; i++) { if (clients[i].url === event.data.url) { // do something else involving the matching client found = true; break; } } if (!found) { clients.openApp(); } }); }; }); Copy KaiOS manifest permissions# \"permissions\": { \"serviceworker\": { \"description\": \"Needed for assocating service worker\" }, \"desktop-notification\": { \"description\": \"Needed for creating system notifications.\" } }, \"messages\": [{\"serviceworker-notification\": \"path/to/your/index.html\"}] Copy","keywords":""},{"title":"BluetoothClassOfDevice","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothclassofdevice","content":"Description# The BluetoothClassOfDevice interface of the Bluetooth API provides identifying/classification information about a given remote Bluetooth device, available at discovery stage. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothClassOfDevice { // Major service class const unsigned short LIMITED_DISCOVERABILITY = 0x0001; const unsigned short POSITIONING = 0x0008; const unsigned short NETWORKING = 0x0010; const unsigned short RENDERING = 0x0020; const unsigned short CAPTURING = 0x0040; const unsigned short OBJECT_TRANSFER = 0x0080; const unsigned short AUDIO = 0x0100; const unsigned short TELEPHONY = 0x0200; const unsigned short INFORMATION = 0x0400; // Major device class const octet MISC = 0x00; const octet COMPUTER = 0x01; const octet PHONE = 0x02; const octet NETWORK = 0x03; const octet AUDIO_VIDEO = 0x04; const octet PERIPHERAL = 0x05; const octet IMAGING = 0x06; const octet WEARABLE = 0x07; const octet TOY = 0x08; const octet HEALTH = 0x09; const octet UNCATEGORIZED = 0x1F; readonly attribute unsigned short majorServiceClass; readonly attribute octet majorDeviceClass; readonly attribute octet minorDeviceClass; }; Copy Properties# BluetoothClassOfDevice.majorDeviceClass read-only no-linkRepresents the Major Device Class of the CoD field of a Bluetooth Device; \"the highest level of granularity for defining a Bluetooth device\". [1] BluetoothClassOfDevice.minorDeviceClass read-only no-linkRepresents the Minor Device Class of the CoD field of a Bluetooth Device; \"interpreted only in the context of the Major Device Class (but independently of the Service Class field)\". [1] BluetoothClassOfDevice.majorServiceClass read-only no-linkRepresents the Major Service Class of the CoD field of a Bluetooth Device; \"the general families of devices with which Bluetooth SIG members want their applications to be associated\". [1] [1] https://www.bluetooth.org/en-us/specification/assigned-numbers/baseband","keywords":""},{"title":"BluetoothDevice.paired","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdevice/07.paired","content":"Description# The paired property indicates if the device is paired to the current device's adapter (true) or not (false). Syntax# var paired = instanceOfBluetoothDevice.paired Copy Value# Return a boolean.","keywords":""},{"title":"BluetoothDevice.gatt","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdevice/10.gatt","content":"Description# The gatt property is an object to conduct GATT client operations on this remote LE device. This property will be a null pointer for devices of type classic or unknown. Value type# BluetoothGatt Default value# Null pointer Sample# var gatt = device.gatt; Copy","keywords":""},{"title":"BluetoothGattServer","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothgattserver","content":"Description# The BluetoothGattServer interface of the Bluetooth API provides Bluetooth GATT server functionality to allow creation of Bluetooth Smart/LE services and characteristics. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothGattServer { [Cached, Pure] readonly attribute sequence<BluetoothGattService> services; attribute EventHandler ondeviceconnectionstatechanged; attribute EventHandler onattributereadreq; attribute EventHandler onattributewritereq; [NewObject] Promise<void> connect(DOMString address); [NewObject] Promise<void> disconnect(DOMString address); [NewObject] Promise<void> addService(BluetoothGattService service); [NewObject] Promise<void> removeService(BluetoothGattService service); [NewObject] Promise<void> notifyCharacteristicChanged(DOMString address, DOMString uuid, int instanceId, bool confirm); [NewObject] Promise<void> sendResponse(DOMString address, int status, int requestId, ArrayBuffer value); }; Copy Properties# BluetoothGattServer.services read-only no-linkReturns an array of the services offered by this device. Event handlers# BluetoothGattServer.ondeviceconnectionstatechangedDefines a handler to trigger as a result of the deviceconnectionstatechanged event firing; this occurs when a remote LE device has been connected or disconnected. BluetoothGattServer.onattributereadreqDefines a handler to trigger as a result of the attributereadreq event firing; this occurs when a remote client has requested to read a server's characteristic or descriptor. BluetoothGattServer.onattributewritereqDefines a handler to trigger as a result of the attributewritereq event firing; this occurs when a remote client has requested to write a server's characteristic or descriptor. Methods# BluetoothGattServer.connect()Initiates a connection to a remote LE device. BluetoothGattServer.disconnect()Disconnects an already-established connection to a remote LE device. BluetoothGattServer.addservice()Adds a BluetoothGattService to the server's list of provided services. BluetoothGattServer.removeservice()Removes a BluetoothGattService from the server's list of provided services. BluetoothGattServer.notifyCharacteristicChanged()Sends a notification/indication that a local characteristic has been updated. BluetoothGattServer.sendResponse()Sends a response to a remote LE device's read or write request.","keywords":""},{"title":"BluetoothGattService","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothgattservice","content":"Description# The BluetoothGattService interface of the Bluetooth API represents a service provided by a GATT server, including the service definition, a list of referenced services, and a list of the characteristics of this service. Interface overview# [CheckAnyPermissions=\"bluetooth\", Constructor(boolean isPrimary, DOMString uuid)] interface BluetoothGattService { [Cached, Pure] readonly attribute sequence<BluetoothGattCharacteristic> characteristics; [Cached, Pure] readonly attribute sequence<BluetoothGattService> includedServices; readonly attribute boolean isPrimary; readonly attribute DOMString uuid; readonly attribute unsigned short instanceId; [NewObject] Promise<BluetoothGattCharacteristic> addCharacteristic(DOMString uuid, GattPermissions permissions, GattCharacteristicProperties properties, ArrayBuffer value); [NewObject] Promise<void> addIncludedService(BluetoothGattService service); }; Copy Properties# BluetoothGattService.characteristics read-only no-linkReturns a cached array of BluetoothServiceCharacteristic objects representing the characteristics of this service. BluetoothGattService.includedServices read-only no-linkReturns a cached array of BluetoothGattService objects representing the included services referenced by this service. BluetoothGattService.isPrimary read-only no-linkReturns a Boolean Indicating whether this is a primary or secondary service. The default value is false, indicating a secondary service. BluetoothGattService.uuid read-only no-linkReturns a DOMString representing the UUID of this service. BluetoothGattService.instanceId read-only no-linkReturns a number representing the instance id of this service. Methods# BluetoothGattService.addCharacteristic()Adds a characteristic to this service. BluetoothGattService.addIncludedService()Adds a referenced included service to this service.","keywords":""},{"title":"DataStore.revisionId","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/04.revisionid","content":"The revisionId read-only property of the DataStore interface returns the current data store's current revision ID. This ID can be tracked, allowing you to synchronize apps using the data store to this point in its history. Syntax# myStoreName = store.revisionId; Copy Value# A DOMString. Example# The following example gets all the data stores on the device called \"contacts\", then logs the current revision ID to the console: navigator.getDataStores('contacts').then(function(stores) { console.log(stores[0].revisionId); }); Copy","keywords":""},{"title":"DataStore.get()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/06.get","content":"The get() method of the DataStore interface retrieves one or more objects from the current data store. Syntax# store.get(1).then(function(obj) { // Do something with obj, which is the record retrieved from the data store }); Copy Returns# A Promise object of type DataStoreKey that resolves with either a specific record from the data store, or an array of records if multiple records were requested. Parameters# id get() can passed one or more ids of specific records that you want to retrieve from the data store. When you want to retrieve multiple ids, you pass them in as multiple parameters, rather than an array or object, e.g. get(1,2,3). Example# The following example gets all the data stores on the device called \"contacts\", then requests the first three records stored in the first \"contacts\" data store and prints them out to the console: navigator.getDataStores('contacts').then(function(stores) { stores[0].get(1,2,3).then(function(obj) { for(i = 0; i <= obj.length; i++) { console.log(i); } }); }); Copy","keywords":""},{"title":"DataStore.owner","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/02.owner","content":"The owner read-only property of the DataStore interface returns the name of the app that owns the current data store. Syntax# myStoreOwner = store.owner; Copy Value# A DOMString. Example# The following example gets all the data stores on the device called \"contacts\", then logs the data store owner to the console: navigator.getDataStores('contacts').then(function(stores) { console.log(stores[0].owner); }); Copy","keywords":""},{"title":"DataStore","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore","content":"Description# The DataStore interface of the Data Store API represents a retrieved set of data, and includes standard properties for accessing the store's name, owner, etc., methods for reading, modifying and syncing data, and the onchange event handler for reacting to changes to the data. Properties# DataStore.name read-onlyReturns the name of the current data store.DataStore.owner read-onlyReturns the name of the app that owns the data store.DataStore.readOnly read-onlyReturns a boolean that signifies whether the data store is read only or not.DataStore.revisionId read-onlyReturns the current revision ID of the data store. Event handlers# DataStore.onchange read-onlyFired when a change is made to the data store, by any app that has permission to modify it. Methods# DataStore.get()Returns a specific record (or list of records) from the data store.DataStore.add()Adds a new record to the data store; if the record you are attempting to add already exists, it will throw an exception.DataStore.put()Updates an existing record in the data store.DataStore.remove()Deletes a record (or list of records) from the data storeDataStore.clear()Deletes all records from the data store, leaving it empty.DataStore.getLength() Returns the number of records currently in the data store.DataStore.sync()Opens a cursor that allows you to step through any changes that have taken place in the data store going back to a particular revision ID, and run code in response to different types of change. Example# In the following example, we use navigator.getDataStores to return a list of DataStore objects representing data stores on the device called contacts. Since there is only one such data store, we can access it inside the outer promise using stores[0]. The next promise uses DataStore.getLength to return the number of records in the store. If the value is 0, we populate the data store with records contained in the contactsInit object; if there is already data in the store, we run DataStore.sync to loop through any additions since the code last accessed the data store and update the data display as necessary. navigator.getDataStores('contacts').then(function(stores) { stores[0].getLength().then(function(storeLength) { if(storeLength == 0) { for(i = 0; i < contactsInit.length; i++) { addContact(stores[0],contactsInit[i]); }; } else { var cursor = stores[0].sync(); runNextTask(cursor); } }); }); Copy","keywords":""},{"title":"Data Store","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/data-store","content":"Description# The Data Store API provides a powerful, flexible storage mechanism for KaiOS applications to use to store and share data. It is basically an intermediary store to allow multiple applications to share data between one another quickly, efficiently, and securely, in spite of differences between API data structures, formats, etc. Data Store API concepts and usage The Data Store API was created to allow multiple KaiOS apps, with potentially different data structures and storage mechanisms, to create, maintain and share the same data objects efficiently between one another. Each app can then import the data into its own local IndexedDB to index according to their specific query needs. This is not necessary however, and you can just write directly to the Data Store API data store. Note: The Data Store API is available in Web Workers There are several possible reasons to use this API, including: It lets an application create data that it can then share with other applications.It lets multiple applications supply data to the same data store.It supports read-only data stores such as Facebook contacts (that is, it lets one app create and maintain the data while other apps can read the data from the store).It supports read/write data stores, so that multiple applications can contribute data to the same data store. An example would be the device's standard contacts, which can be updated by both the built-in Contacts app and third-party apps.It supports keeping an application-locale cache of a data store, with notifications to let the app know when there have been changes to the master data store so that the cache can be updated. This Data Store API datastore is owned by a specific app (as specified by the datastores-owned field in the app's manifest — see Manifest_fields, below), and this ownership gives the app the right to populate the data store and declare whether the data store is readonly (meaning other apps can only read the data) or readwrite (meaning other apps can modify the data as well as read it.) Other apps can gain access to a datastore by naming it in the datastores-access field of their app manifest. When an app wants to access a datastore, it has to call Navigator.getDataStores(); The result value of this method is a Promise object that will resolve with an array of DataStore objects. From these DataStore objects, the app can read and modify values using various methods of the DataStore such as DataStore.get() and DataStore.insert(). Note: The Data Store API currently has no imposed limitations on storage space. This is likely to be updated in the near future. Change management and conflict resolution# When multiple apps make changes to a Data Store, it could create conflicts. However, any change you make (using DataStore.update(), DataStore.add(), etc.) is given a revisionId, a UUID received in the change event fired whenever a operation is performed on the Data Store by any app with access to it. This can be read from the DataStore.revisionId property. The revisionId property can be included as an optional parameter in the DataStore.add(), DataStore.put(), DataStore.remove(), DataStore.clear(), and DataStore.sync() methods. Doing so basically uses that revisionId as a conflict avoider — the operation is aborted if that revisionId is not the last one known by the Data Store (i.e. if another app has made a more recent change). When the change event is fired, it receives a DataStoreChangeEvent object, giving the app access to: DataStoreChangeEvent.revisionId: The last known revisionId.DataStoreChangeEvent.id: The key of the changed object, which can be null if the operation was a clear().DataStoreChangeEvent.operation: The operation that was performed — add(), remove(), etc.DataStoreChangeEvent.owner: The manifest URL of the app that performed this operation. When an app wants to see what has changed, it can do it by asking for the ‘delta’ between the last known revisionId and the current one. This is done using the DataStore.sync() method. You can allow your apps to deal with data changes by running a sync() on application startup and onchange, passing it the current revisionId to check against. Filtering data# As hinted at above, the Data Store API is not responsible for filtering data or building indexes; instead it leaves this up to the the app's local storage mechanism (usually an IndexedDB); The Data Store API simply allows the local indexes to be kept up to date, via the DataStoreCursor object, created when sync() is invoked. Properties# Manifest fields# The data store owner's manifest MUST include the datastores-owned field to claim ownership, for example: \"datastores-owned\": { \"myData\": { \"access\": \"readwrite\", \"description\": \"my data store\" } } Copy You can include multiple properties to represent different data stores, and each one can use readonly/readwrite to specify whether the data store can be read/modified by other applications. A description is also included to describe the purpose of the data store. Other applications that want to access (not own) the data store must include the datastores-access field, for example: \"datastores-access\": { \"myData\": { \"access\": \"readonly\", \"description\": \"Read and modify my data store\" } } Copy Without this field being specified, the default behavior is \"no access\". Again, multiple properties can be included if you want to access multiple data stores, and an access of readonly or readwrite can be set to declare what access type is needed by the app. In terms of permissions, the Data Store owner always wins against the 3rd party apps. if the owner declares \"readonly\": true in its manifest, any 3rd party app will be in readonly mode also, even if they declare \"access\": \"readwrite\" in their manifests. Of course, this isn’t much use if the owner allows the Data Store to be modified by third party apps, so for the moment, Data Store is a certified API. It is likely to come down to privileged when the security model is finalized. Note: Remember also that in such cases you need to use the type field in your manifest to explicitly declare that your app is an internal/certified app: \"type\": \"certified\". DataStore API Interfaces# The Data Store API contains the following interfaces: DataStore The DataStore interface represents a retrieved set of data, and includes standard properties for accessing the store's name, owner, etc., methods for reading, modifying and syncing the data, and the onchange event handler for reacting to changes to the data.DataStoreCursor This interface allows the app to iterate through a list of DataStoreTask objects representing the change history of the data store, for use when synchronising the data.DataStoreChangeEvent This interface represents the event related to a record changed in the data store, i.e. this is returned once a change is made and the change event is fired (see DataStore.onchange for the handler), for use when synchronizing individual changes.DataStoreTask This interface represents a record changed in the data store when a DataStoreCursor is used to iterate through the data store's change history. Methods# Examples# We have written a couple of examples that go together, to explain how different apps can make different use of the same data store: The Data Store Contacts Editor creates a data store called 'contacts' on the device it is installed on, adds some default data to it, and allows the user to add new contacts to the store and delete contacts.The Data Store Contacts Viewer has readonly access to the 'contacts' data store; it grabs data from it and displays it in a user interface, along with a Google map of the selected user's location, displayed in an <iframe> to get around certified app CSP restrictions. Keep referring to these examples and read Using the Data Store API for explanations and code samples. Note: Be aware that to test data store examples you need to make sure your apps are internal/certified (see above for manifest fields needed), and use App Manager or WebIDE to simulate an environment where a internal/certified app can be run. Follow these links to find out how to do this using each tool: App Manager: Debugging Certified Apps and WebIDE: Debugging Certified Apps.","keywords":""},{"title":"BluetoothAdapterEvent","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothadapterevent","content":"Description# The BluetoothAdapterEvent interface of the Bluetooth API provides access to a BluetoothAdapter object and its address as the parameter of a adapteradded or adapterremoved event handler (see BluetoothManager.onadapteradded and BluetoothManager.onadapterremoved), when fired. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothAdapterEvent : Event { readonly attribute BluetoothAdapter? adapter; readonly attribute DOMString? address; }; Copy Properties# BluetoothAdapterEvent.adapter read-only no-linkReturns the BluetoothAdapter object. This is null for the BluetoothManager.onadapterremoved event handler since the corresponding adapter is already removed. BluetoothAdapterEvent.address read-only no-linkReturns a DOMString representing the address of the removed adapter. The property is null for the BluetoothManager.onadapteradded event handler since the adapter already has an BluetoothAdapter.address property.","keywords":""},{"title":"DataStoreChangeEvent.owner","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastorechangeevent/owner","content":"The owner read-only property of the DataStoreChangeEvent interface returns the manifest URL of the application that made the change to the data store. Note: The Data Store API is available in Web Workers, from Firefox 32 onwards Syntax# myOwner = e.owner; Copy Value# A DOMString. Example# In the following snippet we retrieve all the data stores on the device with the name \"contacts\", then we use DataStore.sync to create a cursor to use for syncing the app with the current \"content\" data store (displaying new items, etc.) This cursor is passed to the runNextTask() function that will deal with running through the updates in some way. Next, we include some code inside an onchange function so that when a change is made we return the DataStoreChangeEvent (e in this case), find out what type of operation the change is, and then take action based on this type (either adding or deleting a contact's information.) e.owner is logged to the console, just inside the onchange block. navigator.getDataStores('contacts').then(function(stores) { var cursor = stores[0].sync(); runNextTask(cursor); stores[0].onchange = function(e) { console.log(e.owner); if (e.operation == 'removed') { // Delete the contact deleteContact(e.id); } if (e.operation == 'added') { stores[0].get(e.id).then(function(obj) { // Add the new contact loadData(obj,e.id); }); } } }); Copy","keywords":""},{"title":"DataStoreChangeEvent","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastorechangeevent","content":"Description# The DataStoreChangeEvent interface of the Data Store API represents the event related to a record changed in the data store, i.e. this is returned once a change is made and the change event is fired (see DataStore.onchange for the handler). Properties# DataStoreChangeEvent.id read-only Returns the identifier of the changed record in the data store. Must return null if the operation is cleared.DataStoreChangeEvent.operation read-only Returns the type of operation that represents the current change that has been made to the data store.DataStoreChangeEvent.owner read-only Returns the manifest URL of the application that made the change to the data store.DataStoreChangeEvent.revisionId read-only Returns the id of the current revision of the data store, i.e. the current change that has been made to a data record. Example# In the following snippet we retrieve all the data stores on the device with the name \"contacts\", then we use DataStore.sync to create a cursor to use for syncing the app with the current \"content\" data store (displaying new items, etc.) This cursor is passed to the runNextTask() function that will deal with running through the updates in some way. Next, we include some code inside an onchange function so that when a change is made we return the DataStoreChangeEvent (e in this case), find out what type of operation the change is, and then take action based on this type (either adding or deleting a contact's information.) navigator.getDataStores('contacts').then(function(stores) { var cursor = stores[0].sync(); runNextTask(cursor); stores[0].onchange = function(e) { if (e.operation == 'removed') { // Delete the contact deleteContact(e.id); } if (e.operation == 'added') { stores[0].get(e.id).then(function(obj) { // Add the new contact loadData(obj,e.id); }); } } }); Copy Operation types# The different operation types used in DataStoreChangeEvent are (see also the spec definitions): Enumaration\tDescriptionadded\tThe record is added into the data store. updated\tThe record is updated in the data store. removed\tThe record is deleted from the data store. cleared\tAll records are deleted from the data store.","keywords":""},{"title":"DataStoreChangeEvent.id","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastorechangeevent/id","content":"The id read-only property of the DataStoreChangeEvent interface returns the identifier of the changed record in the data store. This must return null if the operation is cleared. Note: The Data Store API is available in Web Workers, from Firefox 32 onwards Syntax# myId = e.id; Copy Value# A DataStoreKey. Example# In the following snippet we retrieve all the data stores on the device with the name \"contacts\", then we use DataStore.sync to create a cursor to use for syncing the app with the current \"content\" data store (displaying new items, etc.) This cursor is passed to the runNextTask() function that will deal with running through the updates in some way. Next, we include some code inside an onchange function so that when a change is made we return the DataStoreChangeEvent (e in this case), find out what type of task the change was, and then take action based on this type (either adding or deleting a contact's information.) The deleteContact() and loadContact() functions are passed e.id to use in their functionality. navigator.getDataStores('contacts').then(function(stores) { var cursor = stores[0].sync(); runNextTask(cursor); stores[0].onchange = function(e) { if (e.operation == 'removed') { // Delete the contact deleteContact(e.id); } if (e.operation == 'added') { stores[0].get(e.id).then(function(obj) { // Add the new contact loadData(obj,e.id); }); } } }); Copy","keywords":""},{"title":"Clients.openApp()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/clients/01.openapp","content":"The openApp() method of the Clients interface launches a web app with the same origin of its service worker scope. The web app will be launched in the foreground and received a serviceworker-notification system message if contained. Syntax# ServiceWorkerClients.openApp(event) Copy Parameters# event Optional An event object allowing you to send a serviceworker-notification system message to the App. msgIt is a DOMString Return value# A Promise that resolves to a null value Examples# // When the user clicks a notification open the App if it does not exist onotificationclick = function(event) { var found = false; clients.matchAll().then(function(clients) { for (i = 0; i < clients.length; i++) { if (clients[i].url === event.data.url) { // do something else involving the matching client found = true; break; } } if (!found) { var openAppEvent = { msg: \"Your message\" } clients.openApp(openAppEvent); } }); }; }); Copy","keywords":""},{"title":"DataStore.readOnly","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/03.readonly","content":"The readOnly read-only property of the DataStore interface returns a boolean indicating whether the current data store is read-only. Syntax# myStoreName = store.readOnly; Copy Value# A boolean. Example# The following example gets all the data stores on the device called \"contacts\", then logs its read-only status to the console: navigator.getDataStores('contacts').then(function(stores) { console.log(stores[0].readOnly); }); Copy","keywords":""},{"title":"BluetoothDeviceEvent","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/bluetooth/bluetoothdeviceevent","content":"Description# The BluetoothDeviceEvent interface of the Web Bluetooth API provides access to a found/paired device (BluetoothDevice) object or the address or an unpaired device as the parameter of a devicefound, devicepaired or deviceunpaired event handler (see BluetoothDiscoveryHandle.ondevicefound, BluetoothAdapter.ondevicepaired, and BluetoothAdapter.ondeviceunpaired), when fired. Interface overview# [CheckAnyPermissions=\"bluetooth\"] interface BluetoothDeviceEvent : Event { readonly attribute BluetoothDevice? device; readonly attribute DOMString? address; }; Copy Properties# BluetoothDeviceEvent.device read-only no-linkReturns a BluetoothDevice object representing the paired remote device. Returns null for the BluetoothAdapter.ondeviceunpaired event handler since the that only requires the address of the unpaired device. BluetoothDeviceEvent.address read-only no-linkReturns a DOMString representing the address of the unpaired remote device. Returns null for the BluetoothDiscoveryHandle.ondevicefound and BluetoothAdapter.ondevicepaired event handlers since a found/paired remote device already has an BluetoothDevice.address property.","keywords":""},{"title":"DataStoreCursor","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastorecursor","content":"Description# The DataStoreCursor interface of the Data Store API represents a cursor that allows apps to iterate through a list of DataStoreTask objects representing the change history of the data store, for use when synchronizing the data. Properties# DataStoreCursor.store read-only Returns the name of the store that the cursor is iterating over. Methods# DataStoreCursor.next() Makes a request to retrieve information about the next operation that changes a record in the data store. Returns a Promise of type DataStoreTask.DataStoreCursor.close() Makes a request to terminate the cursor. Example# In the following example, we use navigator.getDataStores to return a list of DataStore objects representing data stores on the device called contacts. Since there is only one such data store, we can access it inside the outer promise using stores[0]. The next promise uses DataStore.getLength to return the number of records in the store. If the value is 0, we populate the data store with records contained in the contactsInit object; if there is already data in the store, we run DataStore.sync to create a DataStoreCursor object allowing us to loop through any additions since the code last accessed the data store and update the data display as necessary. The cursor is passed to the runNextTask() function, which calls DataStoreCursor.next to start the process of managing the next task — the resulting DataStoreTask object is passed to the manageTask() function to work out what to do with it. runNextTask() is then called repeatedly by manageTask() until the cursor has finished working through all the records. navigator.getDataStores('contacts').then(function(stores) { stores[0].getLength().then(function(storeLength) { if(storeLength == 0) { for(i = 0; i < contactsInit.length; i++) { addContact(stores[0],contactsInit[i]); }; } else { var cursor = stores[0].sync(); runNextTask(cursor); } }); }); function runNextTask(cursor) { cursor.next().then(function(task) { manageTask(cursor, task); }); } function manageTask(cursor, task) { if (task.operation == 'done') { // Finished adding contacts! return; } if (task.operation == 'add') { // Add the contacts that are different to how it was before displayExisting(task.id, task.data); } runNextTask(cursor); } Copy","keywords":""},{"title":"DataStore.getLength()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/11.getlength","content":"The getLength() method of the DataStore interface returns the number of records stored in the current data store. Syntax# store.getLength().then(function(storeLength) { // Do something with storeLength }); Copy Returns# A Promise object of type unsigned long that resolves with a numeric variable containing the number of records stored in the current data store. Example# In the following example, we use navigator.getDataStores to return a list of DataStore objects representing data stores on the device called contacts. Since there is only one such data store, we can access it inside the outer promise using stores[0]. The next promise uses DataStore.getLength to return the number of records in the store. If the value is 0, we populate the data store with records contained in the contactsInit object; if there is already data in the store, we run DataStore.sync to loop through any additions since the code last accessed the data store and update the data display as necessary. navigator.getDataStores('contacts').then(function(stores) { stores[0].getLength().then(function(storeLength) { if(storeLength == 0) { for(i = 0; i < contactsInit.length; i++) { addContact(stores[0],contactsInit[i]); }; } else { var cursor = stores[0].sync(); runNextTask(cursor); } }); }); Copy","keywords":""},{"title":"DataStore.put()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/08.put","content":"The put() method of the DataStore interface updates an existing record in the data store. Syntax# store.put(obj, id).then(function(id) { // Do something with id, which is the id of the updated object }); Copy Returns# A Promise object of type void that resolves with the ID of the updated object. Parameters# obj The object containing the data you want to update the record's value to.id The id of the record to be updated. This will be either a DataStoreKey of type unsigned long or DOMString, if an id was specified by the developer when the record was created, or a numeric id if not.revisionId You can specify an optional third parameter that will be a revisionId (a DOMString). This can be used to prevent conflicts. If the revisionId is not the current revisionId for the current Data Store, the operation is aborted. This means that the developer has a 'old' revisionId and will have to manage the conflict somehow. Example# The following example gets all the data stores on the device called \"contacts\", then updates a single record in the first \"contacts\" data store with the data available in the obj variable. navigator.getDataStores('contacts').then(function(stores) { stores[0].put(obj,1).then(function(id) { // object successfully updated }); }); Copy","keywords":""},{"title":"DataStoreCursor.store()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastorecursor/store","content":"The store read-only property of the DataStoreCursor interface returns the name of the store that the cursor is iterating over. Note: The Data Store API is available in Web Workers, from Firefox 32 onwards Syntax# myStore = cursor.store; Copy Value# A DataStore object. Example# In the following example, we use navigator.getDataStores to return a list of DataStore objects representing data stores on the device called contacts. Since there is only one such data store, we can access it using stores[0]. Next we run DataStore.sync to create a DataStoreCursor object, then use cursor.store to return back the store name. navigator.getDataStores('contacts').then(function(stores) { var cursor = stores[0].sync(); console.log(cursor.store); }); Copy","keywords":""},{"title":"DataStore.onchange","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/05.onchange","content":"The onchange event handler of the DataStore interface fires when a change is made to the data store. Its main use is to synchronize different apps that are using the data store when a change is made. When fired, this event returns a DataStoreChangeEvent, which can be used to handle the change that was just made. Alternatively, when the event fires you could create a DataStoreCursor and iterate through all the records, if needed. Syntax# store.onchange = function() { // run some code to sync apps that use the data store } Copy Example# This section shows two approaches to handling the same problem — syncing data when another application makes a change to the data store. In our first snippet, we retrieve all the data stores on the device with the name \"contacts\", then we use DataStore.sync to create a cursor to use for syncing the app with the current \"content\" data store (displaying new items, etc.) This cursor is passed to the runNextTask() function that will deal with running through the updates in some way. Next, we include some code inside an onchange function so that when a change is made we return the DataStoreChangeEvent, find out what type of task the change was, and then take action based on this type (either adding or deleting a contact's information.) navigator.getDataStores('contacts').then(function(stores) { var cursor = stores[0].sync(); runNextTask(cursor); stores[0].onchange = function(e) { if (e.operation == 'removed') { // Delete the contact deleteContact(e.id); } if (e.operation == 'added') { stores[0].get(e.id).then(function(obj) { // Add the new contact loadData(obj,e.id); }); } } }); Copy In the second snippet, we retrieve all the data stores on the device with the name \"contacts\", then we use DataStore.sync to create a cursor to use for syncing the app with the current \"content\" data store (displaying new items, etc.) This cursor is passed to the runNextTask() function that will deal with running through the updates in some way. Next, we include the same code inside an onchange function , so that if a change is made to the data store by any app that uses it, the syncing process will be run again. navigator.getDataStores('contacts').then(function(stores) { var cursor = stores[0].sync(); runNextTask(cursor); stores[0].onchange = function() { contactList.innerHTML = ''; var cursor = stores[0].sync(); runNextTask(cursor); } }); Copy","keywords":""},{"title":"DataStoreCursor.close()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastorecursor/close","content":"The close() method of the DataStoreCursor interface makes a request to terminate the cursor. Note: The Data Store API is available in Web Workers, from Firefox 32 onwards Syntax# cursor.close(); Copy Returns# Void. Example# In the following example, we run DataStore.sync() to create a DataStoreCursor object allowing us to loop through any additions since the code last accessed the data store and update the data display as necessary. The cursor is passed to the runNextTask() function, which calls DataStoreCursor.next to start the process of managing the next task — the resulting DataStoreTask object is passed to the manageTask() function to work out what to do with it. runNextTask() is then called repeatedly by manageTask() until the cursor has finished working through all the records. If an operation of type clear is found, cursor.close() is called to close the cursor. var cursor = stores[0].sync(); runNextTask(cursor); function runNextTask(cursor) { cursor.next().then(function(task) { manageTask(cursor, task); }); } function manageTask(cursor, task) { if (task.operation == 'done') { // Finished adding contacts! return; } if (task.operation == 'add') { // Add the contacts that are different to how it was before displayExisting(task.id, task.data); } if (task.operation == 'clear') { // If one of the changes deletes the entire data store's contents, // then close the cursor cursor.close(); } runNextTask(cursor); } Copy","keywords":""},{"title":"DataStoreChangeEvent.revisionId","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastorechangeevent/revisionid","content":"The revisionId read-only property of the DataStoreChangeEvent interface returns the ID of the current revision of the data store, i.e. the current change that has been made to a data record. Note: The Data Store API is available in Web Workers, from Firefox 32 onwards Syntax# myRevision = e.revisionId; Copy Value# A DOMString. Example# In the following snippet we retrieve all the data stores on the device with the name \"contacts\", then we use DataStore.sync to create a cursor to use for syncing the app with the current \"content\" data store (displaying new items, etc.) This cursor is passed to the runNextTask() function that will deal with running through the updates in some way. Next, we include some code inside an onchange function so that when a change is made we return the DataStoreChangeEvent (e in this case), find out what type of operation the change is, and then take action based on this type (either adding or deleting a contact's information.) e.revisionId is logged to the console, just inside the onchange block. navigator.getDataStores('contacts').then(function(stores) { var cursor = stores[0].sync(); runNextTask(cursor); stores[0].onchange = function(e) { console.log(e.revisionId); if (e.operation == 'removed') { // Delete the contact deleteContact(e.id); } if (e.operation == 'added') { stores[0].get(e.id).then(function(obj) { // Add the new contact loadData(obj,e.id); }); } } }); Copy","keywords":""},{"title":"DataStore.add()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/07.add","content":"The add() method of the DataStore interface adds a new record to the data store; if the record you are attempting to add already exists, it will throw an exception. Syntax# store.add(object).then(function(id) { // Do something with id, which is the id of the record added to the data store }); Copy Returns# A Promise object of type DataStoreKey that resolves with a ID number identifying the record added to the store. Parameters# object The object you want to add to the data store.id You can specify an optional second parameter that will be a DataStoreKey of type unsigned long or DOMString, if you want to give the added record a specific id. If you don't specify this, the object's id will be numeric (auto incremented).revisionId You can specify an optional third parameter that will be a revisionId (a DOMString). This can be used to prevent conflicts. If the revisionId is not the current revisionId for the current Data Store, the operation is aborted. This means that the developer has a 'old' revisionId and will have to manage the conflict somehow. Example# The following example function takes the current data store and an object to be added to the data store as arguments, adds the object to the store, and then creates a table row to display the object data in the app and appends it to an existing table in the DOM: function addContact(store, obj) { store.add(obj).then(function(id) { var tableRow = document.createElement('tr'); tableRow.innerHTML = '<td>' + obj.lName + '</td><td>' + obj.fName + '</td><td>' + obj.phone + '</td><td>' + obj.email + '</td><td>' + obj.address + '</td>'; tBody.appendChild(tableRow); var myId = id; console.log(myId); tableRow.setAttribute('data-id', myId); tableRow.onclick = function(event) { deleteItem(event); } }); } Copy","keywords":""},{"title":"DataStoreChangeEvent.operation","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastorechangeevent/operation","content":"The operation read-only property of the DataStoreChangeEvent interface returns the type of operation that represents the current change that has been made to the data store. Note: The Data Store API is available in Web Workers, from Firefox 32 onwards Syntax# myOperation = e.operation; Copy Value# A DataStoreOperation (see Operation types). Example# In the following snippet we retrieve all the data stores on the device with the name \"contacts\", then we use DataStore.sync to create a cursor to use for syncing the app with the current \"content\" data store (displaying new items, etc.) This cursor is passed to the runNextTask() function that will deal with running through the updates in some way. Next, we include some code inside an onchange function so that when a change is made we return the DataStoreChangeEvent (e in this case), find out what type of operation the change is, and then take action based on this type (either adding or deleting a contact's information.) e.operation is used to check what type of operation the current change is. navigator.getDataStores('contacts').then(function(stores) { var cursor = stores[0].sync(); runNextTask(cursor); stores[0].onchange = function(e) { if (e.operation == 'removed') { // Delete the contact deleteContact(e.id); } if (e.operation == 'added') { stores[0].get(e.id).then(function(obj) { // Add the new contact loadData(obj,e.id); }); } } }); Copy","keywords":""},{"title":"DataStore.sync()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/12.sync","content":"The sync() method of the DataStore interface opens a cursor that allows you to step through any changes that have taken place in the data store going back to a particular revision ID, and run code in response to different types of change. Syntax# var cursor = stores[0].sync(3); Copy Returns# A DataStoreCursor object. Parameters# revisionId Optional You can optionally pass sync() a revision ID that specifies the place in the revision history to go back to when running through the tasks. If you don't specify this, it runs through all tasks going back to the beginning of the history. Example# In the following example, we create a cursor using sync(), then invoke the runNextTask() function to run the next task in the cursor. In this function, the DataStoreCursor.next method is used to retrieve the next task (a DataStoreTask object), then the manageTask() function checks what type of task it is, and takes action accordingly. In this case, we are either done running through the tasks, in which case we return, or the task is an addition, in which case we run a function to display that addition in the app UI then move on to the next task by running runNextTask() again. var cursor = stores[0].sync(); runNextTask(cursor); function runNextTask(cursor) { cursor.next().then(function(task) { manageTask(cursor, task); }); } function manageTask(cursor, task) { if (task.operation == 'done') { // Finished adding contacts! return; } if (task.operation == 'add') { // Add the contacts that are different to how it was before displayExisting(task.id, task.data); } runNextTask(cursor); } Copy","keywords":""},{"title":"DataStore.remove()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/09.remove","content":"The remove() method of the DataStore interface deletes one or more objects from the current data store. Syntax# store.remove(1).then(function(success) { // Do something with success, which is a boolean communicating // the result of whether the deletion was successful or not }); Copy Returns# A Promise object of type Boolean that resolves with a boolean communicating the result of whether the deletion was successful or not. Parameters# id remove() can be passed one or more ids of specific records that you want to delete from the data store. When you want to delete multiple ids, you pass them in as multiple parameters, rather than an array or object, e.g. remove(1,2,3).revisionId You can specify an optional second parameter that will be a revisionId (a DOMString). This can be used to prevent conflicts. If the revisionId is not the current revisionId for the current Data Store, the operation is aborted. This means that the developer has a 'old' revisionId and will have to manage the conflict somehow. Example# The following example gets all the data stores on the device called \"contacts\", then removes the first three records stored in the first \"contacts\" data store: navigator.getDataStores('contacts').then(function(stores) { stores[0].remove(1,2,3).then(function(success) { if(success) { console.log('Records successfully removed.'); }; }); }); Copy","keywords":""},{"title":"DataStoreCursor.next()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastorecursor/next","content":"Description# The next() method of the DataStoreCursor interface makes a request to retrieve information about the next operation that changes a record in the data store. Returns a promise of type DataStoreTask. Note: The Data Store API is available in Web Workers, from Firefox 32 onwards Syntax# cursor.next().then(function(task) { // do stuff with next task in the cursor }); Copy Returns# A Promise object of type DataStoreTask; it resolves with a DataStoreTask object representing the next operation. Example# In the following example, we use navigator.getDataStores to return a list of DataStore objects representing data stores on the device called contacts. Since there is only one such data store, we can access it inside the outer promise using stores[0]. The next promise uses DataStore.getLength to return the number of records in the store. If the value is 0, we populate the data store with records contained in the contactsInit object; if there is already data in the store, we run DataStore.sync to create a DataStoreCursor object allowing us to loop through any additions since the code last accessed the data store and update the data display as necessary. The cursor is passed to the runNextTask() function, which calls DataStoreCursor.next to start the process of managing the next task — the resulting DataStoreTask object is passed to the manageTask() function to work out what to do with it. runNextTask() is then called repeatedly by manageTask() until the cursor has finished working through all the records. navigator.getDataStores('contacts').then(function(stores) { stores[0].getLength().then(function(storeLength) { if(storeLength == 0) { for(i = 0; i < contactsInit.length; i++) { addContact(stores[0],contactsInit[i]); }; } else { var cursor = stores[0].sync(); runNextTask(cursor); } }); }); function runNextTask(cursor) { cursor.next().then(function(task) { manageTask(cursor, task); }); } function manageTask(cursor, task) { if (task.operation == 'done') { // Finished adding contacts! return; } if (task.operation == 'add') { // Add the contacts that are different to how it was before displayExisting(task.id, task.data); } runNextTask(cursor); } Copy","keywords":""},{"title":"DataStore.clear()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastore/10.clear","content":"The clear() method of the DataStore interface deletes all records from the data store, leaving it empty. Syntax# store.clear().then(function(success) { // Do something with success, which is a boolean // reporting whether the deletion was successful or not } Copy Returns# A Promise object of type void that resolves with boolean reporting whether the deletion was successful or not. Parameters# revisionId You can specify an optional parameter that will be a revisionId (a DOMString). This can be used to prevent conflicts. If the revisionId is not the current revisionId for the current Data Store, the operation is aborted. This means that the developer has a 'old' revisionId and will have to manage the conflict somehow. Example# The following example gets all the data stores on the device called \"contacts\", then deletes all the content in the first \"contacts\" data store: navigator.getDataStores('contacts').then(function(stores) { stores[0].clear.then(function(success) { if(success) { console.log('Contacts successfully cleared.'); }; }); }); Copy","keywords":""},{"title":"DataStoreTask","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastoretask","content":"Description# The DataStoreTask interface of the Data Store API represents a record changed in the data store when a DataStoreCursor is used to iterate through the data store's change history. Properties# DataStoreTask.data read-only Returns the data stored in the changed record in the data store. Must return null if the operation is clear or done.DataStoreTask.id read-only Returns the identifier of the changed record in the data store. Must return null if the operation is clear or done.DataStoreTask.operation read-only Returns the type of operation that represents the current change that has been made to the data store.DataStoreTask.revisionId read-only Returns the id of the current revision of the data store, i.e. the current change that has been made to a data record. Example# In the following example, we use navigator.getDataStores to return a list of DataStore objects representing data stores on the device called contacts. Since there is only one such data store, we can access it inside the outer promise using stores[0]. The next promise uses DataStore.getLength to return the number of records in the store. If the value is 0, we populate the data store with records contained in the contactsInit object; if there is already data in the store, we run DataStore.sync to create a DataStoreCursor object allowing us to loop through any additions since the code last accessed the data store and update the data display as necessary. The cursor is passed to the runNextTask() function, which calls DataStoreCursor.next to start the process of managing the next task — the resulting DataStoreTask object is passed to the manageTask() function to work out what to do with it. runNextTask() is then called repeatedly by manageTask() until the cursor has finished working through all the records. navigator.getDataStores('contacts').then(function(stores) { stores[0].getLength().then(function(storeLength) { if(storeLength == 0) { for(i = 0; i < contactsInit.length; i++) { addContact(stores[0],contactsInit[i]); }; } else { var cursor = stores[0].sync(); runNextTask(cursor); } }); }); function runNextTask(cursor) { cursor.next().then(function(task) { manageTask(cursor, task); }); } function manageTask(cursor, task) { if (task.operation == 'done') { // Finished adding contacts! return; } if (task.operation == 'add') { // Add the contacts that are different to how it was before displayExisting(task.id, task.data); } runNextTask(cursor); } Copy Operation types# The different operation types used in DataStoreTask are (see also the spec definitions): add - The data record is added into the data store.update - The data record is updated in the data store.remove - The data record is deleted in the data store.clear - All the records are deleted from the data store; a clear operation (plus a list of add operations) is also received when the revision ID is too old for the DataStore to be able to provide all the steps to bring you to the current ID. The DataStore Service has a list of about 100 operations in memory.done - All changes are finished.","keywords":""},{"title":"DataStoreTask.revisionId","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastoretask/revisionid","content":"The revisionId read-only property of the DataStoreTask interface returns the id of the current revision of the data store, i.e. the current change that has been made to a data record. Syntax# myRevision = task.revisionId; Copy Value# A DOMString. Example# In the following example, we use navigator.getDataStores to return a list of DataStore objects representing data stores on the device called contacts. Since there is only one such data store, we can access it inside the outer promise using stores[0]. The next promise uses DataStore.getLength() to return the number of records in the store. If the value is 0, we populate the data store with records contained in the contactsInit object; if there is already data in the store, we run DataStore.sync() to create a DataStoreCursor object allowing us to loop through any additions since the code last accessed the data store and update the data display as necessary. The cursor is passed to the runNextTask() function, which calls DataStoreCursor.next() to start the process of managing the next task — the resulting DataStoreTask object is passed to the manageTask() function to work out what to do with it. runNextTask() is then called repeatedly by manageTask() until the cursor has finished working through all the records. task.revisionId is logged to the console inside the runNextTask() function with each iteration. navigator.getDataStores('contacts').then(function(stores) { stores[0].getLength().then(function(storeLength) { if(storeLength == 0) { for(i = 0; i < contactsInit.length; i++) { addContact(stores[0],contactsInit[i]); }; } else { var cursor = stores[0].sync(); runNextTask(cursor); } }); }); function runNextTask(cursor) { cursor.next().then(function(task) { console.log(task.revisionId); manageTask(cursor, task); }); } function manageTask(cursor, task) { if (task.operation == 'done') { // Finished adding contacts! return; } if (task.operation == 'add') { // Add the contacts that are different to how it was before displayExisting(task.id, task.data); } runNextTask(cursor); } Copy","keywords":""},{"title":"DeviceStorage.default","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/01.default","content":"Summary# The default property indicates if the storage area is the one which will be used by default for storing new files (true) or not (false). Syntax# var default = instanceOfDeviceStorage.default; Copy Value# A boolean.","keywords":""},{"title":"DataStoreTask.data","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastoretask/data","content":"The data read-only property of the DataStoreChangeEvent interface returns the data stored in the changed record in the data store. Must return null if the operation is clear or done. Syntax# myId = task.data; Copy Value# Any (whatever data type the object contained in the data record has.) Example# In the following example, we use navigator.getDataStores to return a list of DataStore objects representing data stores on the device called contacts. Since there is only one such data store, we can access it inside the outer promise using stores[0]. The next promise uses DataStore.getLength to return the number of records in the store. If the value is 0, we populate the data store with records contained in the contactsInit object; if there is already data in the store, we run DataStore.sync to create a DataStoreCursor object allowing us to loop through any additions since the code last accessed the data store and update the data display as necessary. The cursor is passed to the runNextTask() function, which calls DataStoreCursor.next to start the process of managing the next task — the resulting DataStoreTask object is passed to the manageTask() function to work out what to do with it. runNextTask() is then called repeatedly by manageTask() until the cursor has finished working through all the records. When an add operation is found, the displayExisting() function is passed the task.id and task.data to be used in displaying the record in the app UI. navigator.getDataStores('contacts').then(function(stores) { stores[0].getLength().then(function(storeLength) { if(storeLength == 0) { for(i = 0; i < contactsInit.length; i++) { addContact(stores[0],contactsInit[i]); }; } else { var cursor = stores[0].sync(); runNextTask(cursor); } }); }); function runNextTask(cursor) { cursor.next().then(function(task) { manageTask(cursor, task); }); } function manageTask(cursor, task) { if (task.operation == 'done') { // Finished adding contacts! return; } if (task.operation == 'add') { // Add the contacts that are different to how it was before displayExisting(task.id, task.data); } runNextTask(cursor); } Copy","keywords":""},{"title":"DeviceStorage","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage","content":"Summary# The DeviceStorage interface is used to access files on a specific storage area available on the device. A storage area is, in essence, a file system repository even if it hides the reality of the underlying file system. To access a storage area, you must use the navigator.getDeviceStorage() method, which returns DeviceStorage objects. You then use those objects' methods and properties to access the content of the storage area. Properties# DeviceStorage.canBeMounted Indicates if the storage area denoted by storageName is capable of being mounted and unmounted. DeviceStorage.canBeFormatted Indicates if the storage area denoted by storageName is capable of being formatted. DeviceStorage.default A Boolean value that indicates if this storage area is the default destination for storing new files (true) or not (false). Determines if this storage area is the one which will be used by default for storing new files. DeviceStorage.isRemovable Indicates if the storage area denoted by storageName is removable DeviceStorage.lowDiskSpace A Boolean value that returns true if this storage area is close to being full. DeviceStorage.storageName A string representing the name of the storage area. DeviceStorage.storagePath Return the mounted name of volume device Event handlers# DeviceStorage.onchange A handler for the change event. This event occurs each time the storage area is updated. Methods# DeviceStorage.add() Adds a file to the storage area. The name of the file is automatically generated. DeviceStorage.addNamed() Adds a file to the storage area. The name of the file is specified when calling the method. DeviceStorage.appendNamed() DeviceStorage.available() Reports \"available\" when the storage area is available for use and \"shared\" when the storage area is mounted on a computer using the device's USB connection. DeviceStorage.delete() Removes a file from the storage area. DeviceStorage.enumerate Iterates over the list of files available in the storage area. The files retrieved through this method are read only. DeviceStorage.enumerateEditable() Iterates over the list of files available in the storage area. DeviceStorage.format() DeviceStorage.freeSpace() Retrieves the total amount of free space available in the storage area. DeviceStorage.get() Retrieves a read only file from the storage area. DeviceStorage.getEditable() Retrieves an editable file from the storage area. DeviceStorage.usedSpace() Retrieves the total amount of space used by the storage area. DeviceStorage.getRoot() DeviceStorage.mount() DeviceStorage.storageStatus() DeviceStorage.unmount() Event handlers# Methods inherited from the EventTarget interface: DeviceStorage.addEventListener() Register an event handler of a specific event type on the EventTarget. DeviceStorage.removeEventListener() Removes an event listener from the EventTarget. DeviceStorage.dispatchEvent() Dispatch an event to this EventTarget. Additional methods for Mozilla chrome code# Mozilla extensions for use by JS-implemented event targets to implement on* properties. See also WebIDL bindings. void setEventHandler(DOMString type, EventHandler handler) EventHandler getEventHandler(DOMString type) ","keywords":""},{"title":"DeviceStorageChangeEvent","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/02.devicestoragechangeevent","content":"Summary# The DeviceStorageChangeEvent provides information about any change made to a file inside a given storage area. It extends the Event interface. The change event is triggered each time a file is created, modified, or deleted from the device storage system. Properties# DeviceStorageChangeEvent.path A string giving the full path of the file affected by the change. DeviceStorageChangeEvent.reason A string giving the reason of the change. Possible values are created, modified, or deleted. Example# var sdcard = navigator.getDeviceStorage('sdcard'); sdcard.addEventListener(\"change\", function (event) { var reason = event.reason; var path = event.path; console.log('The file \"' + path + '\" has been ' + reason); }); Copy","keywords":""},{"title":"DeviceStorage.onchange","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/04.onchange","content":"Summary# The onchange property is used to specify an event handler to receive change events. Those events are triggered each time a file is created, modified, or deleted on the storage area. Syntax# instanceOfDeviceStorage.onchange = funcRef Copy Where funcRef is a function to be called when the change event occurs. These events are of type DeviceStorageChangeEvent. Example# var sdcard = navigator.getDeviceStorage('sdcard'); sdcard.onchange = function (change) { var reason = change.reason; var path = change.path; console.log('The file \"' + path + '\" has been ' + reason); } Copy","keywords":""},{"title":"DeviceStorage.addNamed()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/06.addnamed","content":"Summary# The addNamed method is used to add a file inside a given storage area. This method allows to choose the name of the file. However, if a file with the same name already exists, this method will fail. It's not possible to override a file. To update or modify a file, you have to pick it first with the getEditable or enumerateEditable method. Note: Repository in a storage area is implicit; it's not possible to explicitly create an empty repository. If you want to use a repository structure you have to make it part of the name of the file to store. So if you want to store the file bar inside the foo repository, you have to provide the complete path name of the file: addNamed(blob, \"foo/bar\"). As files are added in a given restricted storage area, for security reasons, a file path name cannot start with \"/\" nor \"../\" (and \"./\" is pointless). Syntax# var instanceOfDOMRequest = instanceOfDeviceStorage.addNamed(file, name); Copy Parameters# file A Blob object representing the file to add (note that a File object is also a Blob object).name A string representing the full name (path + file name) of the file. Returns# It returns a DOMRequest object to handle the success or error of the operation. Example# var sdcard = navigator.getDeviceStorage(\"sdcard\"); var file = new Blob([\"This is a text file.\"], {type: \"text/plain\"}); var request = sdcard.addNamed(file, \"myFile.txt\"); request.onsuccess = function () { var name = this.result.name; console.log('File \"' + name + '\" successfully wrote on the sdcard storage area'); } request.onerror = function () { console.warn('Unable to write the file: ' + this.error); } Copy","keywords":""},{"title":"DeviceStorage.getEditable()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/13.geteditable","content":"Summary# The getEditable method is used to retrieve a file, which is editable, from a given storage area. If the request is successful, the request's result is a FileHandle object used to access and update the file on the device. Syntax# var instanceOfDOMRequest = instanceOfDeviceStorage.getEditable(fileName); Copy Parameters# fileName A string representing the full name (path + file name) of the file to retrieve. Returns# It returns a DOMRequest object to handle the success or error of the operation. Example# var sdcard = navigator.getDeviceStorage(\"sdcard\"); var request = sdcard.getEditable(\"myFile.txt\"); request.onsuccess = function () { var name = this.result.name; console.log('File \"' + name + '\" successfully retrieved from the sdcard storage area'); } request.onerror = function () { console.warn('Unable to get the file: ' + this.error); } Copy","keywords":""},{"title":"DeviceStorage.storagename","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/03.storagename","content":"Summary# The storageName property indicates the name of the storage area. Note: The storageName is just a name (like sdcard), and doesn't include any path information. Syntax# var name = instanceOfDeviceStorage.storageName; Copy Value# A string representing the name of the storage area.","keywords":""},{"title":"DeviceStorage.enumerateEditable()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/10.enumerateeditable","content":"Summary# The enumerateEditable method is used to iterate through the files of a given storage area. If the request is successful, the request's result is a FileHandle object allowing to access and modify the current file reached on the device. Syntax# var instanceOfDOMCursor = instanceOfDeviceStorage.enumerateEditable([path][, options]); Copy Parameters# pathOptional A string representing a path directory within the storage area where to search for files.optionsOptional An object with the property since which is a Date object. Files older than that date will be ignored during the iteration process. Returns# It returns a DOMCursor object to handle the success or error of the iteration. Example# var sdcard = navigator.getDeviceStorage('sdcard'); // Let's retrieve files from last week. var param = { since = new Date((+new Date()) - 7*24*60*60*1000) } var cursor = sdcard.enumerateEditable(param); cursor.onsuccess = function () { var file = this.result; console.log(\"File updated on: \" + file.lastModifiedDate); // Once we found a file we check if there are other results if (!this.done) { // Then we move to the next result, which calls the cursor // success with the next file as result. this.continue(); } } Copy","keywords":""},{"title":"DeviceStorage.enumerate()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/09.enumerate","content":"Summary# The enumerate method is used to iterate through the files of a given storage area. If the request is successful, the request's result is a File object containing the data of the current files stored on the device. Syntax# var instanceOfDOMCursor = instanceOfDeviceStorage.enumerate([path][, options]); Copy Parameters# path Optional A string representing a path directory within the storage area to search for files within. Note that you should not include a leading slash on the path you specify.options Optional An object with the property since which is a Date object. Files older than that date will be ignored during the iteration process. Returns# It returns a DOMCursor object to handle the success or error of the iteration. Example# var sdcard = navigator.getDeviceStorage('sdcard'); // Let's retrieve files from last week. var param = { since: new Date((+new Date()) - 7*24*60*60*1000) } var cursor = sdcard.enumerate(param); cursor.onsuccess = function () { if (this.result) { var file = this.result; console.log(\"File updated on: \" + file.lastModifiedDate); // Once we found a file we check if there are other results // Then we move to the next result, which calls the cursor // success possibly with the next file as result. this.continue(); } } Copy","keywords":""},{"title":"DeviceStorage.freeSpace()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/11.freespace","content":"Summary# The freeSpace method is used to get the amount of free space usable by the storage area. The request's result is a number representing the amount of free space expressed in Bytes. Syntax# var instanceOfDOMRequest = instanceOfDeviceStorage.freeSpace(); Copy Returns# It returns a DOMRequest object to handle the success or error of the operation. Example# var sdcard = navigator.getDeviceStorage(\"sdcard\"); var request = sdcard.freeSpace(); request.onsuccess = function () { // The result is expressed in bytes, let's turn it into Gigabytes var size = this.result / Math.pow(10,9); console.log(\"You have \" + size.toFixed(2) + \"GB of free space on your SDCard.\"); } request.onerror = function () { console.warn(\"Unable to get the free space available for the SDCard: \" + this.error); } Copy","keywords":""},{"title":"DeviceStorage.usedSpace()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/14.usedspace","content":"Summary# The usedSpace method is used to get the total of space used by the storage (the amount of space filled by files). The request's result is a number representing the amount of available space expressed in Bytes. Syntax# var instanceOfDOMRequest = instanceOfDeviceStorage.usedSpace(); Copy Returns# It returns a DOMRequest object to handle the success or error of the operation. Example# var sdcard = navigator.getDeviceStorage(\"sdcard\"); var request = sdcard.usedSpace(); request.onsuccess = function () { // The result is expressed in bytes, let's turn it into Gigabytes var size = this.result / Math.pow(10,9); console.log(\"The files on your SDCard take \" + size.toFixed(2) + \"GB of space.\"); } request.onerror = function () { console.warn(\"Unable to get the space used by the SDCard: \" + this.error); } Copy","keywords":""},{"title":"DeviceStorage.get()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/12.get","content":"Summary# The get method is used to retrieve a read-only file from a given storage area. If the request is successful, the request's result is a File object containing the data of the original file on the device. Syntax# var instanceOfDOMRequest = instanceOfDeviceStorage.get(fileName); Copy Parameters# fileNameA string representing the full name (path + file name) of the file to retrieve. Returns# It returns a DOMRequest object to handle the success or error of the operation. Example# var sdcard = navigator.getDeviceStorage(\"sdcard\"); var request = sdcard.get(\"myFile.txt\"); request.onsuccess = function () { var name = this.result.name; console.log('File \"' + name + '\" successfully retrieved from the sdcard storage area'); } request.onerror = function () { console.warn('Unable to get the file: ' + this.error); } Copy","keywords":""},{"title":"DeviceStorageChangeEvent.path","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/02.devicestoragechangeevent/01.path","content":"Summary# The path property provides the full path to the file affected by the change. Syntax# var path = instanceOfDeviceStorageChangeEvent.path; Copy Value# A string representing a file's path name.","keywords":""},{"title":"DeviceStorage.lowdiskspace","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/02.lowdiskspace","content":"Summary# The lowDiskSpace read-only property of the DeviceStorage interface returns a Boolean value that returns true if this storage area is close to being full. Syntax# var haveIGotSpace = instanceOfDeviceStorage.lowDiskSpace; Copy Value# A Boolean.","keywords":""},{"title":"Geolocation.getCurrentPosition()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/geolocation/02.getposition","content":"The Geolocation.getCurrentPosition() method is used to get the current position of the device. Syntax# navigator.geolocation.getCurrentPosition(success, error, [options]) Copy Parameters# successA callback function that takes a Position object as its sole input parameter.error OptionalAn optional callback function that takes a PositionError object as its sole input parameter.options OptionalAn optional PositionOptions object. Example# var options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }; function success(pos) { var crd = pos.coords; console.log('Your current position is:'); console.log(`Latitude : ${crd.latitude}`); console.log(`Longitude: ${crd.longitude}`); console.log(`More or less ${crd.accuracy} meters.`); } function error(err) { console.warn(`ERROR(${err.code}): ${err.message}`); } navigator.geolocation.getCurrentPosition(success, error, options); Copy","keywords":""},{"title":"DeviceStorageChangeEvent.reason","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/02.devicestoragechangeevent/02.reason","content":"Summary# The reason property gives the nature of the change that occurred. Syntax# var reason = instanceOfDeviceStorageChangeEvent.reason; Copy Value# A string representing the reason for the change. Possible values are: created, modified, or deleted.","keywords":""},{"title":"DeviceStorage.add()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/05.add","content":"Summary# The add method is used to add a file inside a given storage area. When a file is added with this method, its name is generated automatically and is available within the request's result which is a File object. Syntax# var instanceOfDOMRequest = instanceOfDeviceStorage.add(file); Copy Parameters# file A Blob object representing the file to add (note that a File object is also a Blob object). Returns# It returns a DOMRequest object to handle the success or error of the operation. Example# var sdcard = navigator.getDeviceStorage(\"sdcard\"); var file = new Blob([\"This is a text file.\"], {type: \"text/plain\"}); var request = sdcard.add(file); request.onsuccess = function () { var name = this.result.name; console.log('File \"' + name + '\" successfully wrote on the sdcard storage area'); } // An error typically occur if a file with the same name already exist request.onerror = function () { console.warn('Unable to write the file: ' + this.error); } Copy","keywords":""},{"title":"DeviceStorage.available()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/07.available","content":"Summary# The available() method is used to check whether the storage area is available; this is an asynchronous operation that returns a DOMRequest object that will receive a callback when the operation is complete. The request's result may be: 'available' Meaning that the storage area is available.'unavailable' Meaning that the storage area is not available. E.g. The SD card has need been inserted.'shared' Meaning the storage area is not available because the device is currently being used for USB storage. Syntax# var instanceOfDOMRequest = instanceOfDeviceStorage.available(); Copy Returns# Returns a DOMRequest object to report the success or error of the operation. Example# var sdcard = navigator.getDeviceStorage(\"sdcard\"); var request = sdcard.available(); request.onsuccess = function () { // The result is a string if (this.result == \"available\") { console.log(\"The SDCard on your device is available\"); } else if (this.result == \"unavailable\") { console.log(\"The SDcard on your device is not available\"); } else { console.log(\"The SDCard on your device is shared and thus not available\"); } } request.onerror = function () { console.warn(\"Unable to get the space used by the SDCard: \" + this.error); } Copy","keywords":""},{"title":"DeviceStorage.delete()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/01.devicestorage/08.delete","content":"Summary# The delete method is used to remove a file from a given storage area. Syntax# var instanceOfDOMRequest = instanceOfDeviceStorage.delete(fileName); Copy Parameters# fileName A string representing the full name (path + file name) of the file to remove. Returns# It returns a DOMRequest object to handle the success or error of the operation. Example# var sdcard = navigator.getDeviceStorage(\"sdcard\"); var request = sdcard.delete(\"myFile.txt\"); request.onsuccess = function () { console.log('File successfully removed.'); } request.onerror = function () { console.warn('Unable to remove the file: ' + this.error); } Copy","keywords":""},{"title":"Geolocation.watchPosition()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/geolocation/03.watchposition","content":"The Geolocation method watchPosition() method is used to register a handler function that will be called automatically each time the position of the device changes. You can also, optionally, specify an error handling callback function. This method returns a watch ID value that then can be used to unregister the handler by passing it to the Geolocation.clearWatch() method. Syntax# id = navigator.geolocation.watchPosition(success[, error[, options]]) Copy Parameters# successA callback function that takes a Position object as an input parameter.error OptionalAn optional callback function that takes a PositionError object as an input parameter.options OptionalAn optional PositionOptions object that provides configuration options for the location watch. Example# var id, target, options; function success(pos) { var crd = pos.coords; if (target.latitude === crd.latitude && target.longitude === crd.longitude) { console.log('Congratulations, you reached the target'); navigator.geolocation.clearWatch(id); } } function error(err) { console.warn('ERROR(' + err.code + '): ' + err.message); } target = { latitude : 0, longitude: 0 }; options = { enableHighAccuracy: false, timeout: 5000, maximumAge: 0 }; id = navigator.geolocation.watchPosition(success, error, options); Copy If your application is running on KaiOS, please take a look at geolocation wake lock to keep your application getting position updates while in the background or screen off.","keywords":""},{"title":"DataStoreTask.id","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastoretask/id","content":"The id read-only property of the DataStoreTask interface returns the identifier of the changed record in the data store. This must return null if the operation is cleared or done. Syntax# myId = task.id; Copy Value# A DataStoreKey. Example# In the following example, we use navigator.getDataStores to return a list of DataStore objects representing data stores on the device called contacts. Since there is only one such data store, we can access it inside the outer promise using stores[0]. The next promise uses DataStore.getLength() to return the number of records in the store. If the value is 0, we populate the data store with records contained in the contactsInit object; if there is already data in the store, we run DataStore.sync() to create a DataStoreCursor object allowing us to loop through any additions since the code last accessed the data store and update the data display as necessary. The cursor is passed to the runNextTask() function, which calls DataStoreCursor.next() to start the process of managing the next task — the resulting DataStoreTask object is passed to the manageTask() function to work out what to do with it. runNextTask() is then called repeatedly by manageTask() until the cursor has finished working through all the records. When an add operation is found, the displayExisting() function is passed the task.id and task.data to be used in displaying the record in the app UI. navigator.getDataStores('contacts').then(function(stores) { stores[0].getLength().then(function(storeLength) { if(storeLength == 0) { for(i = 0; i < contactsInit.length; i++) { addContact(stores[0],contactsInit[i]); }; } else { var cursor = stores[0].sync(); runNextTask(cursor); } }); }); function runNextTask(cursor) { cursor.next().then(function(task) { manageTask(cursor, task); }); } function manageTask(cursor, task) { if (task.operation == 'done') { // Finished adding contacts! return; } if (task.operation == 'add') { // Add the contacts that are different to how it was before displayExisting(task.id, task.data); } runNextTask(cursor); } Copy","keywords":""},{"title":"DataStoreTask.operation","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/dataStore/datastoretask/operation","content":"The operation read-only property of the DataStoreTask interface returns the type of operation that represents the current change that has been made to the data store. Syntax# myOperation = task.operation; Copy Value# A DataStoreOperation (see Operation types). Example# In the following example, we use navigator.getDataStores to return a list of DataStore objects representing data stores on the device called contacts. Since there is only one such data store, we can access it inside the outer promise using stores[0]. The next promise uses DataStore.getLength() to return the number of records in the store. If the value is 0, we populate the data store with records contained in the contactsInit object; if there is already data in the store, we run DataStore.sync() to create a DataStoreCursor object allowing us to loop through any additions since the code last accessed the data store and update the data display as necessary. The cursor is passed to the runNextTask() function, which calls DataStoreCursor.next() to start the process of managing the next task — the resulting DataStoreTask object is passed to the manageTask() function to work out what to do with it. runNextTask() is then called repeatedly by manageTask() until the cursor has finished working through all the records. In each case, task.operation is checked to see what type each task is, then appropriate action is taken. navigator.getDataStores('contacts').then(function(stores) { stores[0].getLength().then(function(storeLength) { if(storeLength == 0) { for(i = 0; i < contactsInit.length; i++) { addContact(stores[0],contactsInit[i]); }; } else { var cursor = stores[0].sync(); runNextTask(cursor); } }); }); function runNextTask(cursor) { cursor.next().then(function(task) { manageTask(cursor, task); }); } function manageTask(cursor, task) { if (task.operation == 'done') { // Finished adding contacts! return; } if (task.operation == 'add') { // Add the contacts that are different to how it was before displayExisting(task.id, task.data); } runNextTask(cursor); } Copy","keywords":""},{"title":"mozHasPendingMessage","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/mozhaspendingmessage/mozhaspendingmessage","content":"Summary# This method is used to know if there are pending messages of a given type true ot not false. When navigator.mozSetMessageHandler() is used to set a handler for the type, the pending messages will be asynchronously delivered to the application. Syntax# navigator.mozHasPendingMessage(type); Parameters# type - A string representing the kind of message the app wants to register a handler function for. For a full list of available types, see navigator.mozSetMessageHandler(). Return# A boolean.","keywords":""},{"title":"Geolocation.clearWatch()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/geolocation/01.clearwatch","content":"The Geolocation.clearWatch() method is used to unregister location/error monitoring handlers previously installed using Geolocation.watchPosition(). Syntax# navigator.geolocation.clearWatch(id); Copy Parameters# id The ID number returned by the Geolocation.watchPosition() method when installing the handler you wish to remove. Example# var id, target, option; function success(pos) { var crd = pos.coords; if (target.latitude === crd.latitude && target.longitude === crd.longitude) { console.log('Congratulation, you reach the target'); navigator.geolocation.clearWatch(id); } }; function error(err) { console.warn('ERROR(' + err.code + '): ' + err.message); }; target = { latitude : 0, longitude: 0, } options = { enableHighAccuracy: false, timeout: 5000, maximumAge: 0 }; id = navigator.geolocation.watchPosition(success, error, options); Copy","keywords":""},{"title":"MozNetworkStats","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstats","content":"Description# The MozNetworkStats object gives access to statistics about the data usage for a given network. MozNetworkStats objects are obtained through a call to the MozNetworkStatsManager.getNetworkStats() method. Properties# MozNetworkStats.connectionType read-only A string representing the connection type or null. MozNetworkStats.data read-only An array of MozNetworkStatsData objects. MozNetworkStats.start read-only A date representing the time of the first MozNetworkStatsData object. MozNetworkStats.end read-only A date representing the time of the last MozNetworkStatsData object. Methods# None.","keywords":""},{"title":"MozNetworkStats.data","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstats/02.data","content":"Description# The data property is a list of data usage statistics chunk. Each chunk is a MozNetworkStatsData that provides the total number of bytes received and sent during a given amount of time (this amount of time is accessible through the MozNetworkStatsManager.sampleRate property). Syntax# var data = instanceOfMozNetworkStats.data; Copy Value# An Array of MozNetworkStatsData objects.","keywords":""},{"title":"MozNetworkStats.end","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstats/04.end","content":"Description# The end property is a date equal to the one of the last MozNetworkStatsData objects available within the MozNetworkStats.data property. Syntax# var end = instanceOfMozNetworkStats.end; Copy Value# A Date object.","keywords":""},{"title":"MozNetworkStatsData","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsdata","content":"Description# The MozNetworkStatsData objects represent a chunk of data usage statistics. It provides the total amount of data received and sent during a given amount of time. The exact amount of time is provided by the MozNetworkStatsManager.sampleRate property. `` Properties# MozNetworkStatsData.rxBytes read-only A number representing the number of bytes received at \"date\" for \"sampleRate\" seconds.MozNetworkStatsData.txBytes read-only A number representing the number of bytes sent at \"date\" for \"sampleRate\" seconds.MozNetworkStatsData.date read-only A date representing the time when the number of bytes received and sent were stored. MozNetworkStatsData by Mozilla Contributors is licensed under CC-BY-SA 2.5.","keywords":""},{"title":"MozNetworkStatsManager.clearAllStats()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager/clearallstats","content":"Description# The clearAllStats method allows to clear all data usage chunks that were previously stored. A data usage chunk is a MozNetworkStatsData object representing the total number of bits received and sent during the amount of time defined by the sampleRate property. Syntax# var request = navigator.mozNetworkStats.clearAllStats(); Copy Return# A DOMRequest object to handle the success or error of the operation.","keywords":""},{"title":"Geolocation","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/geolocation/geolocation","content":"Description# The Geolocation interface represents an object able to programmatically obtain the position of the device. It gives Web content access to the location of the device. This allows a Web site or app to offer customized results based on the user's location. Notice that 'geolocation' permission is required for packaged app to use Geolocation API. (i.e. The developer must add the permisson to the manifest.webapp) An object with this interface is obtained using the navigator.geolocation property implemented by the Navigator object. Properties# The Geolocation interface neither implements, nor inherits any property. Methods# The Geolocation interface doesn't inherit any method. Geolocation.getCurrentPosition()Determines the device's current location and gives back a Position object with the data.Geolocation.watchPosition()Returns a long value representing the newly established callback function to be invoked whenever the device location changes.Geolocation.clearWatch()Removes the particular handler previously installed using watchPosition(). Example#","keywords":""},{"title":"MozNetworkStatsManager.getAvailableNetworks()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager/getavailablenetworks","content":"Description# The getAvailableNetworks method returns an Array of available networks that used to be saved in the database. A data usage chunk is a MozNetworkStatsData object representing the total number of bits received and sent during the amount of time defined by the sampleRate property. Syntax# var networks = getAvailableNetworks(); networks.onsuccess = function() { // do something with this.result } Copy Parameters# None. Return# A DOMRequest object. If successful, the result field of the DOMRequest holds an array of the currently available network interfaces.","keywords":""},{"title":"MozNetworkStats.start","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstats/03.start","content":"Description# The start property is a date equal to the one of the first MozNetworkStatsData objects available within the MozNetworkStats.data property. Syntax# var start = instanceOfMozNetworkStats.start; Copy Value# A Date object.","keywords":""},{"title":"MozNetworkStatsManager.getAllAlarms()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager/getallalarms","content":"Description# The getAllAlarms method obtains all alarms for those networks returned by MozNetworkStatsManager.getAvailableNetworks. If a network is provided, it only retrieves the alarms for that network. Syntax# var alarms = getAllAlarms(network); Copy Parameters# network read-only# The origin of the data. It can specify wifi, mobile, or null. If null, data measurement from both origins are merged. To know in advance which kind of origin is available, the MozNetworkStatsManager.getAvailableNetworks method returns an Array of interfaces. Return# An Alarm object with the same fields as that in the system message: alarmId, network, threshold, and data. Exceptions# InvalidNetwork The network must be in the return of MozNetworkStatsManager.getAvailableNetworks.","keywords":""},{"title":"MozNetworkStatsManager.getSamples()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager/getsamples","content":"Description# The getSamples method asynchronously queries network interface statistics. The query may be filtered by connection type and date. A data usage chunk is a MozNetworkStatsData object representing the total number of bits received and sent during the amount of time defined by the sampleRate property. Syntax# var samples = getSamples(network, start, end, options); samples.onsuccess = function() { // do something with samples.result } Copy Parameters# network# The origin of the data; it can be specified as wifi or mobile. If null, data measurement from both origins are merged. To know in advance which kind of origin is available, the MozNetworkStatsManager.getAvailableNetworks method returns an Array of interfaces. start# A Date object representing the beginning of data measurement. end# A Date object representing the end of data measurement. options# Filtering options. NetworkStatsGetOptions is a dictionary object providing filtering options. Return# A DOMRequest object. If successful, the request result is a MozNetworkStats object describing the network statistics. If network stats are not available for some dates, then rxBytes and txBytes are undefined for those dates. If the filtering start date is greater than the end date, an exception is thrown. Exceptions# NS_ERROR_INVALID_ARG# The filtering start date is greater than the end date. NS_ERROR_NOT_IMPLMENTED# Both appManifestURL and serviceType are specified at the same time in the NetworkStatsGetOptions dictionary. InvalidNetwork# The network must be in the return of MozNetworkStatsManager.getAvailableNetworks.","keywords":""},{"title":"LargeText","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/largetext/largetext","content":"Description# Represents the current selection of text size, application developers might need to relayout its UI base on different size of text. Properties# Navigator.largeTextEnabled The read-only property returns a boolean representing the preferred text size of users, true if users select text size large, false if users select text size normal. Methods# EventHandler:# largetextenabledchanged The event target is window, dispatched when users has changed the value of Device/Accessibility/Large Text from Settings App. Example# window.addEventListener('largetextenabledchanged', () => { if (navigator.largeTextEnabled) { console.log('Text size is now set to large, update UI if necessary.'); } } Copy","keywords":""},{"title":"MozNetworkStatsManager","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager","content":"Description# The MozNetworkStatsManager interface provides methods and properties to monitor data usage. Properties# MozNetworkStatsManager.maxStorageAge read-only A number representing the time in milliseconds recorded by the API until present time for each type of connection. All samples older than maxStorageAge from now are deleted. MozNetworkStatsManager.sampleRate read-only A number representing the minimum time in milliseconds between samples stored in the database. Methods# MozNetworkStatsManager.addAlarm() Allows to install an alarm on a network. Returns a DOMRequest object to handle the success or failure of the request. MozNetworkStatsManager.clearAllStats() Allows to clear all the statistics about the data usage. Returns a DOMRequest object to handle the success or failure of the request. MozNetworkStatsManager.clearStats() Allows to clear all the statistics about the data usage on a specific network. Returns a DOMRequest object to handle the success or failure of the request. MozNetworkStatsManager.getAllAlarms() Allows to obtain all alarms for those networks returned by MozNetworkStatsManager.getAvailableNetworks. Returns a DOMRequest object to handle the success or failure of the request. MozNetworkStatsManager.getAvailableNetworks() Allows to obtain an Array of available networks that used to be saved in the database. Returns a DOMRequest object to handle the success or failure of the request. MozNetworkStatsManager.getAvailableServiceTypes() Allows to obtain an Array of available service types that used to be saved in the database. Returns a DOMRequest object to handle the success or failure of the request. MozNetworkStatsManager.getSamples() Allows to access the data usage statistics. Returns a DOMRequest object to handle the success or failure of the request. MozNetworkStatsManager.removeAlarms() Allows to remove all network alarms, or a specific network alarm, if an alarmId is provided. Returns a DOMRequest object to handle the success or failure of the request. Constants# MozNetworkStatsManager.WIFI - Returns 0, identifying Wifi MozNetworkStatsManager.MOBILE - Returns 1, identifying Mobile","keywords":""},{"title":"mozSetMessageHandler","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/mozsetmessagehandler/mozsetmessagehandler","content":"Description# This method is used to allow applications to register a function handler that can receive — and react to — a message from the system. Any application is allowed to register a handler to receive any message, but some messages will only be delivered to applications that have the corresponding permission. For example, an sms-received message will only be delivered to an application that has the sms permission. Contrary to DOM events, system messages will stay in the queue even if the application has no handler for them. You can check if your application has queued messages by calling navigator.mozHasPendingMessage() with the appropriate type as a parameter. When a message handler is set, all queued messages will be asynchronously delivered to the application. Syntax# navigator.mozSetMessageHandler(type, handler); Copy Parameters# type - type is a string that represents the registered handler for which a class of messages.handler - when the system sends a message, the handler is called, its reception parameters determined by the message type. Message types# Currently KaiOS allows you to register handlers for the following messages: Message type\tHandler signature\tPermissionactivity\tf(MozActivityRequestHandler request) alarm\tf(object unknown)\talarms bluetooth-cancel\tf(object unknown)\tbluetooth bluetooth-dialer-command\tf(object unknown)\tbluetooth bluetooth-hfp-status-changed\tf(object unknown)\tbluetooth bluetooth-opp-transfer-start\tf(object unknown)\tbluetooth bluetooth-opp-transfer-complete\tf(object unknown)\tbluetooth bluetooth-opp-receiving-file-confirmation\tf(object unknown)\tbluetooth bluetooth-opp-update-progress\tf(object unknown)\tbluetooth bluetooth-pairedstatuschanged\tf(object unknown)\tbluetooth bluetooth-pairing-request\tf(object unknown)\tbluetooth bluetooth-requestconfirmation\tf(object unknown)\tbluetooth bluetooth-requestpincode\tf(object unknown)\tbluetooth bluetooth-requestpasskey\tf(object unknown)\tbluetooth cdma-info-rec-received\t? connection\t?\tmobileconnection first-run-with-sim\t? headset-button\tf(object unknown) icc-stkcommand\tf(object command)\tsettings networkstats-alarm\tf(object command)\tnetworkstats-manage nfc-hci-event-transaction\t?\tnfc nfc-manager-send-file\t?\tnfc nfc-manager-tech-discovered\t?\tnfc nfc-manager-tech-lost\t?\tnfc notification\tf(object unknown) push\tf(object registration)\tpush push-register\tf( )\tpush sms-received\tf(SmsMessage sms)\tsms sms-sent\tf(SmsMessage sms)\tsms telephony-call-ended\tf(object call)\ttelephony telephony-new-call\tf( )\ttelephony ussd-received\tf(object ussd)\tmobileconnection wappush-received\tf(object wappush)\twappush wifip2p-pairing-request\tf(object unknown)\twifi-manage","keywords":""},{"title":"MozNetworkStatsManager.addAlarm()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager/addalarm","content":"Description# The addAlarm method installs an alarm on a network. When total data usage reaches threshold bytes, a \"networkstats-alarm\" system message is sent to the application, where the optional parameter data must be a cloneable object. Syntax# var alarm = addAlarm(network, threshold, options); Copy Parameters# network# The origin of the data. It can specify wifi, mobile, or null. If null, data measurement from both origins are merged. To know in advance which kind of origin is available, the MozNetworkStatsManager.getAvailableNetworks method returns an Array of interfaces. threshold# The total data usage threshold in bytes. options# Filtering options. NetworkStatsAlarmOptions is a dictionary object providing filtering options. Return# A DOMRequest object. If successful, the result field of the DOMRequest keeps the alarm Id. Exceptions# InvalidNetwork The network must be in the return of MozNetworkStatsManager.getAvailableNetworks.","keywords":""},{"title":"MozNetworkStats.connectionType","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstats/01.connectiontype","content":"Description# The connectionType property indicates for which network the data usage statistics are provided. The value for this property is the same as the one provided within the option parameter of the MozNetworkStatsManager.getNetworkStats() method. If this property is null, it means that the data usage statistics are a merge of the data from all networks. Syntax# var type = instanceOfMozNetworkStats.connectionType; Copy Value# A string or null.","keywords":""},{"title":"MozNetworkStatsManager.clearStats()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager/clearstats","content":"Description# The clearStats method removes all stats related to the provided network from DB. Syntax# var stats = clearStats(network); Copy Parameters# network# The origin of the data. It can specify wifi, mobile, or null. If null, data measurement from both origins are merged. To know in advance which kind of origin is available, the MozNetworkStatsManager.getAvailableNetworks method returns an Array of interfaces. Return# A DOMRequest object.","keywords":""},{"title":"MozNetworkStatsManager.removeAlarms()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager/removealarms","content":"Description# The removeAlarms method removes all network alarms. If an alarmId is provided, then only that alarm is removed. Syntax# var alarm = removeAlarms(alarmId); Copy Parameters# alarmID no-link read-only# ID of an alarm, like the one returned by MozNetworkStatsManager.addAlarm. Return# A DOMRequest object.","keywords":""},{"title":"MozNetworkStatsManager.sampleRate","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager/samplerate","content":"Description# The sampleRate property indicates the time in seconds between when two data usage chunks are stored. A data usage chunk is a MozNetworkStatsData object representing the total number of bytes received and sent during the amount of time defined by the sampleRate property. Syntax# var time = navigator.mozNetworkStats.sampleRate; Copy Value# A number.","keywords":""},{"title":"MozNetworkStatsManager.maxStorageAge","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager/maxstorageage","content":"Description# Time in milliseconds recorded by the API until present time for each type of connection. All samples older than maxStorageAge from now are deleted. A data usage chunk is a MozNetworkStatsData object representing the total number of bytes received and sent during a given amount of time (this amount of time is accessible through the sampleRate property). Syntax# var max = navigator.mozNetworkStats.maxStorageAge; Copy Value# A number given as a long type.","keywords":""},{"title":"Network Stats","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/network-stats","content":"Description# The Network Stats API allows you to monitor data usage and expose this information to certified applications. Data can be accessed through navigator.mozNetworkStats which returns an instance of the MozNetworkStatsManager interface. Interface# MozNetworkStatsGives access to statistics about the data usage for a given network.MozNetworkStatsDataRepresent a chunk of data usage statistics.MozNetworkStatsManagerProvides methods and properties to monitor data usage. Properties# Navigator.mozNetworkStatsProvides methods and properties to monitor data usage. Accessing data# Information about the volume of data received and sent is automatically stored by the system. Accessing this information is possible by using the MozNetworkStatsManager.getSamples() method. This method expects three parameters, and a fourth parameter is optional: network - The origin of the data, which can represent wifi or mobile. If null, data measurement from both origins are merged. To know in advance which kind of origin is available, the MozNetworkStatsManager.getAvailableNetworks() method returns an Array of MozNetworkStats objects representing each supported interface. start - A Date object representing the beginning of data measurement. end - A Date object representing the end of data measurement. options (Optional) - A NetworkStatsGetOptions dictionary. It consists of three keys, two of which are DOMString objects — appManifestURL and serviceType — and the one which is a boolean — browsingTrafficOnly. appManifestURL - is used to filter network stats by app. serviceType - is used to filter stats by system service. Note that serviceType and appManifestURL cannot currently be specified at the same time for now. This results in an NS_ERROR_NOT_IMPLMENTED exception being thrown. browsingTrafficOnly - controls what kind of traffic is returned in the network stats. If it is set to true, only the browsing traffic generated from the mozbrowser <iframe> element within an app is returned in result. If it is set as false (the default), the total traffic — which is generated from both the mozapp and mozbrowser <iframe> elements — is returned. When called, getSamples() returns a DOMRequest to handle the success or failure of the information request. In case of success the request's result is a MozNetworkStats object. var networks = navigator.mozNetworkStats.getAvailableNetworks(); networks.onsuccess = function() { var network = this.result[0]; // 0 for Wifi; returns a mozNetworkInterface object var end = new Date(); var start = new Date(); var samples = navigator.mozNetworkStats.getSamples(network, start, end); // returns a mozNetworkStats object samples.onsuccess = function () { console.log(\"Data received: \" + samples.result.data[0].rxBytes + \" Bytes\"); console.log(\"Data sent: \" + samples.result.data[0].txBytes + \" Bytes\"); }; samples.onerror = function () { console.log(\"Something went wrong: \", samples.error); }; }; networks.onerror = function () { console.log(\"Something went wrong: \", networks.error); }; Copy Sampling over time# To visualise data usage over time, the information about the amount of data is stored in chunks. Each chunk is a value representing the amount of data exchanged since the last chunk was stored. When requesting the stats, the resulting MozNetworkStats object contains as many data chunks as possible for the interval defined between the start and end date. The total number of chunks depends on two parameters (note that those parameters are read-only): MozNetworkStatsManager.sampleRate - which represents the minimum time in milliseconds between samples stored in the database.MozNetworkStatsManager.maxStorageAge - which represents the time in milliseconds recorded by the API until present time. All samples older than maxStorageAge from now are deleted. Each data chunk is a MozNetworkStatsData object, and all the data chunks for a given time frame are available through the MozNetworkStats.data property, which is an Array of MozNetworkStatsData objects. var networks = navigator.mozNetworkStats.getAvailableNetworks(); networks.onsuccess = function() { var network = this.result[0]; // 0 for Wifi; returns a mozNetworkInterface object var end = new Date(); var oneHour = 3600000; //in milliseconds var start = new Date(end.getTime() - oneHour); var samples = navigator.mozNetworkStats.getSamples(network, start, end); // returns a mozNetworkStats object samples.onsuccess = function () { var total = { receive: 0, send : 0 }; samples.result.data.forEach(function (chunk) { // array of MozNetworkStatsData objects total.receive += chunk.rxBytes; total.send += chunk.txBytes; }); console.log(\"Since: \" + start.toString()); console.log(\"Data received: \" + total.receive + \" Bytes\"); console.log(\"Data sent: \" + total.send + \" Bytes\") }; samples.onerror = function () { console.log(\"Something went wrong: \", samples.error); }; }; networks.onerror = function () { console.log(\"Something went wrong: \", networks.error); Copy","keywords":""},{"title":"MozNetworkStatsData.date","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsdata/date","content":"Description# The date property provides the date when the data usage statistics chunk was stored. Syntax# var date = instanceOfMozNetworkData.date; Copy Value# A Date object.","keywords":""},{"title":"SEChannel","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/seChannel/sechannel","content":"Description# A SEChannel interface represents an [ISO7816-4] channel opened to a Secure Element. It can be either a supplementary logical channel or the basic logical channel. It can be used to send commands to and receive responses from an applet in secure element. Properties# SEChannel.session'Session' object this channel is bound to SEChannel.openResponseResponse to openBasicChannel / openLogicalChanneloperation SEChannel.isClosedStatus of channel SEChannel.typeType of channel Methods# SEChannel.transmit() Available since v2.5Transmits the APDU command to the secure element. SEChannel.close() Available since v2.5Closes the active channel. Example# window.AID = { CRS: \"A00000015143525300\", PPSE: \"325041592E5359532E4444463031\", ISD:\"A000000151000000\" }; window.APDU = { ISD: { getCplc: { cla: 0x80, ins: 0xCA, p1: 0x9F, p2: 0x7F, le: 0x00}, }, }; function hexString2byte(str) { var a = []; for(var i = 0, len = str.length; i < len; i+=2) { a.push(parseInt(str.substr(i, 2), 16)); } return new Uint8Array(a); } function byte2hexString(uint8arr) { if (!uint8arr) { return ''; } var hexStr = ''; for (var i = 0; i < uint8arr.length; i++) { var hex = (uint8arr[i] & 0xff).toString(16); hex = (hex.length === 1) ? '0' + hex : hex; hexStr += hex; } return hexStr.toUpperCase(); } function checkResponse(response, expectedSw1, expectedSw2, expectedData) { var sw1Check = response.sw1 === expectedSw1; var sw2Check = response.sw2 === expectedSw2; var dataCheck = (expectedData) ? byte2hexString(response.data) === expectedData : true; if (sw1Check && sw2Check && dataCheck) { return true; } else { return false; } } window.navigator.seManager.getSEReaders() .then((readers) => { window.reader = readers[0]; return readers[0].openSession(); }) .then((session) => { console.log(\"Open a session successfully\"); window.testSession = session; return session.getAtr(); }) .then((result) => { console.log(\"Get answer to reset successfully\"); return window.testSession.openBasicChannel(hexString2byte(window.AID.ISD)); }) .then((channel) => { console.log(\"Open a basic channel successfully\"); window.testChannel = channel; return channel.transmit(window.APDU.ISD.getCplc); }) .then((response) => { if (checkResponse(response, 0x90, 0x00) == true) { console.log(\"Transmit get cplc command successfully\"); } else { console.log(\"Failed to get cplc response\"); } return window.reader.closeAll(); }) .then(() => { console.log(\"Close all channels successfully\"); }) .catch((err) => { console.log(\"Failed\"); window.reader.closeAll(); }); Copy","keywords":""},{"title":"MediaSource","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/mediasource/mediasource","content":"Description# The MediaSource interface of the Media Source Extensions API represents a source of media data for an HTMLMediaElement object. A MediaSource object can be attached to a HTMLMediaElement to be played in the user agent. Properties# MediaSource.sourceBuffers Returns a SourceBufferList object containing the list of SourceBuffer objects associated with this MediaSource. MediaSource.activeSourceBuffers Returns a SourceBufferList object containing a subset of the SourceBuffer objects contained within MediaSource.sourceBuffers — the list of objects providing the selected video track, enabled audio tracks, and shown/hidden text tracks. MediaSource.readyState Returns an enum representing the state of the current MediaSource, whether it is not currently attached to a media element (closed), attached and ready to receive SourceBuffer objects (open), or attached but the stream has been ended via MediaSource.endOfStream() (ended.) MediaSource.duration Gets and sets the duration of the current media being presented. EventHandler# MediaSource.onsourceclose The event handler for the sourceclose event. MediaSource.onsourceended The event handler for the sourceended event. MediaSource.onsourceopen The event handler for the sourceopen event. Methods# Inherits methods from its parent interface, EventTarget. MediaSource.addSourceBuffer() Creates a new SourceBuffer of the given MIME type and adds it to the MediaSource.sourceBuffers list. MediaSource.removeSourceBuffer() Removes the given SourceBuffer from the MediaSource.sourceBuffers list. MediaSource.endOfStream() Signals the end of the stream. MediaSource.setLiveSeekableRange() Sets the range that the user can seek to in the media element. MediaSource.clearLiveSeekableRange() Clears the live seekable range. Static methods# MediaSource.isTypeSupported() Returns a Boolean value indicating if the given MIME type is supported by the current user agent — this is, if it can successfully create SourceBuffer objects for that MIME type. Examples# The following simple example loads a video with XMLHttpRequest, playing it as soon as it can. This example was written by Nick Desaulniers and can be viewed live here (you can also download the source for further investigation.) var video = document.querySelector('video'); var assetURL = 'frag_bunny.mp4'; // Need to be specific for Blink regarding codecs // ./mp4info frag_bunny.mp4 | grep Codec var mimeCodec = 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"'; if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) { var mediaSource = new MediaSource(); //console.log(mediaSource.readyState); // closed video.src = URL.createObjectURL(mediaSource); mediaSource.addEventListener('sourceopen', sourceOpen); } else { console.error('Unsupported MIME type or codec: ', mimeCodec); } function sourceOpen (_) { //console.log(this.readyState); // open var mediaSource = this; var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec); fetchAB(assetURL, function (buf) { sourceBuffer.addEventListener('updateend', function (_) { mediaSource.endOfStream(); video.play(); //console.log(mediaSource.readyState); // ended }); sourceBuffer.appendBuffer(buf); }); }; function fetchAB (url, cb) { console.log(url); var xhr = new XMLHttpRequest; xhr.open('get', url); xhr.responseType = 'arraybuffer'; xhr.onload = function () { cb(xhr.response); }; xhr.send(); }; Copy","keywords":""},{"title":"MozNetworkStatsData.rxBytes","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsdata/rxbytes","content":"Description# The rxBytes property is a number representing the number of bytes received for a given connection. The value is the total number of bytes received for MozNetworkStatsManager.sampleRate seconds at MozNetworkStatsData.date. If no network stats are available for the given date, this property is undefined (which is different than 0). Syntax# var bytes = instanceOfMozNetworkData.rxBytes; Copy Value# A number or undefined.","keywords":""},{"title":"MozNetworkStatsData.txBytes","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsdata/txbytes","content":"Description# The txBytes property is a number representing the number of bytes sent for a given connection. The value is the total number of bytes sent for MozNetworkStatsManager.sampleRate seconds at MozNetworkStatsData.date. If no network stats are available for the given date, this property is undefined (which is different than 0). Syntax# var bytes = instanceOfMozNetworkData.txBytes; Copy Value# A number or undefined.","keywords":""},{"title":"SEManager","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/seManager/semanager","content":"Description# The SEManager interface provides access to Secure Element readers. Properties# N/A Methods# SEReader.getSEReaders( )Retrieves all the readers available on the device. Example# window.navigator.seManager.getSEReaders() .then((readers) => { var result = readers[0].isSEPresent; if (result == false) { console.log(\"Reader is not available !!!\"); } else { console.log(\"Reader is presented !!!\"); } }) .catch((err) => { console.log(\"Reader is not available !!!\"); }); Copy","keywords":""},{"title":"SEReader","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/seReader/sereader","content":"Description# SEReader interface provides ways to connect to secure element this device. Properties# isSEPresentIf a secure element is presenttypeType of SecureElement Methods# SEReader.openSession()Opens a session with the Secure Element. SEReader.closeAll()Closes all sessions associated with this Reader and its associated channels. SEReader.reset()This method resets the physical interface of the Secure Element. The enabling process of the physical interface MUST be replayed. If the physical interface does not support or allow the operation, this method MUST fail with SEUnsupportedException. error. Example# window.navigator.seManager.getSEReaders() .then((readers) => { window.reader = readers[0]; return readers[0].openSession(); }) .then((session)=> { if (session) { console.log(\"Open a seesion successfully\") } else { console.log(\"Failed to open a session\") } window.reader.closeAll(); }) .catch((err) => { console.log(\"Failed to open a session\") window.reader.closeAll(); }); Copy","keywords":""},{"title":"SEResponse","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/seresponse/seresponse","content":"Description# The SEResponse interface represents an APDU response received from a Secure Element. Properties# SEResponse.channelResponse received on this 'channel' object. SEResponse.sw1First octet of response's status word SEResponse.sw2Second octet of response's status word SEResponse.dataThe response's data field bytes Methods# N/A","keywords":""},{"title":"MozNetworkStatsManager.getAvailableServiceTypes()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/networkStats/moznetworkstatsmanager/getavailableservicetypes","content":"Description# The getAvailableServiceTypes method returns an Array of available service types that used to be saved in the database. Syntax# var service_types = getAvailableServiceTypes(); Copy Parameters# None. Return# A DOMRequest object. If successful, the result field of the DOMRequest holds an array of the currently available service types.","keywords":""},{"title":"SpeedDial","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/speeddial/speeddial","content":"Description# Properties# SpeedDialChangeEvent.speedDial The dialing number fo the speed dial which is changed SpeedDialChangeEvent.reason Reason is one from following: 'set', 'remove'. Methods# Example#","keywords":""},{"title":"VolumeManager","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/volumemanager/volumemanager","content":"Description# The VolumeManager interface provides ways to change/show the audio volumes of the system. Properties# Methods:# VolumeManager.requestUp() Send an event to system application for increasing current audio volume. VolumeManager.requestDown() Send an event to system application for decreasing current audio volume. VolumeManager.requestShow() Send an event to system application for showing current audio volume. Example# var volume = navigator.volumeManager; // request system application to increase audio volume volume.requestUp(); // request system application to decrease audio volume volume.requestDown(); // request system application to show the volume status volume.requestShow(); Copy","keywords":""},{"title":"Device Storage","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/deviceStorage/device-storage","content":"Description# The Device Storage API is used to access the file system within a Web app. Accessing the file system can be highly sensitive, and for that reason this API is available for privileged apps only. Note: Accessing device storage is slow due to a limitation at the physical level. In many cases it can be faster to use an IndexedDB database to store files instead of physical device storage. Accessing device storage# This section explains what is needed to access device storage. Entry point# It's possible to access storage areas by using the navigator.getDeviceStorage() and navigator.getDeviceStorages() methods: navigator.getDeviceStorage() accepts a string parameter representing the name of the default storage area to be accessed. The method returns a DeviceStorage object, which is used to access the related storage area. It returns the storage area whose .default attribute is true. This is controlled by the user via Settings App > Media Storage > Default media location. navigator.getDeviceStorages() on the other hand accepts a string representing the name of the storage area to be accessed, and returns an Array of DeviceStorage objects, one per physical storage area. KaiOS provides the following storage names: apps This storage area is used to store the user data needed by apps. As it is critical data, accessing this storage area requires some extra privileges (see below) and is available to certified applications only. music This is the storage area where music and sounds are stored. pictures This is the storage area where pictures are stored. sdcard This is the storage area that grants access to the device's SDCard. sdcard is also used as the name of the device's default internal storage, which is a bit unfortunate and potentially confusing; be aware. videos This is the storage area where videos are stored. var pics = navigator.getDeviceStorage('pictures'); Copy Accessing different storage areas with navigator.getDeviceStorages()# When using navigator.getDeviceStorages(), if there is more than one storage area then the internal one will be named for example sdcard and the physical storage area will be called something else (sometimes it's extsdcard, sometimes it's sdcard1). This varies by device manufacturer. The names of files on the sdcard storage area will be /sdcard/path/filename, and the names of files on the sdcard1 storage area will be /sdcard1/path/filename, or whatever. Note that the /sdcard and /sdcard1 are storage names. Their actual mount points on the system are determined via vold and/or /system/etc/volume.cfg file.) DeviceStorage transparently maps the storageName into the actual mountPoint (so you don't need the mount point if you're just accessing the files through device storage). If you want to determine the mount point to examine the filesystem from an adb shell, then you can determine the vold mount points by using the command adb shell vdc volume list (this requires a root shell). On the Flame, you'll see something like this: 110 0 sdcard /storage/sdcard 4 110 0 sdcard1 /storage/sdcard1 4 200 0 Volumes listed. Copy For volumes that aren't managed by vold the mount point is found in /system/etc/volume.cfg. Note: In Gaia engineering builds there is a ds-test app, which is useful for device storage testing. Device storage permissions# To be able to use these storage areas, the application must declare them in its application manifest. For example, if the application wants to access the sdcard storage area, it must have the \"device-storage:sdcard\" permission in its manifest. \"permissions\": { \"device-storage:videos\":{ \"access\": \"readonly\" }, \"device-storage:pictures\":{ \"access\": \"readwrite\" } } Copy As mentioned above, using device-storage:apps also needs some extra permissions, in the form of the webapps-manage permission, which allows access to the navigator.mozApps.mgmt API for managing installed open web apps. \"permissions\": { \"device-storage:apps\":{ \"access\": \"readwrite\" }, \"webapps-manage\":{ } } Copy All of the device-storage name permissions are privileged level, except for apps, which is certified. webapps-manage is certified level. Using a storage# Once an application gets access to a storage area, it's possible to add, get and remove files inside the area. Add a file# Adding a file is done using the addNamed or add methods. The former allows to set an explicit name when storing a file while the latter creates a name automatically when the file is stored. Both methods are asynchronous and return a DOMRequest object to handle the success or error of the operation. This is very important as writing and reading files on a physical support is a slow process. Those two methods expect a Blob as their first parameter. This object will be turned into a file under the hood and stored. When creating a Blob object, it's mandatory to give it a type. This type, which is a MIME type, is important because some storage areas have restrictions based on the type: music only accepts Blob with a valid audio MIME typepictures only accepts Blob with a valid image MIME typevideos only accepts Blob with a valid video MIME type var sdcard = navigator.getDeviceStorage(\"sdcard\"); var file = new Blob([\"This is a text file.\"], {type: \"text/plain\"}); var request = sdcard.addNamed(file, \"my-file.txt\"); request.onsuccess = function () { var name = this.result; console.log('File \"' + name + '\" successfully wrote on the sdcard storage area'); } // An error typically occur if a file with the same name already exist request.onerror = function () { console.warn('Unable to write the file: ' + this.error); } Copy Note: Repositories in a storage area are implicit. It's not possible to create explicitly an empty repository. If you want to use a repository structure you have to make it part of the name of the file to store. So if you want to store the file bar inside the foo repository, you have to use the addNamed method with the complete path name of the file addNamed(blob, \"foo/bar\"). This is also true when you want to retrieve a file using its name (see below). As files are added in a given restricted storage area for security reasons, a file path name cannot start with \"/\" nor \"../\" (and \"./\" is pointless). Get a file# Retrieving a file can be done in two ways: by using its name or by iterating the whole list of files. The easiest way is to retrieve a file by its name using the get and getEditable methods. The former provides a File object (which act like a read only file) when the latter provides a FileHandle object (which allows updating the underlaying file). Both methods are asynchronous and return a DOMRequest object to handle the success or error of the operation. var sdcard = navigator.getDeviceStorage('sdcard'); var request = sdcard.get(\"my-file.txt\"); request.onsuccess = function () { var file = this.result; console.log(\"Get the file: \" + file.name); } request.onerror = function () { console.warn(\"Unable to get the file: \" + this.error); } Copy The other way to retrieve files is by browsing the content of the storage area. This is possible using the enumerate and enumerateEditable methods. The former provides File objects when the latter provides FileHandle objects. Both methods are asynchronous and return a DOMCursor object to iterate along the list of files. A DOMCursor is nothing less than a DOMRequest with extra power to iterate asynchronously along a list of things (files in that case). var pics = navigator.getDeviceStorage('pictures'); // Let's browse all the images available var cursor = pics.enumerate(); cursor.onsuccess = function () { if(cursor.result.name !== null) { var file = cursor.result; console.log(\"File found: \" + file.name); // Once we found a file we check if there is other results // Then we move to the next result, which call the cursor // success with the next file as result. this.continue(); } } cursor.onerror = function () { console.warn(\"No file found: \" + this.error); } Copy It's possible to limit the number of results by passing two optional parameters to the enumerate and enumerateEditable methods. The first parameter can be a string representing a sub folder to search inside.The second parameter can be an object with a since property, which allows you to limit the search to a given time period. var pics = navigator.getDeviceStorage('pictures'); // Lets retrieve picture from the last week. var param = { since: new Date((+new Date()) - 7*24*60*60*1000) } var cursor = pics.enumerate(param); cursor.onsuccess = function () { var file = this.result; console.log(\"Picture taken on: \" + file.lastModifiedDate); if (!this.done) { this.continue(); } } Copy Delete a file# A file can be removed from the storage area by simply using the delete method. This method just needs the name of the file to delete. As all the other methods from the DeviceStorage interface, this one is also asynchronous and returns a DOMRequest object to handle the success or error of the operation. var sdcard = navigator.getDeviceStorage('sdcard'); var request = sdcard.delete(\"my-file.txt\"); request.onsuccess = function () { console.log(\"File deleted\"); } request.onerror = function () { console.log(\"Unable to delete the file: \" + this.error); } Copy Storage information# Beyond accessing files, a storage area provides a few methods to easily reach some important information Available space# One of the most important things to know when storing files on a device is the amount of space available. The DeviceStorage interface provides two useful functions dedicated to space: freeSpace() to get the amount of free space available to store new files;usedSpace() to get the amount of space used to store the files; As those methods are asynchronous, they return a DOMRequest object to handle the success or error of the operation. var videos = navigator.getDeviceStorage('videos'); var request = videos.usedSpace(); request.onsuccess = function () { // The result is express in bytes, lets turn it into megabytes var size = this.result / 1048576; console.log(\"The videos on your device use a total of \" + size.toFixed(2) + \"Mo of space.\"); } request.onerror = function () { console.warn(\"Unable to get the space used by videos: \" + this.error); } Copy Listening for change# As many applications can use a same storage area at the same time, it's sometimes useful for an application to be aware of a change in that storage area. It's also useful for an application performing an asynchronous action because it doesn't have to relay on all the DOMRequest objects returned by each method of the DeviceStorage interface. To that end, a change event is triggered each time a file is created, modified or deleted. This event can be captured using the onchange property or the addEventListener() method. The event handler gets a DeviceStorageChangeEvent object which is a regular Event object with two extra properties: DeviceStorageChangeEvent.reason which gives the reason of the change (created, modified or deleted). DeviceStorageChangeEvent.path which gives the full path to the file affected by the change. var sdcard = navigator.getDeviceStorage('sdcard'); sdcard.onchange = function (change) { var reason = change.reason; var path = change.path; console.log('The file \"' + path + '\" has been ' + reason); } Copy","keywords":""},{"title":"MozWifiConnectionInfoEvent","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/mozwificonnectioninfoevent","content":"Description# The MozWifiConnectionInfoEvent interface provides developers with information regarding the state of the current Wifi connection. This interface also inherits from the Event interface. Properties# MozWifiConnectionInfoEvent.signalStrength read-only A number indicating the absolute strength of the signal in dBm. MozWifiConnectionInfoEvent.relSignalStrength read-only A number in the range [0,100] indicating the relative strength of the signal. MozWifiConnectionInfoEvent.linkSpeed read-only A number representing link speed in Mb/s. MozWifiConnectionInfoEvent.ipAddress read-only A string representing the IP address of the device in the dotted quad format. MozWifiConnectionInfoEvent.network read-only A network object representing the current network in use (null otherwise); see WifiManager.getNetworks for more detail about such objects. Methods# EventHandler:# WifiManager.onconnectioninfoupdateA handler for the connectioninfoupdate event; triggered any time the connection information changes. The event object is a MozWifiConnectionInfoEvent instance. Example# var wifi = navigator.mozWifiManager; wifi.onconnectioninfoupdate = function (event) { console.log('Update information for: ' + event.network.ssid); console.log('IP: ' + event.ipAddress); console.log('Speed: ' + event.linkSpeed.toFixed(2) + 'Mb/s'); console.log('Signal strength: ' + event.signalStrength.toFixed(2) + 'dBm (' + event.relSignalStrength.toFixed(0) + '%)'); } Copy","keywords":""},{"title":"MozWifiConnectionInfoEvent.ipAddress","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/mozwificonnectioninfoevent/ipaddress","content":"Description# The ipAddress property value provides the current IP address of the device in the dotted quad format. Syntax# var IP = instanceOfMozWifiConnectionInfoEvent.ipAddress Copy Value# A string.","keywords":""},{"title":"MozWifiConnectionInfoEvent.linkSpeed","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/mozwificonnectioninfoevent/linkspeed","content":"Description# The linkSpeed property value provides the current speed of the connection in Mb/s. Syntax# var speed = instanceOfMozWifiConnectionInfoEvent.linkSpeed Copy Value# A number.","keywords":""},{"title":"MozWifiConnectionInfoEvent.network","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/mozwificonnectioninfoevent/network","content":"Description# The network property value provides the current network in use when the connection state changes. Syntax# var network = instanceOfMozWifiConnectionInfoEvent.network Copy Value# A network object representing the current network in use (null otherwise); see WifiManager.getNetworks for more detail about such objects.","keywords":""},{"title":"MozWifiConnectionInfoEvent.signalStrength","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/mozwificonnectioninfoevent/signalstrength","content":"Description# The signalStrength property value provides the absolute strength of the signal in dBm. Syntax# var strength = instanceOfMozWifiConnectionInfoEvent.signalStrength Copy Value# A number.","keywords":""},{"title":"MozWifiStatusChangeEvent","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/mozwifistatuschangeevent","content":"Description# The MozWifiStatusChangeEvent interface provides developers with information regarding the current status of the Wifi connection. This interface also inherit from the Event interface Properties# MozWifiStatusChangeEvent.status read-only A string indicating the current status of the connection. MozWifiStatusChangeEvent.network read-only A network object representing the current network in use (null otherwise), see WifiManager.getNetworks for more detail about such objects. Methods# EventHandler:# WifiManager.onstatuschangeSpecifies an event listener to receive MozWifiStatusChangeEvent events. Those events occur when the device's WiFi connection status changes. Example# var wifi = navigator.mozWifiManager; wifi.onstatuschange = function (event) { console.log('The connection status is: ' + event.status); } Copy MozWifiStatusChangeEvent by Mozilla Contributors is licensed under CC-BY-SA 2.5.","keywords":""},{"title":"MozWifiStatusChangeEvent.network","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/mozwifistatuschangeevent/network","content":"Description# The network property value provides the current network in use when the connection status changes. Syntax# var network = instanceOfMozWifiStatusChangeEvent.network Copy Value# A network object representing the current network in use (null otherwise); see WifiManager.getNetworks for more detail about such objects.","keywords":""},{"title":"MozWifiStatusChangeEvent.status","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/mozwifistatuschangeevent/status","content":"Description# The status property value provides the current connection status. Syntax# var status = instanceOfMozWifiStatusChangeEvent.status Copy Value# A string, one of the following: connecting: the device enters the connection workflow.associated: the device is connected to an access point but does not have an IP address yet.connected: the device is fully connected via wifi and ready.connectingfailed: the device was unable to connect itself to a network.disconnected: the device was connected to a network but has disconnected for any reason.wps-timedout: a WPS connection attempt has timed out.wps-failed: a WPS connection attempt failed.wps-overlapped: a WPS connection attempt overlapped another one (this happens when two networks in the same area allow a pbs connection at the same time).authenticationfailed: The device was entered incorrect password.dhcpfailed: The device was obtained ip address failed.associationreject: The device was rejected with access point.","keywords":""},{"title":"WifiManager.associate()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/associate","content":"Description# The associate method is used to associate (and connect) a device with a given WiFi network. Syntax# var request = navigator.mozWifiManager.associate(network); Copy Parameters# network - A network object as the ones provided by the getNetworks or getKnownNetworks methods. Associating a secured network with the device requires setting some extra properties on the network object passed to the method: For network with WEP encryption method: wep: This property must be set with the proper password to access the network. For network with WPA-PSK encryption method: psk: This property must be set with the proper password to access the network. For network with WPA-EAP encryption method: eap: A string representing the EAP method to use.password: A string representing the password to access the network.identity: A string representing the identity to access the network.pin: A string representing the pin code required to access the network. Returns# It returns a DOMRequest to handle the success or error of the operation. A successful operation means than the device enters the connection workflow to the provided network. The success or failure of the connection itself can be tracked through the statuschange event by attaching an event handler to WifiManager.onstatuschange.","keywords":""},{"title":"WifiManager.connection","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/connection","content":"Description# The connection property value provides the status and current network in used by the WiFi adapter. Syntax# var mac = navigator.mozWifiManager.connection Copy Value# Return an object with the following properties: status read-only A string representing the current connection status, one of disconnected, connecting, associated, or connected (see MozWifiStatusChangeEvent.status for more information about each of those statuses). network read-only A network object representing the current network in use or null if the device is not connected to any network (see WifiManager.getNetworks() for more information about network objects).","keywords":""},{"title":"WifiManager.connectionInformation","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/connectioninformation","content":"Description# The connectionInformation property value provides extra information about the current connection. The value of that property is updated each time the connectionInfoUpdate event is triggered. Syntax# var info = navigator.mozWifiManager.connectionInformation Copy Value# Return an object with the following properties: signalStrength read-only A number indicating the absolute strength of the signal in dBm. relSignalStrength read-only A number in the range [0,100] indicating the relative strength of the signal. linkSpeed read-only A number representing link speed in Mb/s. ipAddress read-only A string representing the IP address of the device in the dotted quad format.","keywords":""},{"title":"WifiManager.forget()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/forget","content":"Description# The forget method is used to make a device forget about a given WiFi network. This will remove the network from the list of known networks and will remove all the configuration settings related to that network. If the device was connected to that network, it is disconnected from it. Syntax# var request = navigator.mozWifiManager.forget(network); Copy Parameters# network - A network object as the ones provided by the getNetworks or getKnownNetworks methods. Returns# It returns a DOMRequest to handle the success or error of the operation.","keywords":""},{"title":"WifiManager.onstatuschange","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/onstatuschange","content":"Description# Specifies an event listener to receive statuschange events. Those events occur when the device's WiFi connection status changes. Syntax# navigator.mozWifiManager.onstatuschange = funcRef Copy Where funcRef is a function to be called when the statuschange event occurs. This callback function receives a MozWifiStatusChangeEvent object as its first parameter.","keywords":""},{"title":"WifiManager.getKnownNetworks()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/getknownnetworks","content":"Description# The getKnownNetworks method is used to retrieve the whole list of WiFi networks the device knows, regardless if they are available or not in the area surrounding the device. A known network is any network the device previously associated with by using the WifiManager.associate() method. Syntax# var request = navigator.mozWifiManager.getKnownNetworks(); Copy Returns# It returns a DOMRequest to handle the success or error of the operation. If the operation is successful, the request's result is an Array of Network object. Network Those objects are regular JavaScript objects with the following properties: ssid read-only A string representing the ssid of the network. bssid read-only A string representing the bssid of the network. capabilities read-only An array of strings representing the special abilities of the network (currently, only WPS is supported). security read-only An array of strings representing the security model of the network (currently supports WEP, WPA-PSK, and WPA-EAP). signalStrength read-only A number indicating the absolute strength of the signal in dBm. relSignalStrength read-only A number in the range [0,100] indicating the relative strength of the signal. connected read-only A boolean indicating if the device is connected to that network. known read-only A boolean indicating if the network is already known by the device (it has been used already).","keywords":""},{"title":"WifiManager.onenabled","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/onenabled","content":"Description# Specifies an event listener to receive enabled events. Those events occur when the device's WiFi is turned on. Syntax# navigator.mozWifiManager.onenabled = funcRef Copy Where funcRef is a function to be called when the enabled event occurs.","keywords":""},{"title":"WifiManager.macAddress","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/macaddress","content":"Description# The macAddress property value provides the wifi adapter's MAC address. Syntax# var mac = navigator.mozWifiManager.macAddress Copy Value# Return a string.","keywords":""},{"title":"SESession","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/seSession/sesession","content":"Description# SESession interface represents a connection to one of the Secure Elements available on the device. These objects can be used to open and close communication channels with an applet. Properties# SESession.reader'reader' that provides this session SESession.isClosedStatus of current session Methods# SESession.getAtr()This attribute MUST return the historical bytes provided by the physical interface of the Secure Element or null if the interface does not provide it. SESession.openBasicChannel()Opens a communication basic channel to an application on Secure Element identified by the AID. SESession.openLogicalChannel()Opens a communication logical channel to an application on Secure Element identified by the AID. SESession.closeAll()Close all active channels associated with this session. Example# window.AID = { CRS: \"A00000015143525300\", PPSE: \"325041592E5359532E4444463031\", ISD:\"A000000151000000\" }; function hexString2byte(str) { var a = []; for(var i = 0, len = str.length; i < len; i+=2) { a.push(parseInt(str.substr(i, 2), 16)); } return new Uint8Array(a); } window.navigator.seManager.getSEReaders() .then((readers) => { window.reader = readers[0]; return readers[0].openSession(); }) .then((session) => { window.testSession = session; console.log(\"Open a session successfully\"); return session.openBasicChannel(hexString2byte(window.AID.ISD)); }) .then((channel) => { console.log(\"Open a basic channel successfully\"); return window.testSession.openLogicalChannel(hexString2byte(window.AID.ISD)); }) .then((channel) => { console.log(\"Open a logical channel successfully\"); return window.reader.closeAll(); }) .then(()=> { console.log(\"Close all channels successfully\"); }) .catch((err) => { console.log(\"Failed!!!\"); window.reader.closeAll(); }); Copy","keywords":""},{"title":"WifiManager.setStaticIpMode()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/setstaticipmode","content":"Description# The setStaticIpMod method is used to define a static or dynamic (if the network has a DHCP server) IP address for the device on a given network. Syntax# var request = navigator.mozWifiManager.setStaticIpMode(param); Copy Parameters# param A configuration object with the following properties: enabled: A boolean requesting if the static IP mode must be turned on (true) or off (false). If it's turned off and the current WiFi network is DHCP enabled, the device will get a dynamic IP.ipaddr: A string representing the IP address of the device in the dotted quad format.proxy: A string representing the proxy server address (if any, otherwise an empty string).maskLength: A number representing the length of the network mask.gateway: A string representing a gateway address (if any, otherwise an empty string).dns1: A string representing the first DNS server address.dns2: A string representing the second DNS server address. Returns# It returns a DOMRequest to handle the success or error of the operation.","keywords":""},{"title":"MozWifiConnectionInfoEvent.relSignalStrength","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/mozwificonnectioninfoevent/relsignalstrength","content":"Description# The relSignalStrength property value provides the relative strength of the signal. Syntax# var strength = instanceOfMozWifiConnectionInfoEvent.relSignalStrength Copy Value# A number in the range [0,100].","keywords":""},{"title":"WifiManager.onconnectioninfoupdate","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/onconnectioninfoupdate","content":"Description# Specifies an event listener to receive connectioninfoupdate events. Those events occur when the device's WiFi connection information changes. Syntax# navigator.mozWifiManager.onconnectioninfoupdate = funcRef Copy Where funcRef is a function to be called when the connectioninfoupdate event occurs. This callback function receives a MozWifiConnectionInfoEvent object as the first parameter.","keywords":""},{"title":"WifiManager.ondisabled","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/ondisabled","content":"Description# Specifies an event listener to receive disabled events. Those events occur when the device's WiFi is turned off. Syntax# navigator.mozWifiManager.ondisabled = funcRef Copy Where funcRef is a function to be called when the disabled event occurs.","keywords":""},{"title":"WifiManager.getNetworks()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/getnetworks","content":"Description# The getNetworks method is used to retrieve the whole list of available WiFi networks surrounding the device. Syntax# var request = navigator.mozWifiManager.getNetworks(); Copy Returns# It returns a DOMRequest to handle the success or error of the operation. If the operation is successful, the request's result is an Array of Network object. Network Those objects are regular JavaScript objects with the following properties: ssid read-only A string representing the ssid of the network.bssid read-only A string representing the bssid of the network.capabilities read-only An array of strings representing the special abilities of the network (currently, only WPS is supported).security read-only An array of strings representing the security model of the network (currently supports WEP, WPA-PSK, and WPA-EAP).signalStrength read-only A number indicating the absolute strength of the signal in dBm.relSignalStrength read-only A number in the range [0,100] indicating the relative strength of the signal.connected read-only A boolean indicating if the device is connected to that network.known read-only A boolean indicating if the network is already known by the device (it has been used already).","keywords":""},{"title":"WifiManager.enabled","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/enabled","content":"Description# The enabled property value indicates whether the wifi is turned on (true) or off (false). Note: Enabling or disabling WiFi can only been done by using the Settings API to change the wifi.enabled setting. Each time this setting changes, the WifiManager object will send an enabled or disabled event. Those events can be handled by using the WifiManager.onenabled and WifiManager.ondisabled event handlers. Syntax# var enabled = navigator.mozWifiManager.enabled Copy Value# Return a boolean.","keywords":""},{"title":"WifiManager.setPowerSavingMode()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/setpowersavingmode","content":"Description# The setPowerSavingMode method is used to have the WiFi adapter enter or exit the power saving mode. Syntax# var request = navigator.mozWifiManager.setPowerSavingMode(enabled); Copy Parameters# enabled A boolean indicating if the device must enter (true) or exit (false) the power saving mode. Returns# It returns a DOMRequest to handle the success or error of the operation.","keywords":""},{"title":"WifiManager.wps()","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager/wps","content":"Description# The wps method is used to handle a WPS connection with networks supporting that feature. A network supporting a WPS connection has the string WPS available within the WifiManager.capabilities Array. A WPS connection is a simpler way to connect a device to a network. It requires less knowledge from the user and makes things easier for him. Basically, when a user has a WPS-enabled WiFi router, he can choose that method to connect his device to the network instead of typing its password. There are two ways of initiating a WPS connection up to the user: The easiest one is by pressing a dedicated button on the WiFi router. An alternative is by entering a PIN number provided by the WiFi router. There are two use cases here: The WiFi router will send a PIN number to the device and the user has to type it on the WiFi router interface. The WiFi router expects the user to type a PIN number on his device (usually, such a PIN number is displayed on the WiFi router itself). Syntax# var request = navigator.mozWifiManager.wps(param); Copy Parameters# paramA configuration object with the following properties: method: A string, one of the following: cancel to abort a WPS connection attempt.pbs to try a connection by pushing the physical button on the WiFi router.pin to try a connection with a pin number. bssid: A string representing the bssid of the network to connect to. It is mandatory if the method property is set to pin.pin: A string representing the pin number typed by the user. It is mandatory if the method property is set to pin and the user had to type the pin on his device. Returns# It returns a DOMRequest to handle the success or error of the operation. When the method property is set to pin, if the operation is successful and if the user must type a pin number on his WiFi router interface, the request's result is a string representing the PIN number to type. Example# var wifi = navigator.mozWifiManager; var request = wifi.getNetworks(); request.onsuccess = function () { // Let's get the first network var network = this.result[0]; var isWPSEnabled = network.capabilities.indexOf('WPS') > -1; var wpsRequest; if (isWPSEnabled) { if (comfirm('Do you want to use the push button to connect your device?')) { wpsRequest = wifi.wps({ method : 'pbs' }); } else if (confirm('Do you want to type a PIN number on your WiFI router interface?')){ wpsRequest = wifi.wps({ method : 'pin', bssid : network.bssid }) wpsRequest.onsuccess = function () { alert('Please, type that number on your WiFi router interface: ' + this.result) } } else { wpsRequest = wifi.wps({ method : 'pin', bssid : network.bssid pin : prompt('Please, provide the PIN number of your WiFi router.') }) } } } Copy","keywords":""},{"title":"WifiManager","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifimanager","content":"Description# The WifiManager API provides access to the wifi device capability. Interface# interface WifiManager { readonly attribute boolean enabled; readonly attribute string macAddress; readonly attribute object connection; readonly attribute object connectionInformation; attribute nsIDOMEventListener onenabled; attribute nsIDOMEventListener ondisabled; attribute nsIDOMEventListener onstatuschange; attribute nsIDOMEventListener onconnectioninfoupdate; attribute nsIDOMEventListener onstationinfoupdate DOMRequest getNetworks(); DOMRequest getKnownNetworks(); DOMRequest associate(object network); DOMRequest forget(object network); DOMRequest wps(object detail); DOMRequest setPowerSavingMode(boolean enabled); DOMRequest setStaticIpMode(object network, object info) }; Copy Properties# WifiManager.enabled read-only A boolean indicating whether the wifi is on (true) or off (false). WifiManager.macAddress read-only A string representing the wifi adapter's MAC address. WifiManager.connection read-only An object providing information about the current connection (status and network in use). WifiManager.connectionInformation read-only An object providing extra information about the current connection or null if the device is not connected to the wifi. WifiManager.openNetworkNotify Returns whether or not openNetworkNotify is currently enabled. Event handlers# WifiManager.onenabled A handler for the enabled event; it is triggered when the wifi has been turned on. WifiManager.ondisabled A handler for the disabled event; it is triggered when the wifi has been turned off. WifiManager.onstatuschange A handler for the statuschange event; the event object is a MozWifiStatusChangeEvent instance. WifiManager.onconnectioninfoupdate A handler for the connectioninfoupdate event; triggered any time the connection information changes. The event object is a MozWifiConnectionInfoEvent instance. WifiManager.onopennetwork An event listener that is called with notification about the open wifi network available. Methods# WifiManager.associate() Allows to associate (and connect) a device with a given network. Returns a DOMRequest. WifiManager.forget() Allows to make a device no longer associate with a given network. Returns a DOMRequest. WifiManager.getKnownNetworks() Allows to retrieve the list of all the networks the device was associated with. Returns a DOMRequest. WifiManager.getNetworks() Allows to retrieve the list of all the networks available in the area surrounding the device. Returns a DOMRequest. WifiManager.setPowerSavingMode() Allows the wifi adapter to enter/exit power saving mode. Returns a DOMRequest. WifiManager.setStaticIpMode() Allows to configure a static IP address for the device on a given network. Returns a DOMRequest. WifiManager.wps() Allows to connect the device to a network using the network's WPS capability (if any). Returns a DOMRequest. WifiManager by Mozilla Contributors is licensed under CC-BY-SA 2.5.","keywords":""},{"title":"KaiStore","type":0,"sectionRef":"#","url":"docs/07.submit-to-kaistore","content":"About KaiStore is a service channel to showcase your product and allow users to install an app on their phones. This guide serves as a resource for you and makes sure your app icon, app name, description, and marketing banner are ready for your product page. App name An app name is a name for your product. It plays a crucial role in how users discover it on the KaiStore. Choose a simple, memorable name that is easy to spell and hints at what your app does. Avoid names that use generic terms or are too similar to existing app names. An app name should not be longer than 20 characters. Subtitle Your app’s subtitle appears below your app name throughout the KaiStore. A subtitle is a short and striking or memorable message, and is intended to summarize your app in a concise phrase. A compelling subtitle can encourage product page views and installs. The maximum length of a subtitle is 40 characters. Icon The app icon (aka. Launcher icon) is the first visual expression of the app, as it directly and effectively communicates the main feature and purpose with the user. Unified graphic elements allow you to create simple, intuitive, and consistent icons that reflect product characteristics and quality. These elements also ensure your app stands out from other ones. To ensure the icon is legible in all sizes, avoid adding unnecessary visual details. For more details, please go to Launcher Icon. Marketing banner Your marketing banner is a background image that appears behind the icon, app name, and subtitle. It helps communicate your app’s feature and purpose. Using an attractive image can encourage product page views and attract user attention. The image should be simple and subtle. Remove unnecessary visual details to ensure your icon, app name, and subtitle are legible. For more information, please go to marketing banner. Description Provide a succinct description that highlights the features and functionality of your app on the Product page. The ideal description is a concise, informative paragraph that introduces your app in a few sentences. Such a description will maximize user engagement. Don’t add unnecessary keywords to your description in an attempt to improve search results. Also avoid including specific prices in your app description. Pricing is already shown on the product page, and references within the description may not be accurate in all countries and territories. Category You can assign one category to your app so that users can find it while browsing the KaiStore. The category you select is particularly important for your app’s discoverability on the KaiStore. This will be the category in which the app appears when users browse the KaiStore. Be sure to select a proper category from the list below that best describes the primary function of your app. A list of categories for apps GamesSocialEntertainmentUtilitiesSportsNewsHealthLifestyleShoppingBooks & Reference Theme color The color theme represents the focus color of an app in the All Apps view when the user selects the app. For more information, please go to marketing banner. Status tags for app These tags displays your App's price and enabled states on the Launch page and Product page. Status Tags on the launch page. Free tag in product page, press center key \"GET\" to start downloading. Price tag in product page, press center key \"BUY\" to go payment page. Update tag Reminder to update. On the product page press center key \"UPDATE\" to get new version. Enabled tag Indicates App has been installed successfully, the tag will display to check icon. On the product page press center key \"GO\" to launch App. Downloading Downloading App or update. On the product page press center key \"STOP\" to cancel downloading. Status tag for website The tags displays your Website enabled states on the Launch page and Product page. Status Tags on the launch page. Status Tags on the launch page. Status Tags on the launch page. Submit my app Thank you for your interest in contributing to the KaiOS platform. Please have a look at our App Submission and Distribution Agreement which you would accept before you could submit your app. Currently, we are only accepting apps that are monetized using KaiAds SDK. Most apps on the developer portal are for QA that use KaiAds for monetization. Visit the KaiAds website to learn more. After you have integrated KaiAds, go through this checklist. We hope you have read all the documentation on the portal. This will help you understand what is considered a qualified app for KaiOS. Make sure the name of the app is relevant to the app. You can’t have a generic app name such as wallpaper, ringtone, wallet, phone, etc. Prepare an app manifest for the required fields. You cannot submit your app without a proper manifest so make sure you read this section carefully. We test your apps on 512MB as well has 256MB devices. We recommend you to optimize the performance of the apps so that you can reach our global audience. You can learn about improving the performance of your app through this article. The type of your app in the manifest file. Hosted app, the type can only be type: \"web\".Native app should be \"web\" by default.If your app needs to access Privileged or Certified APIs, Justify it in the \"Known Issue\" section on the submission portal. If you have any comments for our QA team, you can mention them in \"known issues\" on the Submission Portal. You only need to submit two app icons. (56x56 and 112x112) Read our UI design guidelines carefully. Include Subtitles and App Description Page. This is the first texts that users will see, having better app descriptions have proved to increase the app downloads.Subtitle text limit - 40 characters (including white spaces), Description text limit - 220 characters (including white spaces). You can test your Submitted Application on any KaiOS phone that has KaiStore available on it. Once you have submitted your app on the Submission Portal, click on 'Test Device'.Enter the IMEI of your KaiOS device and after 5 minutes you will be able to view your app on the device KaiStore. Test your app, and if you find any unusual behavior, fix the changes and upload the new version. Once you have submitted your app, the KaiStore team will review your submission and inform you of the result. If you donʼt hear from us within three weeks, please contact developersupport@kaiostech.com Submission Portal To submit your app, visit the Submission Portal. The KaiStore team reserves the right to reject your app under the following circumstances: The above steps have not been followed.The required materials have not been submitted or are incomplete.Your app does not meet our quality threshold in areas such as 'Basic function', 'Interaction', 'Stability', as well as 'Compatibility'.","keywords":""},{"title":"WiFi Information","type":0,"sectionRef":"#","url":"docs/06.api/web-apis/wifiInformation/wifi-information","content":"Description# The WiFi Information API is specifically made to handle WiFi connections on a KaiOS device. It provides an interface to find available WiFi networks and handle connecting and disconnecting the device from those networks. Global information# The WifiManager interface provides global information about the status of the WiFi capabilities of the device. The WifiManager.enabled property simply states if the WiFi adapter is turned on or off. Note: Enabling or disabling WiFi can only been done by using the Settings API to change the wifi.enabled setting. Each time this setting changes, the WifiManager object will send an enabled or disabled event. Those events can be handled by using the WifiManager.onenabled and WifiManager.ondisabled event handlers. The WifiManager.macAddress property provides the MAC address of the WiFi adapter. The WifiManager.connection property provides information about the current connection. It's an object with two properties: status - A string, one of \"disconnected\", \"connecting\", \"associated\", or \"connected\".network - If connected or associated, a network object with all the information about that network (see below). The WifiManager.connectionInformation property provides some extra information if the device is connected to the WiFi (otherwise, it's null). It's an object with the following properties: signalStrength - A number indicating the absolute strength of the signal in dBm.relSignalStrength - A number in the range [0,100] indicating the relative strength of the signal.linkSpeed - A number representing link speed in Mb/s.ipAddress - A string representing the IP address of the device in the dotted quad format. Find and retrieve networks# In order to connect a device to a WiFi network, the first thing to do is get information about the network to connect. This can be done with the WifiManager.getNetworks() method which scans the area to find all the current available networks. It's also possible to use the WifiManager.getKnownNetworks() method which will provide the list of all the networks the device already knows, regardless if they are available or not. Both methods return a DOMRequest object to handle the success or error of the operation. In case of success the request's result is an Array of network objects. Each of those objects are regular JavaScript objects with properties about a given network: ssid - A string representing the ssid of the network.bssid - A string representing the bssid of the network.capabilities - An array of strings representing the special abilities of the network (currently, only WPS is supported).security - An array of strings representing the security model of the network (currently supports WEP, WPA-PSK, and WPA-EAP).signalStrength - A number indicating the absolute strength of the signal in dBm.relSignalStrength - A number in the range [0,100] indicating the relative strength of the signal.connected - A boolean indicating if the device is connected to that network.known - A boolean indicating if the network is already known by the device (it has been used already). var wifi = navigator.mozWifiManager; function sortNetworksByStrength(a, b) { return a.signalStrength > b.signalStrength ? -1 : 1; } var request = wifi.getNetworks(); request.onsuccess = function () { console.log('The following networks are available:'); var networks = this.result; networks.sort(sortNetworksByStrength); networks.forEach(function (network) { console.log(network.ssid, ' (', network.relSignalStrength.toFixed(0), ')'); }) } request.onerror = function (err) { console.log('Something goes wrong: ' + err); } Copy Handling connections# Handling a connection is pretty simple. If the device found a network it already knows, it connects to it automatically. A known network is any network the device has been previously connected to. Although this is often convenient for the user, it can be annoying sometimes. So, if necessary, it's possible to make the device forget a given network by using the WifiManager.forget() method. var wifi = navigator.mozWifiManager // Let's make the device forget about all the networks it knows request = wifi.getKnownNetworks(); request.onsuccess = function () { var networks = this.result; networks.forEach(function (network) { wifi.forget(network); }); } Copy Manual connection# The connection workflow is quite simple. To try to connect the device to a WiFi network, it just requires to pick a network and associate the device with that network. Such an association is done with the WifiManager.associate() method. Once that method is called the device tries to connect itself to that network, entering the connection workflow. Each step of the connection workflow can be tracked thanks to the connection events (see below). var wifi = navigator.mozWifiManager; function sortNetworksByStrength(a, b) { return a.signalStrength > b.signalStrength ? -1 : 1; } var request = wifi.getNetworks(); request.onsuccess = function () { console.log('The following networks are available:'); var networks = this.result; networks.sort(sortNetworksByStrength); // Let's try to connect the device to the strongest network wifi.associate(networks[0]); } Copy Once a connection is established, the last thing remaining is setting an IP address for the device. If the network is configured with DHCP, no problem, a dynamic IP will be assigned to the device. However, if it's not the case or if the user wants to set the IP address manually, this can be done with the WifiManager.setStaticIpMode() method. This method expects two parameter, a network object and a configuration object. The configuration object must have the following properties: enabled - A boolean requesting if the static IP mode must be turned on (true) or off (false).ipaddr - A string representing the IP address of the device in the dotted quad format.proxy - A string representing the proxy server address (if any, otherwise an empty string).maskLength - A number representing the length of the network mask.gateway - A string representing a gateway address (if any, otherwise an empty string).dns1 - A string representing the first DNS server address.dns2 - A string representing the second DNS server address. Secured connection# Connecting to a secure WiFi network is not really harder but it necessitates taking care of a few things. WEP/WPA# When retrieving a network, its security property will provide the kind of encryption used by that network. security is an Array of strings, each string representing an encryption method usable with that network. Currently, KaiOS supports WEP, WPA-PSK, and WPA-EAP. Associating a secured network with the device is done the same way as for an open network with the WifiManager.associate() method. However, this time it's necessary to set some extra properties to the network object passed to the method, which depend on the encryption method: For network with WEP encryption method: wep : This property must be set with the proper password to access the network. For network with WPA-PSK encryption method: psk : This property must be set with the proper password to access the network. For network with WPA-EAP encryption method: eap : A string representing the EAP method to use.password : A string representing the password to access the network.identity : A string representing the identity to access the network.pin : A string representing the pin code required to access the network. var wifi = navigator.mozWifiManager; var request = wifi.getNetworks(); request.onsuccess = function () { // Let's get the first network var network = this.result[0]; var security = network.security[0]; if (security === 'WEP') { network.wep = prompt('This network requires a WEP password:'); } else if (security === 'WPA-PSK') { network.psk = prompt('This network requires a WPA Key:'); } else if (security === 'WPA-EAP') { network.eap = prompt('Which EAP method should be used:'); network.identity = prompt('Which identity should be used:'); network.password = prompt('This network requires a password:'); network.pin = prompt('Thanks to finally provide your own PIN:'); } // Let's try to connect the device to the network wifi.associate(network); } Copy WPS# WPS connection is a simpler way to connect a device to a network. It requires less knowledge from the user and makes things easier for him. Basically, when a user has a WPS enable WiFi router, he can choose that method to connect the device to the network instead of typing a password. It can be useful for WPA-PSK secured networks because their keys can be very long and hard to type. To know if a network is WPS enabled, just check the network.capabilities array. If the network allows it, it's possible to follow the WPS process to associate the device with the network. Each step of the process is handled through the WifiManager.wps() method, which returns a DOMRequest object to handle the success or error of the process. There are two ways of initiating a WPS connection up to the user: The easiest one is by pressing a dedicated button on the WiFi router. In that case, the parameter object passed to the wps() method must have a property named method with the value pbc.An alternative is by entering a PIN provided by the WiFi router. There are two use cases here: The WiFi router will send a PIN to the device and the user has to type it on the WiFi router interface. In such a case, the parameter object passed to the wps() method must have a property named method with the value pin and a property named bssid with the bssid of the network. The WiFi router expects the user to type a PIN on his device (usually, such a PIN is displayed on the WiFi router itself). In such case, the parameter object passed to the wps() method must have a property named method with the value pin, a property named pin with the PIN provided by the user, and a property named bssid with the bssid of the network. var wifi = navigator.mozWifiManager; var request = wifi.getNetworks(); request.onsuccess = function () { // Let's get the first network var network = this.result[0]; var isWPSEnabled = network.capabilities.indexOf('WPS') > -1; var wpsRequest; if (isWPSEnabled) { if (comfirm('Do you want to use the push button to connect your device?')) { wpsRequest = wifi.wps({ method : 'pbs' }); } else if (confirm('Do you want to type a PIN on your WiFI router interface?')){ wpsRequest = wifi.wps({ method : 'pin', bssid : network.bssid }) wpsRequest.onsucces = function () { alert('Please, type that number on your WiFi router interface: ' + this.result) } } else { wpsRequest = wifi.wps({ method : 'pin', bssid : network.bssid pin : prompt('Please, provide the PIN for your WiFi router.') }) } } } Copy Once a connection has been initialized successfully, the completion of the connection process can be tracked through the connection events (see below). As long as the connection process is not complete, it's possible to cancel a WPS connection by calling the wps() method with a parameter object which has a property named method with the value cancel. Events# Connection events - When a device tries to connect itself to a WiFi network (or is disconnected from such a network), it sends several statuschange events. Possible statuses are the following: connecting - The device entered the connection workflow. associated - The device is connected to an access point but does not have an IP address yet. connected - The device is fully connected via wifi and ready. connectingfailed - The device was unable to connect itself to a network. disconnected - The device was connected to a network but has disconnected for any reason. wps-timedout - The WPS connection has timed out. wps-failed - The WPS connection failed. wps-overlapped - A WPS connection overlaps (this happens when two networks in the same area allow a pbs connection at the same time). authenticationfailed - The device was entered incorrect password. dhcpfailed - The device was obtained ip address failed. associationreject - The device was rejected with access point. To listen to those events it's mandatory to use the WifiManager.onstatuschange event handler. Any callback function associated to that handler receives a MozWifiStatusChangeEvent as its first parameter. var wifi = navigator.mozWifiManager; wifi.onstatuschange = function (event) { console.log('The connection status is: ' + event.status); } Copy Ongoing connection# Once the device is connected to a network, the WifiManager.connectionInformation property provides extra information about the connection (see above). However, each time that information changes, the WiFiManager is notified with a connectioninfoupdate event. Such an event can be listened for with the WifiManager.onconnectioninfoupdate event handler. Any callback function associated to that handler receives a MozWifiConnectionInfoEvent as its first parameter. Such an object provides the same information as the WifiManager.connectionInformation property and also provides the corresponding network object. var wifi = navigator.mozWifiManager; wifi.onconnectioninfoupdate = function (event) { console.log('Update information for: ' + event.network.ssid); console.log('IP: ' + event.ipAddress); console.log('Speed: ' + event.linkSpeed.toFixed(2) + 'Mb/s'); console.log('Signal strength: ' + event.signalStrength.toFixed(2) + 'dBm (' + event.relSignalStrength.toFixed(0) + '%)'); } Copy","keywords":""}]